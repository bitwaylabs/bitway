// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bitway/tss/tss.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DKG Status
type DKGStatus int32

const (
	// DKG_STATUS_UNSPECIFIED defines the unknown DKG request status
	DKGStatus_DKG_STATUS_UNSPECIFIED DKGStatus = 0
	// DKG_STATUS_PENDING defines the status of the DKG request which is pending
	DKGStatus_DKG_STATUS_PENDING DKGStatus = 1
	// DKG_STATUS_COMPLETED defines the status of the DKG request which is completed
	DKGStatus_DKG_STATUS_COMPLETED DKGStatus = 2
	// DKG_STATUS_FAILED defines the status of the DKG request which failed
	DKGStatus_DKG_STATUS_FAILED DKGStatus = 3
	// DKG_STATUS_TIMEDOUT defines the status of the DKG request which timed out
	DKGStatus_DKG_STATUS_TIMEDOUT DKGStatus = 4
)

var DKGStatus_name = map[int32]string{
	0: "DKG_STATUS_UNSPECIFIED",
	1: "DKG_STATUS_PENDING",
	2: "DKG_STATUS_COMPLETED",
	3: "DKG_STATUS_FAILED",
	4: "DKG_STATUS_TIMEDOUT",
}

var DKGStatus_value = map[string]int32{
	"DKG_STATUS_UNSPECIFIED": 0,
	"DKG_STATUS_PENDING":     1,
	"DKG_STATUS_COMPLETED":   2,
	"DKG_STATUS_FAILED":      3,
	"DKG_STATUS_TIMEDOUT":    4,
}

func (x DKGStatus) String() string {
	return proto.EnumName(DKGStatus_name, int32(x))
}

func (DKGStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{0}
}

// Signing Status
type SigningStatus int32

const (
	// SIGNING_STATUS_UNSPECIFIED defines the unknown signing status
	SigningStatus_SIGNING_STATUS_UNSPECIFIED SigningStatus = 0
	// SIGNING_STATUS_PENDING defines the status of the signing request which is pending
	SigningStatus_SIGNING_STATUS_PENDING SigningStatus = 1
	// SIGNING_STATUS_SIGNED defines the status of the signing request which is signed
	SigningStatus_SIGNING_STATUS_SIGNED SigningStatus = 2
	// SIGNING_STATUS_FAILED defines the status of the signing request which failed due to unexpected reasons
	SigningStatus_SIGNING_STATUS_FAILED SigningStatus = 3
)

var SigningStatus_name = map[int32]string{
	0: "SIGNING_STATUS_UNSPECIFIED",
	1: "SIGNING_STATUS_PENDING",
	2: "SIGNING_STATUS_SIGNED",
	3: "SIGNING_STATUS_FAILED",
}

var SigningStatus_value = map[string]int32{
	"SIGNING_STATUS_UNSPECIFIED": 0,
	"SIGNING_STATUS_PENDING":     1,
	"SIGNING_STATUS_SIGNED":      2,
	"SIGNING_STATUS_FAILED":      3,
}

func (x SigningStatus) String() string {
	return proto.EnumName(SigningStatus_name, int32(x))
}

func (SigningStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{1}
}

// Signing Type
type SigningType int32

const (
	// SIGNING_TYPE_SCHNORR defines the common schnorr signing
	SigningType_SIGNING_TYPE_SCHNORR SigningType = 0
	// SIGNING_TYPE_SCHNORR_WITH_TWEAK defines the schnorr signing with tweak
	SigningType_SIGNING_TYPE_SCHNORR_WITH_TWEAK SigningType = 1
	// SIGNING_TYPE_SCHNORR_WITH_COMMITMENT defines the schnorr signing with commitment
	SigningType_SIGNING_TYPE_SCHNORR_WITH_COMMITMENT SigningType = 2
	// SIGNING_TYPE_SCHNORR_ADAPTOR defines the schnorr adaptor signing
	SigningType_SIGNING_TYPE_SCHNORR_ADAPTOR SigningType = 3
)

var SigningType_name = map[int32]string{
	0: "SIGNING_TYPE_SCHNORR",
	1: "SIGNING_TYPE_SCHNORR_WITH_TWEAK",
	2: "SIGNING_TYPE_SCHNORR_WITH_COMMITMENT",
	3: "SIGNING_TYPE_SCHNORR_ADAPTOR",
}

var SigningType_value = map[string]int32{
	"SIGNING_TYPE_SCHNORR":                 0,
	"SIGNING_TYPE_SCHNORR_WITH_TWEAK":      1,
	"SIGNING_TYPE_SCHNORR_WITH_COMMITMENT": 2,
	"SIGNING_TYPE_SCHNORR_ADAPTOR":         3,
}

func (x SigningType) String() string {
	return proto.EnumName(SigningType_name, int32(x))
}

func (SigningType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{2}
}

// Refreshing Status
type RefreshingStatus int32

const (
	// REFRESHING_STATUS_UNSPECIFIED defines the unknown refreshing status
	RefreshingStatus_REFRESHING_STATUS_UNSPECIFIED RefreshingStatus = 0
	// REFRESHING_STATUS_PENDING defines the status of the refreshing request which is pending
	RefreshingStatus_REFRESHING_STATUS_PENDING RefreshingStatus = 1
	// REFRESHING_STATUS_COMPLETED defines the status of the refreshing request which is completed
	RefreshingStatus_REFRESHING_STATUS_COMPLETED RefreshingStatus = 2
	// REFRESHING_STATUS_TIMEDOUT defines the status of the refreshing request which timed out
	RefreshingStatus_REFRESHING_STATUS_TIMEDOUT RefreshingStatus = 3
)

var RefreshingStatus_name = map[int32]string{
	0: "REFRESHING_STATUS_UNSPECIFIED",
	1: "REFRESHING_STATUS_PENDING",
	2: "REFRESHING_STATUS_COMPLETED",
	3: "REFRESHING_STATUS_TIMEDOUT",
}

var RefreshingStatus_value = map[string]int32{
	"REFRESHING_STATUS_UNSPECIFIED": 0,
	"REFRESHING_STATUS_PENDING":     1,
	"REFRESHING_STATUS_COMPLETED":   2,
	"REFRESHING_STATUS_TIMEDOUT":    3,
}

func (x RefreshingStatus) String() string {
	return proto.EnumName(RefreshingStatus_name, int32(x))
}

func (RefreshingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{3}
}

// DKG Request
type DKGRequest struct {
	// request id
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// initiator module
	Module string `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	// dkg type
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// dkg intent
	Intent int32 `protobuf:"varint,4,opt,name=intent,proto3" json:"intent,omitempty"`
	// participant set
	Participants []string `protobuf:"bytes,5,rep,name=participants,proto3" json:"participants,omitempty"`
	// threshold required to perform DKG
	Threshold uint32 `protobuf:"varint,6,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// batch size of keys to be generated
	BatchSize uint32 `protobuf:"varint,7,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	// expiration time
	ExpirationTime time.Time `protobuf:"bytes,8,opt,name=expiration_time,json=expirationTime,proto3,stdtime" json:"expiration_time"`
	// status
	Status DKGStatus `protobuf:"varint,9,opt,name=status,proto3,enum=bitway.tss.DKGStatus" json:"status,omitempty"`
}

func (m *DKGRequest) Reset()         { *m = DKGRequest{} }
func (m *DKGRequest) String() string { return proto.CompactTextString(m) }
func (*DKGRequest) ProtoMessage()    {}
func (*DKGRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{0}
}
func (m *DKGRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGRequest.Merge(m, src)
}
func (m *DKGRequest) XXX_Size() int {
	return m.Size()
}
func (m *DKGRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DKGRequest proto.InternalMessageInfo

func (m *DKGRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DKGRequest) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *DKGRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DKGRequest) GetIntent() int32 {
	if m != nil {
		return m.Intent
	}
	return 0
}

func (m *DKGRequest) GetParticipants() []string {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *DKGRequest) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *DKGRequest) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *DKGRequest) GetExpirationTime() time.Time {
	if m != nil {
		return m.ExpirationTime
	}
	return time.Time{}
}

func (m *DKGRequest) GetStatus() DKGStatus {
	if m != nil {
		return m.Status
	}
	return DKGStatus_DKG_STATUS_UNSPECIFIED
}

// DKG Completion
type DKGCompletion struct {
	// request id
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// sender
	Sender string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// public keys generated by DKG
	PubKeys []string `protobuf:"bytes,3,rep,name=pub_keys,json=pubKeys,proto3" json:"pub_keys,omitempty"`
	// participant consensus pub key
	ConsensusPubkey string `protobuf:"bytes,4,opt,name=consensus_pubkey,json=consensusPubkey,proto3" json:"consensus_pubkey,omitempty"`
	// hex encoded participant signature
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DKGCompletion) Reset()         { *m = DKGCompletion{} }
func (m *DKGCompletion) String() string { return proto.CompactTextString(m) }
func (*DKGCompletion) ProtoMessage()    {}
func (*DKGCompletion) Descriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{1}
}
func (m *DKGCompletion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DKGCompletion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DKGCompletion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DKGCompletion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DKGCompletion.Merge(m, src)
}
func (m *DKGCompletion) XXX_Size() int {
	return m.Size()
}
func (m *DKGCompletion) XXX_DiscardUnknown() {
	xxx_messageInfo_DKGCompletion.DiscardUnknown(m)
}

var xxx_messageInfo_DKGCompletion proto.InternalMessageInfo

func (m *DKGCompletion) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DKGCompletion) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *DKGCompletion) GetPubKeys() []string {
	if m != nil {
		return m.PubKeys
	}
	return nil
}

func (m *DKGCompletion) GetConsensusPubkey() string {
	if m != nil {
		return m.ConsensusPubkey
	}
	return ""
}

func (m *DKGCompletion) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// Signing Options
type SigningOptions struct {
	// optional tweak
	Tweak string `protobuf:"bytes,1,opt,name=tweak,proto3" json:"tweak,omitempty"`
	// optional public nonce, i.e. commitment
	Nonce string `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// optional adaptor point
	AdaptorPoint string `protobuf:"bytes,3,opt,name=adaptor_point,json=adaptorPoint,proto3" json:"adaptor_point,omitempty"`
}

func (m *SigningOptions) Reset()         { *m = SigningOptions{} }
func (m *SigningOptions) String() string { return proto.CompactTextString(m) }
func (*SigningOptions) ProtoMessage()    {}
func (*SigningOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{2}
}
func (m *SigningOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningOptions.Merge(m, src)
}
func (m *SigningOptions) XXX_Size() int {
	return m.Size()
}
func (m *SigningOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SigningOptions proto.InternalMessageInfo

func (m *SigningOptions) GetTweak() string {
	if m != nil {
		return m.Tweak
	}
	return ""
}

func (m *SigningOptions) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *SigningOptions) GetAdaptorPoint() string {
	if m != nil {
		return m.AdaptorPoint
	}
	return ""
}

// Signing Request
type SigningRequest struct {
	// request id
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// initiator module
	Module string `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	// module specific id
	ScopedId string `protobuf:"bytes,3,opt,name=scoped_id,json=scopedId,proto3" json:"scoped_id,omitempty"`
	// signing type
	Type SigningType `protobuf:"varint,4,opt,name=type,proto3,enum=bitway.tss.SigningType" json:"type,omitempty"`
	// signing intent
	Intent int32 `protobuf:"varint,5,opt,name=intent,proto3" json:"intent,omitempty"`
	// signing pub key
	PubKey string `protobuf:"bytes,6,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// hashes to be signed
	SigHashes []string `protobuf:"bytes,7,rep,name=sig_hashes,json=sigHashes,proto3" json:"sig_hashes,omitempty"`
	// signing options
	Options *SigningOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	// creation time
	CreationTime time.Time `protobuf:"bytes,9,opt,name=creation_time,json=creationTime,proto3,stdtime" json:"creation_time"`
	// status
	Status SigningStatus `protobuf:"varint,10,opt,name=status,proto3,enum=bitway.tss.SigningStatus" json:"status,omitempty"`
}

func (m *SigningRequest) Reset()         { *m = SigningRequest{} }
func (m *SigningRequest) String() string { return proto.CompactTextString(m) }
func (*SigningRequest) ProtoMessage()    {}
func (*SigningRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{3}
}
func (m *SigningRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningRequest.Merge(m, src)
}
func (m *SigningRequest) XXX_Size() int {
	return m.Size()
}
func (m *SigningRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SigningRequest proto.InternalMessageInfo

func (m *SigningRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SigningRequest) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *SigningRequest) GetScopedId() string {
	if m != nil {
		return m.ScopedId
	}
	return ""
}

func (m *SigningRequest) GetType() SigningType {
	if m != nil {
		return m.Type
	}
	return SigningType_SIGNING_TYPE_SCHNORR
}

func (m *SigningRequest) GetIntent() int32 {
	if m != nil {
		return m.Intent
	}
	return 0
}

func (m *SigningRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *SigningRequest) GetSigHashes() []string {
	if m != nil {
		return m.SigHashes
	}
	return nil
}

func (m *SigningRequest) GetOptions() *SigningOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *SigningRequest) GetCreationTime() time.Time {
	if m != nil {
		return m.CreationTime
	}
	return time.Time{}
}

func (m *SigningRequest) GetStatus() SigningStatus {
	if m != nil {
		return m.Status
	}
	return SigningStatus_SIGNING_STATUS_UNSPECIFIED
}

// Refreshing Request
type RefreshingRequest struct {
	// request id
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// request id of the DKG corresponding to the key shares to be refreshed
	DkgId uint64 `protobuf:"varint,2,opt,name=dkg_id,json=dkgId,proto3" json:"dkg_id,omitempty"`
	// removed participant set
	RemovedParticipants []string `protobuf:"bytes,3,rep,name=removed_participants,json=removedParticipants,proto3" json:"removed_participants,omitempty"`
	// new threshold
	Threshold uint32 `protobuf:"varint,4,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// expiration time
	ExpirationTime time.Time `protobuf:"bytes,5,opt,name=expiration_time,json=expirationTime,proto3,stdtime" json:"expiration_time"`
	// status
	Status RefreshingStatus `protobuf:"varint,6,opt,name=status,proto3,enum=bitway.tss.RefreshingStatus" json:"status,omitempty"`
}

func (m *RefreshingRequest) Reset()         { *m = RefreshingRequest{} }
func (m *RefreshingRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshingRequest) ProtoMessage()    {}
func (*RefreshingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{4}
}
func (m *RefreshingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RefreshingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshingRequest.Merge(m, src)
}
func (m *RefreshingRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshingRequest proto.InternalMessageInfo

func (m *RefreshingRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RefreshingRequest) GetDkgId() uint64 {
	if m != nil {
		return m.DkgId
	}
	return 0
}

func (m *RefreshingRequest) GetRemovedParticipants() []string {
	if m != nil {
		return m.RemovedParticipants
	}
	return nil
}

func (m *RefreshingRequest) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *RefreshingRequest) GetExpirationTime() time.Time {
	if m != nil {
		return m.ExpirationTime
	}
	return time.Time{}
}

func (m *RefreshingRequest) GetStatus() RefreshingStatus {
	if m != nil {
		return m.Status
	}
	return RefreshingStatus_REFRESHING_STATUS_UNSPECIFIED
}

// Refreshing Completion
type RefreshingCompletion struct {
	// request id
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// sender
	Sender string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// participant consensus pub key
	ConsensusPubkey string `protobuf:"bytes,3,opt,name=consensus_pubkey,json=consensusPubkey,proto3" json:"consensus_pubkey,omitempty"`
	// hex encoded participant signature
	Signature string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *RefreshingCompletion) Reset()         { *m = RefreshingCompletion{} }
func (m *RefreshingCompletion) String() string { return proto.CompactTextString(m) }
func (*RefreshingCompletion) ProtoMessage()    {}
func (*RefreshingCompletion) Descriptor() ([]byte, []int) {
	return fileDescriptor_429ab65fe5c6256b, []int{5}
}
func (m *RefreshingCompletion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshingCompletion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshingCompletion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RefreshingCompletion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshingCompletion.Merge(m, src)
}
func (m *RefreshingCompletion) XXX_Size() int {
	return m.Size()
}
func (m *RefreshingCompletion) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshingCompletion.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshingCompletion proto.InternalMessageInfo

func (m *RefreshingCompletion) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RefreshingCompletion) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *RefreshingCompletion) GetConsensusPubkey() string {
	if m != nil {
		return m.ConsensusPubkey
	}
	return ""
}

func (m *RefreshingCompletion) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func init() {
	proto.RegisterEnum("bitway.tss.DKGStatus", DKGStatus_name, DKGStatus_value)
	proto.RegisterEnum("bitway.tss.SigningStatus", SigningStatus_name, SigningStatus_value)
	proto.RegisterEnum("bitway.tss.SigningType", SigningType_name, SigningType_value)
	proto.RegisterEnum("bitway.tss.RefreshingStatus", RefreshingStatus_name, RefreshingStatus_value)
	proto.RegisterType((*DKGRequest)(nil), "bitway.tss.DKGRequest")
	proto.RegisterType((*DKGCompletion)(nil), "bitway.tss.DKGCompletion")
	proto.RegisterType((*SigningOptions)(nil), "bitway.tss.SigningOptions")
	proto.RegisterType((*SigningRequest)(nil), "bitway.tss.SigningRequest")
	proto.RegisterType((*RefreshingRequest)(nil), "bitway.tss.RefreshingRequest")
	proto.RegisterType((*RefreshingCompletion)(nil), "bitway.tss.RefreshingCompletion")
}

func init() { proto.RegisterFile("bitway/tss/tss.proto", fileDescriptor_429ab65fe5c6256b) }

var fileDescriptor_429ab65fe5c6256b = []byte{
	// 963 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x15, 0xf5, 0xb2, 0x79, 0x63, 0x39, 0xcc, 0x44, 0xb6, 0x69, 0xc5, 0x96, 0x54, 0xa5, 0x0b,
	0xd5, 0x45, 0x25, 0x24, 0xcd, 0x0f, 0xc8, 0x22, 0x2d, 0x13, 0x8a, 0x1e, 0xa0, 0x68, 0x04, 0xed,
	0x86, 0xa0, 0xc4, 0x09, 0x45, 0x48, 0x22, 0x59, 0xcd, 0xb0, 0x89, 0xb2, 0xeb, 0xa6, 0x45, 0x77,
	0xde, 0x14, 0x28, 0xd0, 0x8f, 0xe9, 0x36, 0xcb, 0x2c, 0xbb, 0x6a, 0x0b, 0xfb, 0x47, 0x0a, 0x0e,
	0xa9, 0x87, 0x25, 0xb9, 0x68, 0x9a, 0x85, 0x01, 0xde, 0x73, 0x2e, 0x39, 0x73, 0xcf, 0x3d, 0xc7,
	0x10, 0x64, 0xfb, 0x36, 0x7d, 0x63, 0xcc, 0xaa, 0x94, 0x90, 0xe0, 0xaf, 0xe2, 0x4d, 0x5d, 0xea,
	0x22, 0x08, 0xd1, 0x0a, 0x25, 0x24, 0x97, 0xb5, 0x5c, 0xcb, 0x65, 0x70, 0x35, 0x78, 0x0a, 0x3b,
	0x72, 0x05, 0xcb, 0x75, 0xad, 0x31, 0xae, 0xb2, 0xaa, 0xef, 0xbf, 0xae, 0x52, 0x7b, 0x82, 0x09,
	0x35, 0x26, 0x5e, 0xd8, 0x50, 0xfa, 0x3d, 0x0e, 0x20, 0x35, 0x1b, 0x2a, 0xfe, 0xce, 0xc7, 0x84,
	0xa2, 0x7d, 0x88, 0xdb, 0xa6, 0xc8, 0x15, 0xb9, 0x72, 0x52, 0x8d, 0xdb, 0x26, 0x3a, 0x84, 0xf4,
	0xc4, 0x35, 0xfd, 0x31, 0x16, 0xe3, 0x45, 0xae, 0xcc, 0xab, 0x51, 0x85, 0x10, 0x24, 0xe9, 0xcc,
	0xc3, 0x62, 0x82, 0xa1, 0xec, 0x39, 0xe8, 0xb5, 0x1d, 0x8a, 0x1d, 0x2a, 0x26, 0x8b, 0x5c, 0x39,
	0xa5, 0x46, 0x15, 0x2a, 0xc1, 0x9e, 0x67, 0x4c, 0xa9, 0x3d, 0xb0, 0x3d, 0xc3, 0xa1, 0x44, 0x4c,
	0x15, 0x13, 0x65, 0x5e, 0xbd, 0x83, 0xa1, 0x13, 0xe0, 0xe9, 0x70, 0x8a, 0xc9, 0xd0, 0x1d, 0x9b,
	0x62, 0xba, 0xc8, 0x95, 0x33, 0xea, 0x12, 0x40, 0xa7, 0x00, 0x7d, 0x83, 0x0e, 0x86, 0x3a, 0xb1,
	0xdf, 0x61, 0x71, 0x27, 0xa4, 0x19, 0xd2, 0xb3, 0xdf, 0x61, 0xd4, 0x82, 0x87, 0xf8, 0xad, 0x67,
	0x4f, 0x0d, 0x6a, 0xbb, 0x8e, 0x1e, 0x4c, 0x28, 0xee, 0x16, 0xb9, 0xf2, 0x83, 0xe7, 0xb9, 0x4a,
	0x38, 0x7e, 0x65, 0x3e, 0x7e, 0x45, 0x9b, 0x8f, 0x7f, 0xbe, 0xfb, 0xfe, 0xcf, 0x42, 0xec, 0xfa,
	0xaf, 0x02, 0xa7, 0xee, 0x2f, 0x5f, 0x0e, 0x68, 0xf4, 0x15, 0xa4, 0x09, 0x35, 0xa8, 0x4f, 0x44,
	0xbe, 0xc8, 0x95, 0xf7, 0x9f, 0x1f, 0x54, 0x96, 0x32, 0x57, 0xa4, 0x66, 0xa3, 0xc7, 0x48, 0x35,
	0x6a, 0x2a, 0xfd, 0xc6, 0x41, 0x46, 0x6a, 0x36, 0xea, 0xee, 0xc4, 0x1b, 0xe3, 0xe0, 0x23, 0xdb,
	0x44, 0x24, 0xd8, 0x31, 0xf1, 0x74, 0x2e, 0x62, 0x58, 0xa1, 0x63, 0xd8, 0xf5, 0xfc, 0xbe, 0x3e,
	0xc2, 0x33, 0x22, 0x26, 0x98, 0x28, 0x3b, 0x9e, 0xdf, 0x6f, 0xe2, 0x19, 0x41, 0x5f, 0x80, 0x30,
	0x70, 0x1d, 0x82, 0x1d, 0xe2, 0x13, 0xdd, 0xf3, 0xfb, 0x23, 0x3c, 0x63, 0xaa, 0xf2, 0xea, 0xc3,
	0x05, 0xde, 0x65, 0x70, 0x20, 0x1d, 0xb1, 0x2d, 0xc7, 0xa0, 0xfe, 0x14, 0x8b, 0x29, 0xd6, 0xb3,
	0x04, 0x4a, 0x06, 0xec, 0xf7, 0x6c, 0xcb, 0xb1, 0x1d, 0xab, 0xe3, 0x05, 0x97, 0x23, 0x28, 0x0b,
	0x29, 0xfa, 0x06, 0x1b, 0x23, 0x76, 0x41, 0x5e, 0x0d, 0x8b, 0x00, 0x75, 0x5c, 0x67, 0x30, 0xdf,
	0x73, 0x58, 0xa0, 0xa7, 0x90, 0x31, 0x4c, 0xc3, 0xa3, 0xee, 0x54, 0xf7, 0x5c, 0xdb, 0xa1, 0xd1,
	0xbe, 0xf7, 0x22, 0xb0, 0x1b, 0x60, 0xa5, 0x1f, 0x13, 0x8b, 0x33, 0x3e, 0xd6, 0x46, 0x4f, 0x80,
	0x27, 0x03, 0xd7, 0xc3, 0xa6, 0x6e, 0x9b, 0xd1, 0xb7, 0x77, 0x43, 0x40, 0x31, 0xd1, 0x97, 0x91,
	0xc7, 0x92, 0x6c, 0x0b, 0x47, 0xab, 0x5b, 0x88, 0x8e, 0xd3, 0x66, 0x1e, 0xde, 0x30, 0x5f, 0xea,
	0x8e, 0xf9, 0x8e, 0x60, 0x27, 0xd2, 0x98, 0xd9, 0x8a, 0x57, 0xd3, 0xa1, 0xc4, 0x81, 0xa7, 0x88,
	0x6d, 0xe9, 0x43, 0x83, 0x0c, 0x31, 0x11, 0x77, 0x98, 0xfc, 0x81, 0x6e, 0x97, 0x0c, 0x40, 0x2f,
	0x60, 0xc7, 0x0d, 0x05, 0x5b, 0x78, 0x69, 0xf3, 0xfc, 0x48, 0x52, 0x75, 0xde, 0x8a, 0x14, 0xc8,
	0x0c, 0xa6, 0x78, 0xc5, 0x87, 0xfc, 0x47, 0xf8, 0x70, 0x6f, 0xfe, 0x2a, 0x73, 0xe1, 0xb3, 0x85,
	0x0b, 0x81, 0xcd, 0x7f, 0xbc, 0xe5, 0xfc, 0x35, 0x27, 0x5e, 0xc7, 0xe1, 0x91, 0x8a, 0x5f, 0x07,
	0xa9, 0xf9, 0x97, 0x5d, 0x1c, 0x40, 0xda, 0x1c, 0x59, 0x81, 0xe0, 0x71, 0x86, 0xa5, 0xcc, 0x91,
	0xa5, 0x98, 0xe8, 0x19, 0x64, 0xa7, 0x78, 0xe2, 0x7e, 0x8f, 0x4d, 0xfd, 0x4e, 0x5a, 0x43, 0x63,
	0x3e, 0x8e, 0xb8, 0xee, 0xbd, 0xa1, 0x4d, 0xae, 0x87, 0x76, 0x4b, 0x2a, 0x53, 0x9f, 0x90, 0xca,
	0x17, 0x0b, 0x3d, 0xd2, 0x4c, 0x8f, 0x93, 0x55, 0x3d, 0x96, 0x53, 0xaf, 0x49, 0xf2, 0x13, 0x07,
	0xd9, 0x25, 0xf9, 0x3f, 0x32, 0xba, 0x2d, 0x88, 0x89, 0xff, 0x10, 0xc4, 0xe4, 0x5a, 0x10, 0xcf,
	0x7e, 0xe6, 0x80, 0x5f, 0xfc, 0xf3, 0x40, 0x39, 0x38, 0x94, 0x9a, 0x0d, 0xbd, 0xa7, 0xd5, 0xb4,
	0xab, 0x9e, 0x7e, 0xd5, 0xee, 0x75, 0xe5, 0xba, 0x72, 0xa1, 0xc8, 0x92, 0x10, 0x43, 0x87, 0x80,
	0x56, 0xb8, 0xae, 0xdc, 0x96, 0x94, 0x76, 0x43, 0xe0, 0x90, 0x08, 0xd9, 0x15, 0xbc, 0xde, 0x69,
	0x75, 0x5f, 0xca, 0x9a, 0x2c, 0x09, 0x71, 0x74, 0x00, 0x8f, 0x56, 0x98, 0x8b, 0x9a, 0xf2, 0x52,
	0x96, 0x84, 0x04, 0x3a, 0x82, 0xc7, 0x2b, 0xb0, 0xa6, 0xb4, 0x64, 0xa9, 0x73, 0xa5, 0x09, 0xc9,
	0xb3, 0x1f, 0x38, 0xc8, 0xdc, 0xb1, 0x10, 0xca, 0x43, 0xae, 0xa7, 0x34, 0xda, 0x4a, 0xfb, 0x9e,
	0x3b, 0xe5, 0xe0, 0x70, 0x8d, 0x5f, 0xde, 0xeb, 0x18, 0x0e, 0xd6, 0xb8, 0xa0, 0x64, 0x17, 0xdb,
	0xa4, 0xe6, 0x97, 0x3b, 0xfb, 0x95, 0x83, 0x07, 0x2b, 0x31, 0x0e, 0xa6, 0x9b, 0xb7, 0x6a, 0xdf,
	0x74, 0x65, 0xbd, 0x57, 0xbf, 0x6c, 0x77, 0x54, 0x55, 0x88, 0xa1, 0xa7, 0x50, 0xd8, 0xc6, 0xe8,
	0xaf, 0x14, 0xed, 0x52, 0xd7, 0x5e, 0xc9, 0xb5, 0xa6, 0xc0, 0xa1, 0x32, 0x7c, 0x7e, 0x7f, 0x53,
	0xbd, 0xd3, 0x6a, 0x29, 0x5a, 0x4b, 0x6e, 0x6b, 0x42, 0x1c, 0x15, 0xe1, 0x64, 0x6b, 0x67, 0x4d,
	0xaa, 0x75, 0xb5, 0x8e, 0x2a, 0x24, 0xce, 0x7e, 0xe1, 0x40, 0x58, 0x77, 0x14, 0xfa, 0x0c, 0x4e,
	0x55, 0xf9, 0x42, 0x95, 0x7b, 0x97, 0xf7, 0x8a, 0x74, 0x0a, 0xc7, 0x9b, 0x2d, 0x4b, 0x9d, 0x0a,
	0xf0, 0x64, 0x93, 0x5e, 0x5d, 0x63, 0x1e, 0x72, 0x9b, 0x0d, 0x8b, 0xb5, 0x25, 0xce, 0xcf, 0xdf,
	0xdf, 0xe4, 0xb9, 0x0f, 0x37, 0x79, 0xee, 0xef, 0x9b, 0x3c, 0x77, 0x7d, 0x9b, 0x8f, 0x7d, 0xb8,
	0xcd, 0xc7, 0xfe, 0xb8, 0xcd, 0xc7, 0xbe, 0x2d, 0x5b, 0x36, 0x1d, 0xfa, 0xfd, 0xca, 0xc0, 0x9d,
	0x54, 0xc3, 0x58, 0x8c, 0x8d, 0x3e, 0x89, 0x1e, 0xab, 0x6f, 0xc3, 0x9f, 0x0d, 0x33, 0x0f, 0x93,
	0x7e, 0x9a, 0x85, 0xee, 0xeb, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x17, 0xf4, 0x48, 0x32, 0x51,
	0x08, 0x00, 0x00,
}

func (m *DKGRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpirationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpirationTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTss(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x42
	if m.BatchSize != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x38
	}
	if m.Threshold != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Participants[iNdEx])
			copy(dAtA[i:], m.Participants[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.Participants[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Intent != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Intent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DKGCompletion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DKGCompletion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DKGCompletion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ConsensusPubkey) > 0 {
		i -= len(m.ConsensusPubkey)
		copy(dAtA[i:], m.ConsensusPubkey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.ConsensusPubkey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubKeys) > 0 {
		for iNdEx := len(m.PubKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PubKeys[iNdEx])
			copy(dAtA[i:], m.PubKeys[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.PubKeys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SigningOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdaptorPoint) > 0 {
		i -= len(m.AdaptorPoint)
		copy(dAtA[i:], m.AdaptorPoint)
		i = encodeVarintTss(dAtA, i, uint64(len(m.AdaptorPoint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tweak) > 0 {
		i -= len(m.Tweak)
		copy(dAtA[i:], m.Tweak)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Tweak)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreationTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintTss(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x4a
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTss(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.SigHashes) > 0 {
		for iNdEx := len(m.SigHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SigHashes[iNdEx])
			copy(dAtA[i:], m.SigHashes[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.SigHashes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x32
	}
	if m.Intent != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Intent))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ScopedId) > 0 {
		i -= len(m.ScopedId)
		copy(dAtA[i:], m.ScopedId)
		i = encodeVarintTss(dAtA, i, uint64(len(m.ScopedId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RefreshingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpirationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpirationTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTss(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x2a
	if m.Threshold != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RemovedParticipants) > 0 {
		for iNdEx := len(m.RemovedParticipants) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RemovedParticipants[iNdEx])
			copy(dAtA[i:], m.RemovedParticipants[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.RemovedParticipants[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DkgId != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.DkgId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RefreshingCompletion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshingCompletion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshingCompletion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ConsensusPubkey) > 0 {
		i -= len(m.ConsensusPubkey)
		copy(dAtA[i:], m.ConsensusPubkey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.ConsensusPubkey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTss(dAtA []byte, offset int, v uint64) int {
	offset -= sovTss(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DKGRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTss(uint64(m.Id))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Intent != 0 {
		n += 1 + sovTss(uint64(m.Intent))
	}
	if len(m.Participants) > 0 {
		for _, s := range m.Participants {
			l = len(s)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovTss(uint64(m.Threshold))
	}
	if m.BatchSize != 0 {
		n += 1 + sovTss(uint64(m.BatchSize))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpirationTime)
	n += 1 + l + sovTss(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	return n
}

func (m *DKGCompletion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTss(uint64(m.Id))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if len(m.PubKeys) > 0 {
		for _, s := range m.PubKeys {
			l = len(s)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	l = len(m.ConsensusPubkey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *SigningOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tweak)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.AdaptorPoint)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *SigningRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTss(uint64(m.Id))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.ScopedId)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTss(uint64(m.Type))
	}
	if m.Intent != 0 {
		n += 1 + sovTss(uint64(m.Intent))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if len(m.SigHashes) > 0 {
		for _, s := range m.SigHashes {
			l = len(s)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovTss(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreationTime)
	n += 1 + l + sovTss(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	return n
}

func (m *RefreshingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTss(uint64(m.Id))
	}
	if m.DkgId != 0 {
		n += 1 + sovTss(uint64(m.DkgId))
	}
	if len(m.RemovedParticipants) > 0 {
		for _, s := range m.RemovedParticipants {
			l = len(s)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovTss(uint64(m.Threshold))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpirationTime)
	n += 1 + l + sovTss(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	return n
}

func (m *RefreshingCompletion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTss(uint64(m.Id))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.ConsensusPubkey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func sovTss(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTss(x uint64) (n int) {
	return sovTss(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DKGRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			m.Intent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Intent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpirationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DKGStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DKGCompletion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DKGCompletion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DKGCompletion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKeys = append(m.PubKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusPubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusPubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tweak", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tweak = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptorPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdaptorPoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SigningType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			m.Intent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Intent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigHashes = append(m.SigHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &SigningOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SigningStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DkgId", wireType)
			}
			m.DkgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DkgId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovedParticipants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemovedParticipants = append(m.RemovedParticipants, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpirationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RefreshingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshingCompletion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshingCompletion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshingCompletion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusPubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusPubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTss(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTss
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTss
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTss
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTss
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTss        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTss          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTss = fmt.Errorf("proto: unexpected end of group")
)
