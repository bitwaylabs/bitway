package types

import (
	"encoding/hex"

	"github.com/decred/dcrd/dcrec/secp256k1/v4"

	"github.com/btcsuite/btcd/btcec/v2"
	"github.com/btcsuite/btcd/btcec/v2/schnorr"
	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/btcutil/psbt"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/txscript"

	"github.com/bitwaylabs/bitway/bitcoin"
)

const (
	// NUMS Point computed by SHA256(G)
	NUMS_POINT = "50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"
)

// Branch 1 & 2: multisig script for borrower and dcm
// 1: liquidation script with borrower auth key
// 2: repayment script with borrower key
func CreateMultisigScript(pubKeys [][]byte) ([]byte, error) {
	builder := txscript.NewScriptBuilder()

	for i, pubKey := range pubKeys {
		builder.AddData(pubKey)

		if i == 0 {
			builder.AddOp(txscript.OP_CHECKSIG)
		} else {
			builder.AddOp(txscript.OP_CHECKSIGADD)
		}
	}

	builder.AddInt64(int64(len(pubKeys)))
	builder.AddOp(txscript.OP_NUMEQUAL)

	return builder.Script()
}

// Branch 3: PubKey with time lock script for borrower refund
func CreatePubKeyTimeLockScript(pubKey []byte, lockTime int64) ([]byte, error) {
	builder := txscript.NewScriptBuilder()

	builder.AddInt64(lockTime)
	builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
	builder.AddOp(txscript.OP_DROP)
	builder.AddData(pubKey)
	builder.AddOp(txscript.OP_CHECKSIG)

	return builder.Script()
}

// CreateTaprootAddress creates the taproot address with the given internal key and scripts
func CreateTaprootAddress(internalKey *secp256k1.PublicKey, scripts [][]byte, params *chaincfg.Params) (string, error) {
	tapscriptTree := GetTapscriptTree(scripts)
	scriptRoot := tapscriptTree.RootNode.TapHash()

	taprootOutKey := txscript.ComputeTaprootOutputKey(internalKey, scriptRoot[:])

	// Generate Taproot address
	address, err := btcutil.NewAddressTaproot(schnorr.SerializePubKey(taprootOutKey), params)
	if err != nil {
		return "", err
	}

	return address.EncodeAddress(), nil
}

// CreateVaultAddress creates the vault address with the given params
// Assume that the given pub keys are valid
func CreateVaultAddress(borrowerPubKey string, borrowerAuthPubKey string, dcmPubKey string, finalTimeout int64) (string, error) {
	borrowerPubKeyBytes, _ := hex.DecodeString(borrowerPubKey)
	borrowerAuthPubKeyBytes, _ := hex.DecodeString(borrowerAuthPubKey)
	dcmPubKeyBytes, _ := hex.DecodeString(dcmPubKey)

	internalKey := GetInternalKey(borrowerPubKeyBytes, dcmPubKeyBytes)

	liquidationScript, repaymentScript, timeoutRefundScript, err := GetVaultScripts(borrowerPubKeyBytes, borrowerAuthPubKeyBytes, dcmPubKeyBytes, finalTimeout)
	if err != nil {
		return "", err
	}

	scripts := [][]byte{liquidationScript, repaymentScript, timeoutRefundScript}

	vaultAddress, err := CreateTaprootAddress(internalKey, scripts, bitcoin.Network)
	if err != nil {
		return "", err
	}

	return vaultAddress, nil
}

// GetVaultScripts gets the scripts associated the underlying vault address from the given params
func GetVaultScripts(borrowerPubKey []byte, borrowerAuthPubKey []byte, dcmPubKey []byte, finalTimeout int64) ([]byte, []byte, []byte, error) {
	// liquidation script
	liquidationScript, err := CreateMultisigScript([][]byte{borrowerAuthPubKey, dcmPubKey})
	if err != nil {
		return nil, nil, nil, err
	}

	// repayment script
	repaymentScript, err := CreateMultisigScript([][]byte{borrowerPubKey, dcmPubKey})
	if err != nil {
		return nil, nil, nil, err
	}

	// refund script
	timeoutRefundScript, err := CreatePubKeyTimeLockScript(borrowerPubKey, finalTimeout)
	if err != nil {
		return nil, nil, nil, err
	}

	return liquidationScript, repaymentScript, timeoutRefundScript, nil
}

// GetInternalKey gets the pub key used for taproot address generation
// Generated by borrower pk + dcm pk, fallback to a NUMS Point
// Assume that the given pub keys are valid
func GetInternalKey(borrowerPubKey []byte, dcmPubKey []byte) *btcec.PublicKey {
	borrowerPk, _ := schnorr.ParsePubKey(borrowerPubKey)
	dcmPk, _ := schnorr.ParsePubKey(dcmPubKey)

	// P = borrower pk + dcm pk
	var BPK, DPK, P btcec.JacobianPoint
	borrowerPk.AsJacobian(&BPK)
	dcmPk.AsJacobian(&DPK)
	btcec.AddNonConst(&BPK, &DPK, &P)

	// check if P is the point at infinity
	if (P.X.IsZero() && P.Y.IsZero()) || P.Z.IsZero() {
		return GetNUMSPoint()
	}

	P.ToAffine()

	return btcec.NewPublicKey(&P.X, &P.Y)
}

// GetTapscriptTree gets the tapscript tree built from the given tapscripts
// NOTE: Duplicate scripts are filtered out
func GetTapscriptTree(scripts [][]byte) *txscript.IndexedTapScriptTree {
	leaves := []txscript.TapLeaf{}
	leafMap := make(map[chainhash.Hash]bool)

	for _, script := range scripts {
		leaf := txscript.NewBaseTapLeaf(script)
		hash := leaf.TapHash()

		if !leafMap[hash] {
			leaves = append(leaves, leaf)
			leafMap[hash] = true
		}
	}

	tree := txscript.AssembleTaprootScriptTree(leaves...)

	return tree
}

// GetTapscriptMerkleProof gets the merkle proof of the specified script from the given tapscript tree
func GetTapscriptMerkleProof(tree *txscript.IndexedTapScriptTree, script []byte) txscript.TapscriptProof {
	leaf := txscript.NewBaseTapLeaf(script)

	index, ok := tree.LeafProofIndex[leaf.TapHash()]
	if !ok {
		return txscript.TapscriptProof{}
	}

	return tree.LeafMerkleProofs[index]
}

// GetControlBlock gets the control block for the given tapscript
// Assume that the given script exists in the tapscript tree
func GetControlBlock(tree *txscript.IndexedTapScriptTree, script []byte, internalKey *secp256k1.PublicKey) ([]byte, error) {
	proof := GetTapscriptMerkleProof(tree, script)
	controlBlock := proof.ToControlBlock(internalKey)

	controlBlockBz, err := controlBlock.ToBytes()
	if err != nil {
		return nil, err
	}

	return controlBlockBz, nil
}

// CalcTapscriptSigHash computes the sig hash of the given script
// Assume that the psbt is valid
func CalcTapscriptSigHash(p *psbt.Packet, idx int, sigHashType txscript.SigHashType, script []byte) ([]byte, error) {
	prevOutFetcher := txscript.NewMultiPrevOutFetcher(nil)
	for i, txIn := range p.UnsignedTx.TxIn {
		prevOutFetcher.AddPrevOut(txIn.PreviousOutPoint, p.Inputs[i].WitnessUtxo)
	}

	sigHash, err := txscript.CalcTapscriptSignaturehash(txscript.NewTxSigHashes(p.UnsignedTx, prevOutFetcher), sigHashType, p.UnsignedTx, idx, prevOutFetcher, txscript.NewBaseTapLeaf(script))
	if err != nil {
		return nil, err
	}

	return sigHash, nil
}

// GetPkScriptFromAddress gets the pk script of the given address
func GetPkScriptFromAddress(address string) ([]byte, error) {
	addr, err := btcutil.DecodeAddress(address, bitcoin.Network)
	if err != nil {
		return nil, err
	}

	return txscript.PayToAddrScript(addr)
}

// GetPkScriptFromPubKey gets the pk script from the given taproot pubkey
func GetPkScriptFromPubKey(pubKeyHex string) ([]byte, error) {
	pubKey, err := hex.DecodeString(pubKeyHex)
	if err != nil {
		return nil, err
	}

	parsedPubKey, err := schnorr.ParsePubKey(pubKey)
	if err != nil {
		return nil, err
	}

	taprootOutKey := txscript.ComputeTaprootKeyNoScript(parsedPubKey)

	return txscript.PayToTaprootScript(taprootOutKey)
}

// GetNUMSPoint gets the NUMS point
func GetNUMSPoint() *btcec.PublicKey {
	pointBytes, err := hex.DecodeString(NUMS_POINT)
	if err != nil {
		panic(err)
	}

	point, err := schnorr.ParsePubKey(pointBytes)
	if err != nil {
		panic(err)
	}

	return point
}
