// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bitway/lending/lending.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	types1 "github.com/bitwaylabs/bitway/x/btcbridge/types"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status options for a lending pool
type PoolStatus int32

const (
	PoolStatus_INACTIVE PoolStatus = 0
	PoolStatus_ACTIVE   PoolStatus = 1
	PoolStatus_PAUSED   PoolStatus = 2
)

var PoolStatus_name = map[int32]string{
	0: "INACTIVE",
	1: "ACTIVE",
	2: "PAUSED",
}

var PoolStatus_value = map[string]int32{
	"INACTIVE": 0,
	"ACTIVE":   1,
	"PAUSED":   2,
}

func (x PoolStatus) String() string {
	return proto.EnumName(PoolStatus_name, int32(x))
}

func (PoolStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{0}
}

// Loan Status
type LoanStatus int32

const (
	// Unspecified
	LoanStatus_Unspecified LoanStatus = 0
	// Loan Requested
	LoanStatus_Requested LoanStatus = 1
	// Loan Cancelled
	LoanStatus_Cancelled LoanStatus = 2
	// Loan Authorized
	LoanStatus_Authorized LoanStatus = 3
	// Loan Rejected
	LoanStatus_Rejected LoanStatus = 4
	// Loan Open
	LoanStatus_Open LoanStatus = 5
	// Loan Repaid
	LoanStatus_Repaid LoanStatus = 6
	// Loan Defaulted
	LoanStatus_Defaulted LoanStatus = 7
	// Loan Liquidated
	LoanStatus_Liquidated LoanStatus = 8
	// Loan Closed
	LoanStatus_Closed LoanStatus = 9
)

var LoanStatus_name = map[int32]string{
	0: "Unspecified",
	1: "Requested",
	2: "Cancelled",
	3: "Authorized",
	4: "Rejected",
	5: "Open",
	6: "Repaid",
	7: "Defaulted",
	8: "Liquidated",
	9: "Closed",
}

var LoanStatus_value = map[string]int32{
	"Unspecified": 0,
	"Requested":   1,
	"Cancelled":   2,
	"Authorized":  3,
	"Rejected":    4,
	"Open":        5,
	"Repaid":      6,
	"Defaulted":   7,
	"Liquidated":  8,
	"Closed":      9,
}

func (x LoanStatus) String() string {
	return proto.EnumName(LoanStatus_name, int32(x))
}

func (LoanStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{1}
}

// Authorization Status
type AuthorizationStatus int32

const (
	// Pending
	AuthorizationStatus_AUTHORIZATION_STATUS_PENDING AuthorizationStatus = 0
	// Authorized
	AuthorizationStatus_AUTHORIZATION_STATUS_AUTHORIZED AuthorizationStatus = 1
	// Rejected
	AuthorizationStatus_AUTHORIZATION_STATUS_REJECTED AuthorizationStatus = 2
)

var AuthorizationStatus_name = map[int32]string{
	0: "AUTHORIZATION_STATUS_PENDING",
	1: "AUTHORIZATION_STATUS_AUTHORIZED",
	2: "AUTHORIZATION_STATUS_REJECTED",
}

var AuthorizationStatus_value = map[string]int32{
	"AUTHORIZATION_STATUS_PENDING":    0,
	"AUTHORIZATION_STATUS_AUTHORIZED": 1,
	"AUTHORIZATION_STATUS_REJECTED":   2,
}

func (x AuthorizationStatus) String() string {
	return proto.EnumName(AuthorizationStatus_name, int32(x))
}

func (AuthorizationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{2}
}

type CetType int32

const (
	CetType_LIQUIDATION         CetType = 0
	CetType_DEFAULT_LIQUIDATION CetType = 1
	CetType_REPAYMENT           CetType = 2
)

var CetType_name = map[int32]string{
	0: "LIQUIDATION",
	1: "DEFAULT_LIQUIDATION",
	2: "REPAYMENT",
}

var CetType_value = map[string]int32{
	"LIQUIDATION":         0,
	"DEFAULT_LIQUIDATION": 1,
	"REPAYMENT":           2,
}

func (x CetType) String() string {
	return proto.EnumName(CetType_name, int32(x))
}

func (CetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{3}
}

type DepositStatus int32

const (
	DepositStatus_DEPOSIT_STATUS_PENDING   DepositStatus = 0
	DepositStatus_DEPOSIT_STATUS_VERIFIED  DepositStatus = 1
	DepositStatus_DEPOSIT_STATUS_REDEEMING DepositStatus = 2
	DepositStatus_DEPOSIT_STATUS_REDEEMED  DepositStatus = 3
)

var DepositStatus_name = map[int32]string{
	0: "DEPOSIT_STATUS_PENDING",
	1: "DEPOSIT_STATUS_VERIFIED",
	2: "DEPOSIT_STATUS_REDEEMING",
	3: "DEPOSIT_STATUS_REDEEMED",
}

var DepositStatus_value = map[string]int32{
	"DEPOSIT_STATUS_PENDING":   0,
	"DEPOSIT_STATUS_VERIFIED":  1,
	"DEPOSIT_STATUS_REDEEMING": 2,
	"DEPOSIT_STATUS_REDEEMED":  3,
}

func (x DepositStatus) String() string {
	return proto.EnumName(DepositStatus_name, int32(x))
}

func (DepositStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{4}
}

// Signing intent
type SigningIntent int32

const (
	SigningIntent_SIGNING_INTENT_REPAYMENT           SigningIntent = 0
	SigningIntent_SIGNING_INTENT_LIQUIDATION         SigningIntent = 1
	SigningIntent_SIGNING_INTENT_DEFAULT_LIQUIDATION SigningIntent = 2
	SigningIntent_SIGNING_INTENT_REDEMPTION          SigningIntent = 3
)

var SigningIntent_name = map[int32]string{
	0: "SIGNING_INTENT_REPAYMENT",
	1: "SIGNING_INTENT_LIQUIDATION",
	2: "SIGNING_INTENT_DEFAULT_LIQUIDATION",
	3: "SIGNING_INTENT_REDEMPTION",
}

var SigningIntent_value = map[string]int32{
	"SIGNING_INTENT_REPAYMENT":           0,
	"SIGNING_INTENT_LIQUIDATION":         1,
	"SIGNING_INTENT_DEFAULT_LIQUIDATION": 2,
	"SIGNING_INTENT_REDEMPTION":          3,
}

func (x SigningIntent) String() string {
	return proto.EnumName(SigningIntent_name, int32(x))
}

func (SigningIntent) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{5}
}

// Asset metadata
type AssetMetadata struct {
	Denom            string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Symbol           string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Decimals         int32  `protobuf:"varint,3,opt,name=decimals,proto3" json:"decimals,omitempty"`
	PriceSymbol      string `protobuf:"bytes,4,opt,name=price_symbol,json=priceSymbol,proto3" json:"price_symbol,omitempty"`
	IsBasePriceAsset bool   `protobuf:"varint,5,opt,name=is_base_price_asset,json=isBasePriceAsset,proto3" json:"is_base_price_asset,omitempty"`
}

func (m *AssetMetadata) Reset()         { *m = AssetMetadata{} }
func (m *AssetMetadata) String() string { return proto.CompactTextString(m) }
func (*AssetMetadata) ProtoMessage()    {}
func (*AssetMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{0}
}
func (m *AssetMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetMetadata.Merge(m, src)
}
func (m *AssetMetadata) XXX_Size() int {
	return m.Size()
}
func (m *AssetMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_AssetMetadata proto.InternalMessageInfo

func (m *AssetMetadata) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *AssetMetadata) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *AssetMetadata) GetDecimals() int32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *AssetMetadata) GetPriceSymbol() string {
	if m != nil {
		return m.PriceSymbol
	}
	return ""
}

func (m *AssetMetadata) GetIsBasePriceAsset() bool {
	if m != nil {
		return m.IsBasePriceAsset
	}
	return false
}

// Pool tranche config
type PoolTrancheConfig struct {
	// maturity duration in seconds
	Maturity int64 `protobuf:"varint,1,opt,name=maturity,proto3" json:"maturity,omitempty"`
	// borrow apr permille
	BorrowAPR uint32 `protobuf:"varint,2,opt,name=borrow_apr,json=borrowApr,proto3" json:"borrow_apr,omitempty"`
}

func (m *PoolTrancheConfig) Reset()         { *m = PoolTrancheConfig{} }
func (m *PoolTrancheConfig) String() string { return proto.CompactTextString(m) }
func (*PoolTrancheConfig) ProtoMessage()    {}
func (*PoolTrancheConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{1}
}
func (m *PoolTrancheConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolTrancheConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolTrancheConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolTrancheConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolTrancheConfig.Merge(m, src)
}
func (m *PoolTrancheConfig) XXX_Size() int {
	return m.Size()
}
func (m *PoolTrancheConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolTrancheConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PoolTrancheConfig proto.InternalMessageInfo

func (m *PoolTrancheConfig) GetMaturity() int64 {
	if m != nil {
		return m.Maturity
	}
	return 0
}

func (m *PoolTrancheConfig) GetBorrowAPR() uint32 {
	if m != nil {
		return m.BorrowAPR
	}
	return 0
}

// Pool config
type PoolConfig struct {
	// collateral asset metadata
	CollateralAsset AssetMetadata `protobuf:"bytes,1,opt,name=collateral_asset,json=collateralAsset,proto3" json:"collateral_asset"`
	// lending asset metadata
	LendingAsset AssetMetadata `protobuf:"bytes,2,opt,name=lending_asset,json=lendingAsset,proto3" json:"lending_asset"`
	// supply cap
	SupplyCap cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=supply_cap,json=supplyCap,proto3,customtype=cosmossdk.io/math.Int" json:"supply_cap"`
	// borrow cap
	BorrowCap cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=borrow_cap,json=borrowCap,proto3,customtype=cosmossdk.io/math.Int" json:"borrow_cap"`
	// minimum amount to be borrowed
	MinBorrowAmount cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=min_borrow_amount,json=minBorrowAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_borrow_amount"`
	// maximum amount to be borrowed
	MaxBorrowAmount cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=max_borrow_amount,json=maxBorrowAmount,proto3,customtype=cosmossdk.io/math.Int" json:"max_borrow_amount"`
	// tranches
	Tranches []PoolTrancheConfig `protobuf:"bytes,7,rep,name=tranches,proto3" json:"tranches"`
	// request fee
	RequestFee types.Coin `protobuf:"bytes,8,opt,name=request_fee,json=requestFee,proto3" json:"request_fee"`
	// origination fee factor permille
	OriginationFeeFactor uint32 `protobuf:"varint,9,opt,name=origination_fee_factor,json=originationFeeFactor,proto3" json:"origination_fee_factor,omitempty"`
	// reserve factor permille
	ReserveFactor uint32 `protobuf:"varint,10,opt,name=reserve_factor,json=reserveFactor,proto3" json:"reserve_factor,omitempty"`
	// maximum ltv percent
	MaxLtv uint32 `protobuf:"varint,11,opt,name=max_ltv,json=maxLtv,proto3" json:"max_ltv,omitempty"`
	// liquidation ltv percent
	LiquidationThreshold uint32 `protobuf:"varint,12,opt,name=liquidation_threshold,json=liquidationThreshold,proto3" json:"liquidation_threshold,omitempty"`
	// indicates if the pool is paused
	Paused bool `protobuf:"varint,13,opt,name=paused,proto3" json:"paused,omitempty"`
}

func (m *PoolConfig) Reset()         { *m = PoolConfig{} }
func (m *PoolConfig) String() string { return proto.CompactTextString(m) }
func (*PoolConfig) ProtoMessage()    {}
func (*PoolConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{2}
}
func (m *PoolConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolConfig.Merge(m, src)
}
func (m *PoolConfig) XXX_Size() int {
	return m.Size()
}
func (m *PoolConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PoolConfig proto.InternalMessageInfo

func (m *PoolConfig) GetCollateralAsset() AssetMetadata {
	if m != nil {
		return m.CollateralAsset
	}
	return AssetMetadata{}
}

func (m *PoolConfig) GetLendingAsset() AssetMetadata {
	if m != nil {
		return m.LendingAsset
	}
	return AssetMetadata{}
}

func (m *PoolConfig) GetTranches() []PoolTrancheConfig {
	if m != nil {
		return m.Tranches
	}
	return nil
}

func (m *PoolConfig) GetRequestFee() types.Coin {
	if m != nil {
		return m.RequestFee
	}
	return types.Coin{}
}

func (m *PoolConfig) GetOriginationFeeFactor() uint32 {
	if m != nil {
		return m.OriginationFeeFactor
	}
	return 0
}

func (m *PoolConfig) GetReserveFactor() uint32 {
	if m != nil {
		return m.ReserveFactor
	}
	return 0
}

func (m *PoolConfig) GetMaxLtv() uint32 {
	if m != nil {
		return m.MaxLtv
	}
	return 0
}

func (m *PoolConfig) GetLiquidationThreshold() uint32 {
	if m != nil {
		return m.LiquidationThreshold
	}
	return 0
}

func (m *PoolConfig) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

// Pool tranche
type PoolTranche struct {
	// maturity duration
	Maturity int64 `protobuf:"varint,1,opt,name=maturity,proto3" json:"maturity,omitempty"`
	// borrow index
	BorrowIndex cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=borrow_index,json=borrowIndex,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"borrow_index"`
	// total borrowed
	TotalBorrowed cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_borrowed,json=totalBorrowed,proto3,customtype=cosmossdk.io/math.Int" json:"total_borrowed"`
	// total reserve
	TotalReserve cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_reserve,json=totalReserve,proto3,customtype=cosmossdk.io/math.Int" json:"total_reserve"`
}

func (m *PoolTranche) Reset()         { *m = PoolTranche{} }
func (m *PoolTranche) String() string { return proto.CompactTextString(m) }
func (*PoolTranche) ProtoMessage()    {}
func (*PoolTranche) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{3}
}
func (m *PoolTranche) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolTranche) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolTranche.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolTranche) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolTranche.Merge(m, src)
}
func (m *PoolTranche) XXX_Size() int {
	return m.Size()
}
func (m *PoolTranche) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolTranche.DiscardUnknown(m)
}

var xxx_messageInfo_PoolTranche proto.InternalMessageInfo

func (m *PoolTranche) GetMaturity() int64 {
	if m != nil {
		return m.Maturity
	}
	return 0
}

type LendingPool struct {
	Id              string                `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Supply          types.Coin            `protobuf:"bytes,2,opt,name=supply,proto3" json:"supply"`
	AvailableAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=available_amount,json=availableAmount,proto3,customtype=cosmossdk.io/math.Int" json:"available_amount"`
	BorrowedAmount  cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=borrowed_amount,json=borrowedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"borrowed_amount"`
	TotalBorrowed   cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=total_borrowed,json=totalBorrowed,proto3,customtype=cosmossdk.io/math.Int" json:"total_borrowed"`
	ReserveAmount   cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=reserve_amount,json=reserveAmount,proto3,customtype=cosmossdk.io/math.Int" json:"reserve_amount"`
	TotalReserve    cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=total_reserve,json=totalReserve,proto3,customtype=cosmossdk.io/math.Int" json:"total_reserve"`
	TotalYTokens    types.Coin            `protobuf:"bytes,8,opt,name=total_ytokens,json=totalYtokens,proto3" json:"total_ytokens"`
	Tranches        []PoolTranche         `protobuf:"bytes,9,rep,name=tranches,proto3" json:"tranches"`
	Config          PoolConfig            `protobuf:"bytes,10,opt,name=config,proto3" json:"config"`
	Status          PoolStatus            `protobuf:"varint,11,opt,name=status,proto3,enum=bitway.lending.PoolStatus" json:"status,omitempty"`
}

func (m *LendingPool) Reset()         { *m = LendingPool{} }
func (m *LendingPool) String() string { return proto.CompactTextString(m) }
func (*LendingPool) ProtoMessage()    {}
func (*LendingPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{4}
}
func (m *LendingPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LendingPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LendingPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LendingPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LendingPool.Merge(m, src)
}
func (m *LendingPool) XXX_Size() int {
	return m.Size()
}
func (m *LendingPool) XXX_DiscardUnknown() {
	xxx_messageInfo_LendingPool.DiscardUnknown(m)
}

var xxx_messageInfo_LendingPool proto.InternalMessageInfo

func (m *LendingPool) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LendingPool) GetSupply() types.Coin {
	if m != nil {
		return m.Supply
	}
	return types.Coin{}
}

func (m *LendingPool) GetTotalYTokens() types.Coin {
	if m != nil {
		return m.TotalYTokens
	}
	return types.Coin{}
}

func (m *LendingPool) GetTranches() []PoolTranche {
	if m != nil {
		return m.Tranches
	}
	return nil
}

func (m *LendingPool) GetConfig() PoolConfig {
	if m != nil {
		return m.Config
	}
	return PoolConfig{}
}

func (m *LendingPool) GetStatus() PoolStatus {
	if m != nil {
		return m.Status
	}
	return PoolStatus_INACTIVE
}

// Authorization with deposit txs for cets
type Authorization struct {
	Id         uint64              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DepositTxs []string            `protobuf:"bytes,2,rep,name=deposit_txs,json=depositTxs,proto3" json:"deposit_txs,omitempty"`
	Status     AuthorizationStatus `protobuf:"varint,3,opt,name=status,proto3,enum=bitway.lending.AuthorizationStatus" json:"status,omitempty"`
}

func (m *Authorization) Reset()         { *m = Authorization{} }
func (m *Authorization) String() string { return proto.CompactTextString(m) }
func (*Authorization) ProtoMessage()    {}
func (*Authorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{5}
}
func (m *Authorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authorization.Merge(m, src)
}
func (m *Authorization) XXX_Size() int {
	return m.Size()
}
func (m *Authorization) XXX_DiscardUnknown() {
	xxx_messageInfo_Authorization.DiscardUnknown(m)
}

var xxx_messageInfo_Authorization proto.InternalMessageInfo

func (m *Authorization) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Authorization) GetDepositTxs() []string {
	if m != nil {
		return m.DepositTxs
	}
	return nil
}

func (m *Authorization) GetStatus() AuthorizationStatus {
	if m != nil {
		return m.Status
	}
	return AuthorizationStatus_AUTHORIZATION_STATUS_PENDING
}

type Loan struct {
	VaultAddress       string                      `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	Borrower           string                      `protobuf:"bytes,2,opt,name=borrower,proto3" json:"borrower,omitempty"`
	BorrowerPubKey     string                      `protobuf:"bytes,3,opt,name=borrowerPubKey,proto3" json:"borrowerPubKey,omitempty"`
	BorrowerAuthPubKey string                      `protobuf:"bytes,4,opt,name=borrowerAuthPubKey,proto3" json:"borrowerAuthPubKey,omitempty"`
	DCM                string                      `protobuf:"bytes,5,opt,name=dcm,proto3" json:"dcm,omitempty"`
	MaturityTime       int64                       `protobuf:"varint,6,opt,name=maturity_time,json=maturityTime,proto3" json:"maturity_time,omitempty"`
	FinalTimeout       int64                       `protobuf:"varint,7,opt,name=final_timeout,json=finalTimeout,proto3" json:"final_timeout,omitempty"`
	PoolId             string                      `protobuf:"bytes,8,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	BorrowAmount       types.Coin                  `protobuf:"bytes,9,opt,name=borrow_amount,json=borrowAmount,proto3" json:"borrow_amount"`
	RequestFee         types.Coin                  `protobuf:"bytes,10,opt,name=request_fee,json=requestFee,proto3" json:"request_fee"`
	OriginationFee     cosmossdk_io_math.Int       `protobuf:"bytes,11,opt,name=origination_fee,json=originationFee,proto3,customtype=cosmossdk.io/math.Int" json:"origination_fee"`
	Interest           cosmossdk_io_math.Int       `protobuf:"bytes,12,opt,name=interest,proto3,customtype=cosmossdk.io/math.Int" json:"interest"`
	ProtocolFee        cosmossdk_io_math.Int       `protobuf:"bytes,13,opt,name=protocol_fee,json=protocolFee,proto3,customtype=cosmossdk.io/math.Int" json:"protocol_fee"`
	Maturity           int64                       `protobuf:"varint,14,opt,name=maturity,proto3" json:"maturity,omitempty"`
	BorrowAPR          uint32                      `protobuf:"varint,15,opt,name=borrow_apr,json=borrowApr,proto3" json:"borrow_apr,omitempty"`
	StartBorrowIndex   cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=start_borrow_index,json=startBorrowIndex,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"start_borrow_index"`
	LiquidationPrice   cosmossdk_io_math.LegacyDec `protobuf:"bytes,17,opt,name=liquidation_price,json=liquidationPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"liquidation_price"`
	DlcEventId         uint64                      `protobuf:"varint,18,opt,name=dlc_event_id,json=dlcEventId,proto3" json:"dlc_event_id,omitempty"`
	Authorizations     []Authorization             `protobuf:"bytes,19,rep,name=authorizations,proto3" json:"authorizations"`
	CollateralAmount   cosmossdk_io_math.Int       `protobuf:"bytes,20,opt,name=collateral_amount,json=collateralAmount,proto3,customtype=cosmossdk.io/math.Int" json:"collateral_amount"`
	LiquidationId      uint64                      `protobuf:"varint,21,opt,name=liquidation_id,json=liquidationId,proto3" json:"liquidation_id,omitempty"`
	Referrer           *Referrer                   `protobuf:"bytes,22,opt,name=referrer,proto3" json:"referrer,omitempty"`
	CreateAt           time.Time                   `protobuf:"bytes,23,opt,name=create_at,json=createAt,proto3,stdtime" json:"create_at"`
	DisburseAt         time.Time                   `protobuf:"bytes,24,opt,name=disburse_at,json=disburseAt,proto3,stdtime" json:"disburse_at"`
	Status             LoanStatus                  `protobuf:"varint,25,opt,name=status,proto3,enum=bitway.lending.LoanStatus" json:"status,omitempty"`
}

func (m *Loan) Reset()         { *m = Loan{} }
func (m *Loan) String() string { return proto.CompactTextString(m) }
func (*Loan) ProtoMessage()    {}
func (*Loan) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{6}
}
func (m *Loan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Loan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Loan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Loan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Loan.Merge(m, src)
}
func (m *Loan) XXX_Size() int {
	return m.Size()
}
func (m *Loan) XXX_DiscardUnknown() {
	xxx_messageInfo_Loan.DiscardUnknown(m)
}

var xxx_messageInfo_Loan proto.InternalMessageInfo

func (m *Loan) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *Loan) GetBorrower() string {
	if m != nil {
		return m.Borrower
	}
	return ""
}

func (m *Loan) GetBorrowerPubKey() string {
	if m != nil {
		return m.BorrowerPubKey
	}
	return ""
}

func (m *Loan) GetBorrowerAuthPubKey() string {
	if m != nil {
		return m.BorrowerAuthPubKey
	}
	return ""
}

func (m *Loan) GetDCM() string {
	if m != nil {
		return m.DCM
	}
	return ""
}

func (m *Loan) GetMaturityTime() int64 {
	if m != nil {
		return m.MaturityTime
	}
	return 0
}

func (m *Loan) GetFinalTimeout() int64 {
	if m != nil {
		return m.FinalTimeout
	}
	return 0
}

func (m *Loan) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *Loan) GetBorrowAmount() types.Coin {
	if m != nil {
		return m.BorrowAmount
	}
	return types.Coin{}
}

func (m *Loan) GetRequestFee() types.Coin {
	if m != nil {
		return m.RequestFee
	}
	return types.Coin{}
}

func (m *Loan) GetMaturity() int64 {
	if m != nil {
		return m.Maturity
	}
	return 0
}

func (m *Loan) GetBorrowAPR() uint32 {
	if m != nil {
		return m.BorrowAPR
	}
	return 0
}

func (m *Loan) GetDlcEventId() uint64 {
	if m != nil {
		return m.DlcEventId
	}
	return 0
}

func (m *Loan) GetAuthorizations() []Authorization {
	if m != nil {
		return m.Authorizations
	}
	return nil
}

func (m *Loan) GetLiquidationId() uint64 {
	if m != nil {
		return m.LiquidationId
	}
	return 0
}

func (m *Loan) GetReferrer() *Referrer {
	if m != nil {
		return m.Referrer
	}
	return nil
}

func (m *Loan) GetCreateAt() time.Time {
	if m != nil {
		return m.CreateAt
	}
	return time.Time{}
}

func (m *Loan) GetDisburseAt() time.Time {
	if m != nil {
		return m.DisburseAt
	}
	return time.Time{}
}

func (m *Loan) GetStatus() LoanStatus {
	if m != nil {
		return m.Status
	}
	return LoanStatus_Unspecified
}

// Referrer defines the referrer
type Referrer struct {
	// Optional name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Unique referral code with 8 alphanumeric characters
	ReferralCode string `protobuf:"bytes,2,opt,name=referral_code,json=referralCode,proto3" json:"referral_code,omitempty"`
	// Referrer address
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// Referral fee factor
	ReferralFeeFactor cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=referral_fee_factor,json=referralFeeFactor,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"referral_fee_factor"`
}

func (m *Referrer) Reset()         { *m = Referrer{} }
func (m *Referrer) String() string { return proto.CompactTextString(m) }
func (*Referrer) ProtoMessage()    {}
func (*Referrer) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{7}
}
func (m *Referrer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Referrer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Referrer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Referrer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Referrer.Merge(m, src)
}
func (m *Referrer) XXX_Size() int {
	return m.Size()
}
func (m *Referrer) XXX_DiscardUnknown() {
	xxx_messageInfo_Referrer.DiscardUnknown(m)
}

var xxx_messageInfo_Referrer proto.InternalMessageInfo

func (m *Referrer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Referrer) GetReferralCode() string {
	if m != nil {
		return m.ReferralCode
	}
	return ""
}

func (m *Referrer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// LeafScript defines the tap leaf script
type LeafScript struct {
	Script       string `protobuf:"bytes,1,opt,name=script,proto3" json:"script,omitempty"`
	ControlBlock string `protobuf:"bytes,2,opt,name=control_block,json=controlBlock,proto3" json:"control_block,omitempty"`
}

func (m *LeafScript) Reset()         { *m = LeafScript{} }
func (m *LeafScript) String() string { return proto.CompactTextString(m) }
func (*LeafScript) ProtoMessage()    {}
func (*LeafScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{8}
}
func (m *LeafScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeafScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeafScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafScript.Merge(m, src)
}
func (m *LeafScript) XXX_Size() int {
	return m.Size()
}
func (m *LeafScript) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafScript.DiscardUnknown(m)
}

var xxx_messageInfo_LeafScript proto.InternalMessageInfo

func (m *LeafScript) GetScript() string {
	if m != nil {
		return m.Script
	}
	return ""
}

func (m *LeafScript) GetControlBlock() string {
	if m != nil {
		return m.ControlBlock
	}
	return ""
}

type CetInfo struct {
	EventId        uint64     `protobuf:"varint,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	OutcomeIndex   uint32     `protobuf:"varint,2,opt,name=outcome_index,json=outcomeIndex,proto3" json:"outcome_index,omitempty"`
	SignaturePoint string     `protobuf:"bytes,3,opt,name=signature_point,json=signaturePoint,proto3" json:"signature_point,omitempty"`
	Script         LeafScript `protobuf:"bytes,4,opt,name=script,proto3" json:"script"`
	SighashType    uint32     `protobuf:"varint,5,opt,name=sighash_type,json=sighashType,proto3" json:"sighash_type,omitempty"`
}

func (m *CetInfo) Reset()         { *m = CetInfo{} }
func (m *CetInfo) String() string { return proto.CompactTextString(m) }
func (*CetInfo) ProtoMessage()    {}
func (*CetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{9}
}
func (m *CetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CetInfo.Merge(m, src)
}
func (m *CetInfo) XXX_Size() int {
	return m.Size()
}
func (m *CetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CetInfo proto.InternalMessageInfo

func (m *CetInfo) GetEventId() uint64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *CetInfo) GetOutcomeIndex() uint32 {
	if m != nil {
		return m.OutcomeIndex
	}
	return 0
}

func (m *CetInfo) GetSignaturePoint() string {
	if m != nil {
		return m.SignaturePoint
	}
	return ""
}

func (m *CetInfo) GetScript() LeafScript {
	if m != nil {
		return m.Script
	}
	return LeafScript{}
}

func (m *CetInfo) GetSighashType() uint32 {
	if m != nil {
		return m.SighashType
	}
	return 0
}

type LiquidationCet struct {
	Tx                        string   `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	BorrowerAdaptorSignatures []string `protobuf:"bytes,2,rep,name=borrower_adaptor_signatures,json=borrowerAdaptorSignatures,proto3" json:"borrower_adaptor_signatures,omitempty"`
	BorrowerAdaptedSignatures []string `protobuf:"bytes,3,rep,name=borrower_adapted_signatures,json=borrowerAdaptedSignatures,proto3" json:"borrower_adapted_signatures,omitempty"`
	DCMSignatures             []string `protobuf:"bytes,4,rep,name=dcm_signatures,json=dcmSignatures,proto3" json:"dcm_signatures,omitempty"`
	SignedTxHex               string   `protobuf:"bytes,5,opt,name=signed_tx_hex,json=signedTxHex,proto3" json:"signed_tx_hex,omitempty"`
}

func (m *LiquidationCet) Reset()         { *m = LiquidationCet{} }
func (m *LiquidationCet) String() string { return proto.CompactTextString(m) }
func (*LiquidationCet) ProtoMessage()    {}
func (*LiquidationCet) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{10}
}
func (m *LiquidationCet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidationCet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidationCet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidationCet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidationCet.Merge(m, src)
}
func (m *LiquidationCet) XXX_Size() int {
	return m.Size()
}
func (m *LiquidationCet) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidationCet.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidationCet proto.InternalMessageInfo

func (m *LiquidationCet) GetTx() string {
	if m != nil {
		return m.Tx
	}
	return ""
}

func (m *LiquidationCet) GetBorrowerAdaptorSignatures() []string {
	if m != nil {
		return m.BorrowerAdaptorSignatures
	}
	return nil
}

func (m *LiquidationCet) GetBorrowerAdaptedSignatures() []string {
	if m != nil {
		return m.BorrowerAdaptedSignatures
	}
	return nil
}

func (m *LiquidationCet) GetDCMSignatures() []string {
	if m != nil {
		return m.DCMSignatures
	}
	return nil
}

func (m *LiquidationCet) GetSignedTxHex() string {
	if m != nil {
		return m.SignedTxHex
	}
	return ""
}

type RepaymentCet struct {
	Tx                   string   `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	DCMAdaptorSignatures []string `protobuf:"bytes,2,rep,name=dcm_adaptor_signatures,json=dcmAdaptorSignatures,proto3" json:"dcm_adaptor_signatures,omitempty"`
	DCMAdaptedSignatures []string `protobuf:"bytes,3,rep,name=dcm_adapted_signatures,json=dcmAdaptedSignatures,proto3" json:"dcm_adapted_signatures,omitempty"`
	BorrowerSignatures   []string `protobuf:"bytes,4,rep,name=borrower_signatures,json=borrowerSignatures,proto3" json:"borrower_signatures,omitempty"`
	SignedTxHex          string   `protobuf:"bytes,5,opt,name=signed_tx_hex,json=signedTxHex,proto3" json:"signed_tx_hex,omitempty"`
}

func (m *RepaymentCet) Reset()         { *m = RepaymentCet{} }
func (m *RepaymentCet) String() string { return proto.CompactTextString(m) }
func (*RepaymentCet) ProtoMessage()    {}
func (*RepaymentCet) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{11}
}
func (m *RepaymentCet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepaymentCet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepaymentCet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepaymentCet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepaymentCet.Merge(m, src)
}
func (m *RepaymentCet) XXX_Size() int {
	return m.Size()
}
func (m *RepaymentCet) XXX_DiscardUnknown() {
	xxx_messageInfo_RepaymentCet.DiscardUnknown(m)
}

var xxx_messageInfo_RepaymentCet proto.InternalMessageInfo

func (m *RepaymentCet) GetTx() string {
	if m != nil {
		return m.Tx
	}
	return ""
}

func (m *RepaymentCet) GetDCMAdaptorSignatures() []string {
	if m != nil {
		return m.DCMAdaptorSignatures
	}
	return nil
}

func (m *RepaymentCet) GetDCMAdaptedSignatures() []string {
	if m != nil {
		return m.DCMAdaptedSignatures
	}
	return nil
}

func (m *RepaymentCet) GetBorrowerSignatures() []string {
	if m != nil {
		return m.BorrowerSignatures
	}
	return nil
}

func (m *RepaymentCet) GetSignedTxHex() string {
	if m != nil {
		return m.SignedTxHex
	}
	return ""
}

type DLCMeta struct {
	LiquidationCet        LiquidationCet `protobuf:"bytes,1,opt,name=liquidation_cet,json=liquidationCet,proto3" json:"liquidation_cet"`
	DefaultLiquidationCet LiquidationCet `protobuf:"bytes,2,opt,name=default_liquidation_cet,json=defaultLiquidationCet,proto3" json:"default_liquidation_cet"`
	RepaymentCet          RepaymentCet   `protobuf:"bytes,3,opt,name=repayment_cet,json=repaymentCet,proto3" json:"repayment_cet"`
	TimeoutRefundTx       string         `protobuf:"bytes,4,opt,name=timeout_refund_tx,json=timeoutRefundTx,proto3" json:"timeout_refund_tx,omitempty"`
	VaultUtxos            []*types1.UTXO `protobuf:"bytes,5,rep,name=vault_utxos,json=vaultUtxos,proto3" json:"vault_utxos,omitempty"`
	InternalKey           string         `protobuf:"bytes,6,opt,name=internal_key,json=internalKey,proto3" json:"internal_key,omitempty"`
	LiquidationScript     LeafScript     `protobuf:"bytes,7,opt,name=liquidation_script,json=liquidationScript,proto3" json:"liquidation_script"`
	RepaymentScript       LeafScript     `protobuf:"bytes,8,opt,name=repayment_script,json=repaymentScript,proto3" json:"repayment_script"`
	TimeoutRefundScript   LeafScript     `protobuf:"bytes,9,opt,name=timeout_refund_script,json=timeoutRefundScript,proto3" json:"timeout_refund_script"`
}

func (m *DLCMeta) Reset()         { *m = DLCMeta{} }
func (m *DLCMeta) String() string { return proto.CompactTextString(m) }
func (*DLCMeta) ProtoMessage()    {}
func (*DLCMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{12}
}
func (m *DLCMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DLCMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DLCMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DLCMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DLCMeta.Merge(m, src)
}
func (m *DLCMeta) XXX_Size() int {
	return m.Size()
}
func (m *DLCMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_DLCMeta.DiscardUnknown(m)
}

var xxx_messageInfo_DLCMeta proto.InternalMessageInfo

func (m *DLCMeta) GetLiquidationCet() LiquidationCet {
	if m != nil {
		return m.LiquidationCet
	}
	return LiquidationCet{}
}

func (m *DLCMeta) GetDefaultLiquidationCet() LiquidationCet {
	if m != nil {
		return m.DefaultLiquidationCet
	}
	return LiquidationCet{}
}

func (m *DLCMeta) GetRepaymentCet() RepaymentCet {
	if m != nil {
		return m.RepaymentCet
	}
	return RepaymentCet{}
}

func (m *DLCMeta) GetTimeoutRefundTx() string {
	if m != nil {
		return m.TimeoutRefundTx
	}
	return ""
}

func (m *DLCMeta) GetVaultUtxos() []*types1.UTXO {
	if m != nil {
		return m.VaultUtxos
	}
	return nil
}

func (m *DLCMeta) GetInternalKey() string {
	if m != nil {
		return m.InternalKey
	}
	return ""
}

func (m *DLCMeta) GetLiquidationScript() LeafScript {
	if m != nil {
		return m.LiquidationScript
	}
	return LeafScript{}
}

func (m *DLCMeta) GetRepaymentScript() LeafScript {
	if m != nil {
		return m.RepaymentScript
	}
	return LeafScript{}
}

func (m *DLCMeta) GetTimeoutRefundScript() LeafScript {
	if m != nil {
		return m.TimeoutRefundScript
	}
	return LeafScript{}
}

type DepositLog struct {
	Txid            string        `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	VaultAddress    string        `protobuf:"bytes,2,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	AuthorizationId uint64        `protobuf:"varint,3,opt,name=authorization_id,json=authorizationId,proto3" json:"authorization_id,omitempty"`
	DepositTx       string        `protobuf:"bytes,4,opt,name=deposit_tx,json=depositTx,proto3" json:"deposit_tx,omitempty"`
	Status          DepositStatus `protobuf:"varint,5,opt,name=status,proto3,enum=bitway.lending.DepositStatus" json:"status,omitempty"`
}

func (m *DepositLog) Reset()         { *m = DepositLog{} }
func (m *DepositLog) String() string { return proto.CompactTextString(m) }
func (*DepositLog) ProtoMessage()    {}
func (*DepositLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{13}
}
func (m *DepositLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositLog.Merge(m, src)
}
func (m *DepositLog) XXX_Size() int {
	return m.Size()
}
func (m *DepositLog) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositLog.DiscardUnknown(m)
}

var xxx_messageInfo_DepositLog proto.InternalMessageInfo

func (m *DepositLog) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *DepositLog) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *DepositLog) GetAuthorizationId() uint64 {
	if m != nil {
		return m.AuthorizationId
	}
	return 0
}

func (m *DepositLog) GetDepositTx() string {
	if m != nil {
		return m.DepositTx
	}
	return ""
}

func (m *DepositLog) GetStatus() DepositStatus {
	if m != nil {
		return m.Status
	}
	return DepositStatus_DEPOSIT_STATUS_PENDING
}

type Repayment struct {
	LoanId   string     `protobuf:"bytes,1,opt,name=loan_id,json=loanId,proto3" json:"loan_id,omitempty"`
	Amount   types.Coin `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	CreateAt time.Time  `protobuf:"bytes,3,opt,name=create_at,json=createAt,proto3,stdtime" json:"create_at"`
}

func (m *Repayment) Reset()         { *m = Repayment{} }
func (m *Repayment) String() string { return proto.CompactTextString(m) }
func (*Repayment) ProtoMessage()    {}
func (*Repayment) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{14}
}
func (m *Repayment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repayment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repayment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repayment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repayment.Merge(m, src)
}
func (m *Repayment) XXX_Size() int {
	return m.Size()
}
func (m *Repayment) XXX_DiscardUnknown() {
	xxx_messageInfo_Repayment.DiscardUnknown(m)
}

var xxx_messageInfo_Repayment proto.InternalMessageInfo

func (m *Repayment) GetLoanId() string {
	if m != nil {
		return m.LoanId
	}
	return ""
}

func (m *Repayment) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func (m *Repayment) GetCreateAt() time.Time {
	if m != nil {
		return m.CreateAt
	}
	return time.Time{}
}

type Redemption struct {
	Id            uint64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	LoanId        string    `protobuf:"bytes,2,opt,name=loan_id,json=loanId,proto3" json:"loan_id,omitempty"`
	Txid          string    `protobuf:"bytes,3,opt,name=txid,proto3" json:"txid,omitempty"`
	Tx            string    `protobuf:"bytes,4,opt,name=tx,proto3" json:"tx,omitempty"`
	Signatures    []string  `protobuf:"bytes,5,rep,name=signatures,proto3" json:"signatures,omitempty"`
	DCMSignatures []string  `protobuf:"bytes,6,rep,name=dcm_signatures,json=dcmSignatures,proto3" json:"dcm_signatures,omitempty"`
	CreateAt      time.Time `protobuf:"bytes,7,opt,name=create_at,json=createAt,proto3,stdtime" json:"create_at"`
}

func (m *Redemption) Reset()         { *m = Redemption{} }
func (m *Redemption) String() string { return proto.CompactTextString(m) }
func (*Redemption) ProtoMessage()    {}
func (*Redemption) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb241e8d4b740022, []int{15}
}
func (m *Redemption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Redemption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Redemption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Redemption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redemption.Merge(m, src)
}
func (m *Redemption) XXX_Size() int {
	return m.Size()
}
func (m *Redemption) XXX_DiscardUnknown() {
	xxx_messageInfo_Redemption.DiscardUnknown(m)
}

var xxx_messageInfo_Redemption proto.InternalMessageInfo

func (m *Redemption) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Redemption) GetLoanId() string {
	if m != nil {
		return m.LoanId
	}
	return ""
}

func (m *Redemption) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

func (m *Redemption) GetTx() string {
	if m != nil {
		return m.Tx
	}
	return ""
}

func (m *Redemption) GetSignatures() []string {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *Redemption) GetDCMSignatures() []string {
	if m != nil {
		return m.DCMSignatures
	}
	return nil
}

func (m *Redemption) GetCreateAt() time.Time {
	if m != nil {
		return m.CreateAt
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("bitway.lending.PoolStatus", PoolStatus_name, PoolStatus_value)
	proto.RegisterEnum("bitway.lending.LoanStatus", LoanStatus_name, LoanStatus_value)
	proto.RegisterEnum("bitway.lending.AuthorizationStatus", AuthorizationStatus_name, AuthorizationStatus_value)
	proto.RegisterEnum("bitway.lending.CetType", CetType_name, CetType_value)
	proto.RegisterEnum("bitway.lending.DepositStatus", DepositStatus_name, DepositStatus_value)
	proto.RegisterEnum("bitway.lending.SigningIntent", SigningIntent_name, SigningIntent_value)
	proto.RegisterType((*AssetMetadata)(nil), "bitway.lending.AssetMetadata")
	proto.RegisterType((*PoolTrancheConfig)(nil), "bitway.lending.PoolTrancheConfig")
	proto.RegisterType((*PoolConfig)(nil), "bitway.lending.PoolConfig")
	proto.RegisterType((*PoolTranche)(nil), "bitway.lending.PoolTranche")
	proto.RegisterType((*LendingPool)(nil), "bitway.lending.LendingPool")
	proto.RegisterType((*Authorization)(nil), "bitway.lending.Authorization")
	proto.RegisterType((*Loan)(nil), "bitway.lending.Loan")
	proto.RegisterType((*Referrer)(nil), "bitway.lending.Referrer")
	proto.RegisterType((*LeafScript)(nil), "bitway.lending.LeafScript")
	proto.RegisterType((*CetInfo)(nil), "bitway.lending.CetInfo")
	proto.RegisterType((*LiquidationCet)(nil), "bitway.lending.LiquidationCet")
	proto.RegisterType((*RepaymentCet)(nil), "bitway.lending.RepaymentCet")
	proto.RegisterType((*DLCMeta)(nil), "bitway.lending.DLCMeta")
	proto.RegisterType((*DepositLog)(nil), "bitway.lending.DepositLog")
	proto.RegisterType((*Repayment)(nil), "bitway.lending.Repayment")
	proto.RegisterType((*Redemption)(nil), "bitway.lending.Redemption")
}

func init() { proto.RegisterFile("bitway/lending/lending.proto", fileDescriptor_eb241e8d4b740022) }

var fileDescriptor_eb241e8d4b740022 = []byte{
	// 2462 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x59, 0xc9, 0x6f, 0x23, 0xc7,
	0xd5, 0x17, 0x17, 0x51, 0xe4, 0xe3, 0xaa, 0x92, 0x66, 0x86, 0x9a, 0x45, 0xd2, 0x70, 0x60, 0x7f,
	0xf3, 0x0d, 0x6c, 0x0a, 0x1e, 0x3b, 0xb0, 0x83, 0x2c, 0x30, 0x37, 0xcd, 0xb4, 0x2d, 0x69, 0x94,
	0x56, 0xcb, 0x88, 0x8d, 0x24, 0x8d, 0x62, 0x77, 0x89, 0xea, 0x4c, 0xb3, 0x8b, 0xee, 0x2e, 0xca,
	0x54, 0x80, 0x20, 0x40, 0x72, 0xca, 0xcd, 0x40, 0x72, 0xca, 0x29, 0xf7, 0x5c, 0x73, 0xcb, 0x25,
	0xa7, 0xc0, 0x40, 0x0e, 0x31, 0x72, 0x0a, 0x72, 0x50, 0x02, 0xcd, 0xff, 0x90, 0x4b, 0x80, 0x20,
	0xa8, 0xa5, 0x9b, 0xcd, 0x25, 0x1a, 0x4a, 0x27, 0x75, 0xbd, 0xad, 0x5e, 0xbd, 0x7a, 0xef, 0xf7,
	0x5e, 0x51, 0x70, 0xbf, 0xeb, 0xb0, 0x2f, 0xf0, 0xf9, 0x8e, 0x4b, 0x3c, 0xdb, 0xf1, 0x7a, 0xe1,
	0xdf, 0xfa, 0xc0, 0xa7, 0x8c, 0xa2, 0x92, 0xe4, 0xd6, 0x15, 0xf5, 0xee, 0x7a, 0x8f, 0xf6, 0xa8,
	0x60, 0xed, 0xf0, 0x2f, 0x29, 0x75, 0x77, 0xab, 0x47, 0x69, 0xcf, 0x25, 0x3b, 0x62, 0xd5, 0x1d,
	0x9e, 0xec, 0x30, 0xa7, 0x4f, 0x02, 0x86, 0xfb, 0x03, 0x25, 0xb0, 0x69, 0xd1, 0xa0, 0x4f, 0x83,
	0x9d, 0x2e, 0x0e, 0xc8, 0xce, 0xd9, 0x3b, 0x5d, 0xc2, 0xf0, 0x3b, 0x3b, 0x16, 0x75, 0x3c, 0xc5,
	0xdf, 0x90, 0x7c, 0x53, 0x5a, 0x96, 0x0b, 0xc5, 0xda, 0x56, 0xfe, 0x75, 0x99, 0xd5, 0xf5, 0x1d,
	0xbb, 0x47, 0xc6, 0x5f, 0x52, 0xa2, 0xf6, 0xbb, 0x04, 0x14, 0x1b, 0x41, 0x40, 0xd8, 0x3e, 0x61,
	0xd8, 0xc6, 0x0c, 0xa3, 0x75, 0x58, 0xb6, 0x89, 0x47, 0xfb, 0xd5, 0xc4, 0x76, 0xe2, 0x71, 0x4e,
	0x97, 0x0b, 0x74, 0x1b, 0x32, 0xc1, 0x79, 0xbf, 0x4b, 0xdd, 0x6a, 0x52, 0x90, 0xd5, 0x0a, 0xdd,
	0x85, 0xac, 0x4d, 0x2c, 0xa7, 0x8f, 0xdd, 0xa0, 0x9a, 0xda, 0x4e, 0x3c, 0x5e, 0xd6, 0xa3, 0x35,
	0x7a, 0x08, 0x85, 0x81, 0xef, 0x58, 0xc4, 0x54, 0x9a, 0x69, 0xa1, 0x99, 0x17, 0xb4, 0x23, 0xa9,
	0xfe, 0x36, 0xac, 0x39, 0x81, 0xc9, 0x4f, 0x66, 0x4a, 0x51, 0xcc, 0x7d, 0xa9, 0x2e, 0x6f, 0x27,
	0x1e, 0x67, 0xf5, 0x8a, 0x13, 0x34, 0x71, 0x40, 0x0e, 0x39, 0x43, 0xf8, 0x58, 0xfb, 0x21, 0xac,
	0x1e, 0x52, 0xea, 0x1a, 0x3e, 0xf6, 0xac, 0x53, 0xd2, 0xa2, 0xde, 0x89, 0xd3, 0xe3, 0x2e, 0xf4,
	0x31, 0x1b, 0xfa, 0x0e, 0x3b, 0x17, 0x3e, 0xa7, 0xf4, 0x68, 0x8d, 0xde, 0x02, 0xe8, 0x52, 0xdf,
	0xa7, 0x5f, 0x98, 0x78, 0xe0, 0x0b, 0xd7, 0x8b, 0xcd, 0xe2, 0xe5, 0xc5, 0x56, 0xae, 0x29, 0xa8,
	0x8d, 0x43, 0x5d, 0xcf, 0x49, 0x81, 0xc6, 0xc0, 0xaf, 0xfd, 0x3c, 0x03, 0xc0, 0xed, 0x2b, 0xc3,
	0x07, 0x50, 0xb1, 0xa8, 0xeb, 0x62, 0x46, 0x7c, 0xec, 0x2a, 0xcf, 0xf8, 0x06, 0xf9, 0xa7, 0x0f,
	0xea, 0x93, 0x57, 0x5b, 0x9f, 0x08, 0x61, 0x33, 0xfd, 0xd5, 0xc5, 0xd6, 0x92, 0x5e, 0x1e, 0x2b,
	0x0b, 0x36, 0x7a, 0x0e, 0x45, 0x25, 0xaf, 0x8c, 0x25, 0x17, 0x37, 0x56, 0x50, 0x4c, 0x69, 0xe9,
	0xdb, 0x00, 0xc1, 0x70, 0x30, 0x70, 0xcf, 0x4d, 0x0b, 0x0f, 0x44, 0xdc, 0x73, 0xcd, 0x07, 0x5c,
	0xee, 0xef, 0x17, 0x5b, 0xb7, 0x64, 0x06, 0x04, 0xf6, 0xcb, 0xba, 0x43, 0x77, 0xfa, 0x98, 0x9d,
	0xd6, 0x35, 0x8f, 0xe9, 0x39, 0xa9, 0xd0, 0xc2, 0x03, 0xae, 0xad, 0x82, 0xc2, 0xb5, 0xd3, 0x0b,
	0x69, 0x4b, 0x05, 0xae, 0xad, 0xc1, 0x6a, 0xdf, 0xf1, 0xcc, 0x30, 0xac, 0x7d, 0x3a, 0xf4, 0xe4,
	0x85, 0xbd, 0xd6, 0x48, 0xb9, 0xef, 0x78, 0x2a, 0xee, 0x42, 0x4b, 0x98, 0xc2, 0xa3, 0x29, 0x53,
	0x99, 0xc5, 0x4c, 0xe1, 0xd1, 0x84, 0xa9, 0x16, 0x64, 0x99, 0xcc, 0x8a, 0xa0, 0xba, 0xb2, 0x9d,
	0x7a, 0x9c, 0x7f, 0xfa, 0x70, 0x3a, 0xac, 0x33, 0x99, 0xa3, 0x42, 0x1b, 0x29, 0xa2, 0x0f, 0x21,
	0xef, 0x93, 0xcf, 0x87, 0x24, 0x60, 0xe6, 0x09, 0x21, 0xd5, 0xac, 0xb8, 0x9e, 0x8d, 0xba, 0x2a,
	0x29, 0x9e, 0xa5, 0x75, 0x55, 0x7f, 0xf5, 0x16, 0x75, 0x3c, 0xa5, 0x0f, 0x4a, 0x67, 0x97, 0x10,
	0xf4, 0x1e, 0xdc, 0xa6, 0xbe, 0xd3, 0x73, 0x3c, 0xcc, 0x1c, 0xea, 0x71, 0x2b, 0xe6, 0x09, 0xb6,
	0x18, 0xf5, 0xab, 0x39, 0x9e, 0x7b, 0xfa, 0x7a, 0x8c, 0xbb, 0x4b, 0xc8, 0xae, 0xe0, 0xa1, 0x37,
	0xa0, 0xe4, 0x93, 0x80, 0xf8, 0x67, 0x91, 0x34, 0x08, 0xe9, 0xa2, 0xa2, 0x2a, 0xb1, 0x3b, 0xb0,
	0xc2, 0xc3, 0xe5, 0xb2, 0xb3, 0x6a, 0x5e, 0xf0, 0x33, 0x7d, 0x3c, 0xda, 0x63, 0x67, 0xe8, 0x5d,
	0xb8, 0xe5, 0x3a, 0x9f, 0x0f, 0x1d, 0x5b, 0xee, 0xca, 0x4e, 0x7d, 0x12, 0x9c, 0x52, 0xd7, 0xae,
	0x16, 0xe4, 0xa6, 0x31, 0xa6, 0x11, 0xf2, 0x78, 0x45, 0x0f, 0xf0, 0x30, 0x20, 0x76, 0xb5, 0x28,
	0xaa, 0x4d, 0xad, 0x6a, 0xbf, 0x4c, 0x42, 0x3e, 0x16, 0xaa, 0x2b, 0xcb, 0xcb, 0x80, 0x82, 0xba,
	0x3c, 0xc7, 0xb3, 0xc9, 0x48, 0x62, 0x43, 0xf3, 0x1d, 0x75, 0x77, 0xf7, 0x66, 0xef, 0x6e, 0x8f,
	0xf4, 0xb0, 0x75, 0xde, 0x26, 0xd6, 0x5f, 0x7f, 0xff, 0x36, 0xa8, 0xb8, 0xb6, 0x89, 0xa5, 0xe7,
	0xa5, 0x19, 0x8d, 0x5b, 0x41, 0x6d, 0x28, 0x31, 0xca, 0xb0, 0xab, 0x12, 0x83, 0xd8, 0x8b, 0x65,
	0x78, 0x51, 0x28, 0x35, 0x95, 0x0e, 0x6a, 0x82, 0x24, 0x98, 0x2a, 0x88, 0x8b, 0x25, 0x7a, 0x41,
	0xe8, 0xe8, 0x52, 0xa5, 0xf6, 0x87, 0x65, 0xc8, 0xef, 0xc9, 0xf4, 0xe1, 0x21, 0x41, 0x25, 0x48,
	0x3a, 0xb6, 0x02, 0xc6, 0xa4, 0x63, 0xa3, 0xf7, 0x21, 0x23, 0xcb, 0x4a, 0x95, 0xf2, 0x6b, 0x73,
	0x45, 0x89, 0xa3, 0xe7, 0x50, 0xc1, 0x67, 0xd8, 0x71, 0x71, 0xd7, 0x25, 0x61, 0xe2, 0x2f, 0x74,
	0xc8, 0x72, 0xa4, 0xa6, 0x12, 0x7f, 0x17, 0xca, 0x61, 0x98, 0x42, 0x43, 0x0b, 0x1d, 0xb4, 0x14,
	0x6a, 0x29, 0x3b, 0xb3, 0x41, 0x5f, 0xbe, 0x41, 0xd0, 0xdb, 0xe3, 0x4c, 0xbe, 0x4e, 0x39, 0x87,
	0x89, 0xae, 0x7c, 0x99, 0xb9, 0xba, 0x95, 0x6b, 0x5f, 0x1d, 0x32, 0x42, 0x1b, 0xe7, 0x8c, 0xbe,
	0x24, 0x5e, 0xf0, 0xfa, 0x6a, 0x5e, 0xe7, 0xe6, 0x2f, 0x2f, 0xb6, 0x0a, 0x06, 0xd7, 0xfb, 0xd4,
	0x10, 0x6a, 0xca, 0xea, 0xa7, 0xd2, 0x08, 0xfa, 0x4e, 0x0c, 0x66, 0x72, 0x02, 0x66, 0xee, 0x5d,
	0x01, 0x33, 0x33, 0x00, 0xf3, 0x01, 0x64, 0x2c, 0x01, 0x3d, 0xa2, 0xc0, 0xf3, 0x4f, 0xef, 0xce,
	0x53, 0x9e, 0x00, 0x27, 0x25, 0x8f, 0x9e, 0x42, 0x26, 0x60, 0x98, 0x0d, 0x03, 0x51, 0xfa, 0xa5,
	0xf9, 0x9a, 0x47, 0x42, 0x42, 0x57, 0x92, 0xb5, 0x9f, 0x42, 0xb1, 0x31, 0x64, 0xa7, 0xd4, 0x77,
	0x7e, 0x22, 0x6a, 0x3f, 0x96, 0xbe, 0x69, 0x91, 0xbe, 0x5b, 0x90, 0xb7, 0xc9, 0x80, 0x06, 0x0e,
	0x33, 0xd9, 0x28, 0xa8, 0x26, 0xb7, 0x53, 0x8f, 0x73, 0x3a, 0x28, 0x92, 0x31, 0x0a, 0xd0, 0xb7,
	0xa2, 0x5d, 0x53, 0x62, 0xd7, 0x47, 0x33, 0xad, 0x2a, 0x6e, 0x7f, 0x6a, 0xfb, 0x3f, 0x03, 0xa4,
	0xf7, 0x28, 0xf6, 0xd0, 0x23, 0x28, 0x9e, 0xe1, 0xa1, 0xcb, 0x4c, 0x6c, 0xdb, 0x3e, 0x09, 0x02,
	0x55, 0x40, 0x05, 0x41, 0x6c, 0x48, 0x1a, 0x87, 0x19, 0x95, 0x79, 0xbe, 0x1a, 0x31, 0xa2, 0x35,
	0x7a, 0x13, 0xc2, 0x6c, 0xf5, 0x0f, 0x87, 0xdd, 0x8f, 0xc9, 0xb9, 0xac, 0x15, 0x7d, 0x8a, 0x8a,
	0xea, 0x80, 0x42, 0x0a, 0x77, 0x4c, 0xc9, 0xca, 0xb1, 0x63, 0x0e, 0x07, 0x6d, 0x40, 0xca, 0xb6,
	0xfa, 0x2a, 0xd1, 0x57, 0x2e, 0x2f, 0xb6, 0x52, 0xed, 0xd6, 0xbe, 0xce, 0x69, 0xdc, 0xe7, 0x10,
	0xe5, 0x4c, 0x3e, 0x90, 0x89, 0x3c, 0x4e, 0xe9, 0x85, 0x90, 0x68, 0x38, 0x7d, 0xc2, 0x85, 0x4e,
	0x1c, 0x0f, 0xbb, 0x42, 0x82, 0x0e, 0x99, 0xc8, 0xd3, 0x94, 0x5e, 0x10, 0x44, 0x43, 0xd2, 0x38,
	0x6a, 0x0f, 0x28, 0x75, 0x4d, 0xc7, 0x16, 0x29, 0x98, 0xd3, 0x33, 0x7c, 0xa9, 0xf1, 0x5a, 0x29,
	0x4e, 0x76, 0xbe, 0xdc, 0x62, 0x18, 0xa2, 0x20, 0x57, 0xd5, 0xca, 0x54, 0xcf, 0x82, 0xeb, 0xf7,
	0xac, 0x5d, 0x28, 0x4f, 0xf5, 0x2c, 0x91, 0x63, 0xaf, 0x47, 0x90, 0xc9, 0x5e, 0x86, 0xbe, 0x09,
	0x59, 0xc7, 0x63, 0xc4, 0x27, 0x01, 0x13, 0x8d, 0xe7, 0xb5, 0x06, 0x22, 0x71, 0xf4, 0x21, 0x9f,
	0x14, 0x29, 0xa3, 0x16, 0x75, 0xc5, 0xfe, 0xc5, 0x45, 0xd4, 0xf3, 0xa1, 0x0a, 0xdf, 0x3c, 0xde,
	0xa5, 0x4a, 0x57, 0x0e, 0x81, 0xe5, 0xab, 0x87, 0x40, 0x64, 0x02, 0x0a, 0x18, 0xf6, 0x99, 0x39,
	0xd1, 0xd9, 0x2a, 0x37, 0xed, 0x6c, 0x15, 0x61, 0xac, 0x19, 0x6b, 0x6f, 0x3f, 0x82, 0xd5, 0x78,
	0xb7, 0x16, 0x73, 0x6f, 0x75, 0xf5, 0xc6, 0xf6, 0x63, 0xb6, 0xc4, 0xa4, 0x8c, 0xb6, 0xa1, 0x60,
	0xbb, 0x96, 0x49, 0xce, 0x88, 0xc7, 0x78, 0xd6, 0x21, 0x51, 0xef, 0x60, 0xbb, 0x56, 0x87, 0x93,
	0x34, 0x1b, 0x7d, 0x0c, 0x25, 0x1c, 0x2f, 0xdc, 0xa0, 0xba, 0x26, 0xb0, 0xec, 0xc1, 0x95, 0xe5,
	0xad, 0x52, 0x67, 0x4a, 0x15, 0x7d, 0x04, 0xab, 0xf1, 0x29, 0x59, 0xa6, 0xf2, 0xfa, 0x22, 0x17,
	0x18, 0x9b, 0xae, 0x55, 0x32, 0xbf, 0x01, 0xa5, 0x78, 0x68, 0x1c, 0xbb, 0x7a, 0x4b, 0x38, 0x5f,
	0x8c, 0x51, 0x35, 0x1b, 0xbd, 0x07, 0x59, 0x9f, 0x9c, 0x10, 0xdf, 0x27, 0x7e, 0xf5, 0xb6, 0x48,
	0xf8, 0xea, 0xb4, 0xe7, 0xba, 0xe2, 0xeb, 0x91, 0x24, 0x6a, 0x40, 0xce, 0xf2, 0x09, 0x66, 0xc4,
	0xc4, 0xac, 0x7a, 0x47, 0xe1, 0xaf, 0x7c, 0x7c, 0xd5, 0xc3, 0xc7, 0x57, 0xdd, 0x08, 0x1f, 0x5f,
	0xcd, 0x2c, 0x77, 0xfe, 0xcb, 0x7f, 0x6c, 0x25, 0xf4, 0xac, 0x54, 0x6b, 0x30, 0xd4, 0x81, 0xbc,
	0xed, 0x04, 0xdd, 0xa1, 0x1f, 0x08, 0x23, 0xd5, 0x6b, 0x18, 0x81, 0x50, 0xb1, 0xc1, 0x62, 0x60,
	0xbe, 0x31, 0x1f, 0xcc, 0x39, 0x6c, 0x4e, 0xa1, 0xe9, 0x1f, 0x13, 0x90, 0x0d, 0x0f, 0x85, 0x10,
	0xa4, 0x3d, 0xdc, 0x27, 0x0a, 0x48, 0xc5, 0x37, 0x07, 0x23, 0x79, 0x54, 0xec, 0x9a, 0x16, 0xb5,
	0x89, 0x42, 0xd1, 0x42, 0x48, 0x6c, 0x51, 0x9b, 0xa0, 0x2a, 0xac, 0x84, 0x20, 0x2c, 0x21, 0x34,
	0x5c, 0x22, 0x0c, 0x6b, 0x91, 0x7a, 0x6c, 0x6c, 0x4d, 0xdf, 0x34, 0x2f, 0x57, 0x43, 0x6b, 0xd1,
	0x98, 0x5b, 0xd3, 0x00, 0xf6, 0x08, 0x3e, 0x39, 0xb2, 0x7c, 0x67, 0xc0, 0xc4, 0x8b, 0x52, 0x7c,
	0xa9, 0x53, 0xa8, 0x15, 0x3f, 0x87, 0x45, 0x3d, 0xe6, 0x53, 0xd7, 0xec, 0xba, 0xd4, 0x7a, 0x19,
	0x9e, 0x43, 0x11, 0x9b, 0x9c, 0x56, 0xfb, 0x4b, 0x02, 0x56, 0x5a, 0x84, 0x69, 0xde, 0x09, 0x45,
	0x1b, 0x90, 0x8d, 0x72, 0x5d, 0xf6, 0xb6, 0x15, 0xa2, 0x12, 0xfd, 0x11, 0x14, 0xe9, 0x90, 0x59,
	0xb4, 0x4f, 0x62, 0x03, 0x6a, 0x51, 0x2f, 0x28, 0xa2, 0xac, 0xc7, 0xff, 0x83, 0x72, 0xe0, 0xf4,
	0x3c, 0x8e, 0x16, 0xc4, 0x1c, 0x50, 0x27, 0x1c, 0xc5, 0xf4, 0x52, 0x44, 0x3e, 0xe4, 0x54, 0xde,
	0xbd, 0x95, 0xc7, 0xe9, 0xf9, 0xdd, 0x7b, 0x7c, 0xba, 0x68, 0xdc, 0x93, 0x67, 0x7a, 0x08, 0x85,
	0xc0, 0xe9, 0x9d, 0xe2, 0xe0, 0xd4, 0x64, 0xe7, 0x03, 0x22, 0x3a, 0x4e, 0x51, 0xcf, 0x2b, 0x9a,
	0x71, 0x3e, 0x20, 0xb5, 0xff, 0x24, 0xa0, 0xb4, 0x37, 0xce, 0xf2, 0x16, 0x61, 0xbc, 0x5d, 0xb3,
	0x51, 0x38, 0x6d, 0xb2, 0x11, 0xfa, 0x2e, 0xdc, 0x0b, 0x9b, 0x98, 0x89, 0x6d, 0x3c, 0x60, 0xd4,
	0x37, 0x23, 0x17, 0xc3, 0xf6, 0xbd, 0x11, 0xf5, 0x39, 0x29, 0x71, 0x14, 0x09, 0xcc, 0xea, 0x13,
	0x3b, 0xae, 0x9f, 0x9a, 0xa3, 0x4f, 0xec, 0x98, 0xfe, 0x07, 0x50, 0xb2, 0xad, 0x7e, 0x5c, 0x25,
	0xcd, 0x55, 0x9a, 0xab, 0x97, 0x17, 0x5b, 0xc5, 0x76, 0x6b, 0x7f, 0x2c, 0xaa, 0x17, 0x6d, 0xab,
	0x1f, 0xd3, 0xac, 0x41, 0x91, 0x6b, 0x11, 0xdb, 0x64, 0x23, 0xf3, 0x94, 0x8c, 0x64, 0xcb, 0x15,
	0x01, 0xf0, 0x88, 0x6d, 0x8c, 0x9e, 0x93, 0x51, 0xed, 0x57, 0x49, 0x28, 0xe8, 0x64, 0x80, 0xcf,
	0xfb, 0xc4, 0x63, 0xf3, 0x8e, 0x7f, 0x00, 0xb7, 0xf9, 0xf6, 0xff, 0xeb, 0xe4, 0xcd, 0xea, 0xe5,
	0xc5, 0xd6, 0x7a, 0xbb, 0xb5, 0x3f, 0x73, 0x70, 0x7d, 0xdd, 0xb6, 0xfa, 0xb3, 0xe1, 0x88, 0xdb,
	0x9b, 0x13, 0x89, 0x49, 0x7b, 0xf1, 0x40, 0x8c, 0xed, 0x4d, 0x84, 0x67, 0x07, 0xd6, 0xa2, 0xf0,
	0x4e, 0xc7, 0x68, 0x3c, 0x7e, 0x5c, 0x33, 0x2a, 0xff, 0x4e, 0xc3, 0x4a, 0x7b, 0xaf, 0xb5, 0x4f,
	0x18, 0x46, 0xfb, 0x50, 0x8e, 0xa3, 0xa3, 0x15, 0xfd, 0x1c, 0xb1, 0x39, 0x93, 0x88, 0x13, 0x89,
	0x14, 0x02, 0xb7, 0x3b, 0x99, 0x5e, 0x3f, 0x80, 0x3b, 0x36, 0x39, 0x11, 0x83, 0xd9, 0xb4, 0xd9,
	0xe4, 0x35, 0xcc, 0xde, 0x52, 0x46, 0xa6, 0x92, 0xf7, 0x19, 0x87, 0x23, 0x75, 0x9b, 0xc2, 0x66,
	0x4a, 0xd8, 0xbc, 0x3f, 0x0b, 0xd4, 0xe3, 0x2b, 0x0f, 0x07, 0x1c, 0x3f, 0x9e, 0x06, 0x4f, 0x60,
	0x55, 0x8d, 0x57, 0xa6, 0x4f, 0x4e, 0x86, 0x1e, 0x8f, 0x96, 0x9a, 0xe9, 0xca, 0x8a, 0xa1, 0x0b,
	0xba, 0x31, 0x42, 0xef, 0x43, 0x5e, 0x4e, 0x9a, 0x43, 0x36, 0xa2, 0x41, 0x75, 0x59, 0x74, 0xb5,
	0xdb, 0xe1, 0x96, 0xe3, 0xdf, 0xbe, 0x8e, 0x8d, 0xef, 0xbf, 0xd0, 0x41, 0x88, 0x1e, 0x73, 0x49,
	0x5e, 0xa0, 0x62, 0x18, 0xe1, 0xc3, 0xdc, 0x4b, 0x72, 0x2e, 0x5f, 0x2d, 0x7a, 0x3e, 0xa4, 0xf1,
	0x61, 0xf1, 0x05, 0xa0, 0x78, 0x98, 0x14, 0x12, 0xac, 0x2c, 0x88, 0x04, 0xf1, 0x96, 0xaf, 0x00,
	0xf0, 0x63, 0xa8, 0x8c, 0x23, 0xa4, 0xcc, 0x65, 0x17, 0x34, 0x57, 0x8e, 0x34, 0x95, 0x31, 0x03,
	0x6e, 0x4d, 0x45, 0x49, 0x59, 0xcc, 0x2d, 0x68, 0x71, 0x6d, 0x22, 0x96, 0x92, 0x55, 0xfb, 0x53,
	0x02, 0xa0, 0x2d, 0x9f, 0x03, 0x7b, 0xb4, 0xc7, 0xdb, 0x0e, 0x1b, 0x45, 0x0f, 0x60, 0xf1, 0x3d,
	0x3b, 0xdc, 0x27, 0xe7, 0x0c, 0xf7, 0xff, 0x0f, 0x95, 0x89, 0xa9, 0x81, 0x43, 0x75, 0x4a, 0x40,
	0x75, 0x79, 0x82, 0xae, 0xd9, 0xe8, 0x01, 0xc0, 0xf8, 0x4d, 0xa2, 0xee, 0x39, 0x17, 0x3d, 0x49,
	0xd0, 0x37, 0xa2, 0xd6, 0xb9, 0x2c, 0x5a, 0xe7, 0xcc, 0xc8, 0xa2, 0xdc, 0x9d, 0xea, 0x9e, 0xbf,
	0x4d, 0x40, 0x2e, 0xca, 0x34, 0x3e, 0x92, 0xbb, 0x14, 0x7b, 0x66, 0x74, 0x94, 0x0c, 0x5f, 0x6a,
	0xe2, 0x3d, 0xaf, 0x06, 0x98, 0x45, 0xdf, 0xf3, 0x52, 0x7c, 0x72, 0xb6, 0x48, 0xdd, 0x64, 0xb6,
	0xa8, 0xfd, 0x2b, 0x01, 0xa0, 0x13, 0x9b, 0xf4, 0x07, 0x73, 0xdf, 0x6a, 0x31, 0x9f, 0x93, 0x13,
	0x3e, 0x87, 0x97, 0x92, 0x8a, 0x5d, 0x8a, 0x84, 0xce, 0x74, 0x04, 0x9d, 0x9b, 0x00, 0x31, 0x44,
	0x5a, 0x96, 0xef, 0xbc, 0xe0, 0x2a, 0x64, 0xcf, 0x2c, 0x88, 0xec, 0x13, 0x07, 0x5f, 0xb9, 0xc9,
	0xc1, 0x9f, 0x3c, 0x95, 0x3f, 0xba, 0xca, 0x1b, 0x43, 0x05, 0xc8, 0x6a, 0x07, 0x8d, 0x96, 0xa1,
	0x7d, 0xd2, 0xa9, 0x2c, 0x21, 0x80, 0x8c, 0xfa, 0x4e, 0xf0, 0xef, 0xc3, 0xc6, 0xf1, 0x51, 0xa7,
	0x5d, 0x49, 0x3e, 0xf9, 0x4d, 0x02, 0x60, 0x3c, 0x24, 0xa1, 0x32, 0xe4, 0x8f, 0xbd, 0x60, 0x40,
	0x2c, 0xe7, 0xc4, 0x21, 0x76, 0x65, 0x09, 0x15, 0xf9, 0x75, 0x8b, 0x17, 0x0e, 0xb1, 0x2b, 0x09,
	0xbe, 0x6c, 0x61, 0xcf, 0x22, 0xae, 0x4b, 0xec, 0x4a, 0x12, 0x95, 0x00, 0xc2, 0xc9, 0x96, 0xd8,
	0x95, 0x14, 0xdf, 0x53, 0x27, 0x3f, 0x26, 0x16, 0x17, 0x4e, 0xa3, 0x2c, 0xa4, 0x5f, 0x0c, 0x88,
	0x57, 0x59, 0xe6, 0x3b, 0xf2, 0xa4, 0x71, 0xec, 0x4a, 0x86, 0x9b, 0x68, 0x4b, 0xa0, 0x23, 0x76,
	0x65, 0x85, 0x9b, 0x08, 0x01, 0x8f, 0xd8, 0x95, 0x2c, 0x17, 0x6d, 0xb9, 0x34, 0x20, 0x76, 0x25,
	0xf7, 0xe4, 0x67, 0xb0, 0x36, 0xe7, 0x5d, 0x8c, 0xb6, 0xe1, 0x7e, 0xe3, 0xd8, 0x78, 0xfe, 0x42,
	0xd7, 0x3e, 0x6b, 0x18, 0xda, 0x8b, 0x03, 0xf3, 0xc8, 0x68, 0x18, 0xc7, 0x47, 0xe6, 0x61, 0xe7,
	0xa0, 0xad, 0x1d, 0x3c, 0xab, 0x2c, 0xa1, 0x47, 0xb0, 0x35, 0x57, 0x22, 0x24, 0x76, 0xda, 0x95,
	0x04, 0x7a, 0x08, 0x0f, 0xe6, 0x0a, 0xe9, 0x9d, 0x8f, 0x3a, 0x2d, 0x43, 0x44, 0xa7, 0x29, 0x86,
	0x23, 0x3e, 0x56, 0xf0, 0xc8, 0xec, 0x69, 0xdf, 0x3b, 0xd6, 0xda, 0x42, 0xb6, 0xb2, 0x84, 0xee,
	0xc0, 0x5a, 0xbb, 0xb3, 0xdb, 0x38, 0xde, 0x33, 0xcc, 0x38, 0x43, 0xc4, 0x48, 0xef, 0x1c, 0x36,
	0x3e, 0xdd, 0xef, 0x1c, 0x18, 0x95, 0xe4, 0x93, 0x5f, 0x24, 0xa0, 0x38, 0x51, 0x4b, 0xe8, 0x2e,
	0xdc, 0x6e, 0x77, 0x0e, 0x5f, 0x1c, 0x69, 0xc6, 0xac, 0xe7, 0xf7, 0xe0, 0xce, 0x14, 0xef, 0x93,
	0x8e, 0xae, 0xed, 0x6a, 0xc2, 0xe3, 0xfb, 0x50, 0x9d, 0x62, 0xea, 0x9d, 0x76, 0xa7, 0xb3, 0xcf,
	0x55, 0x93, 0x73, 0x54, 0x25, 0xb7, 0xd3, 0xae, 0xa4, 0x9e, 0xfc, 0x3a, 0x01, 0x45, 0x9e, 0x6d,
	0x8e, 0xd7, 0xd3, 0x3c, 0xc6, 0x6b, 0xf7, 0x3e, 0x54, 0x8f, 0xb4, 0x67, 0x07, 0xda, 0xc1, 0x33,
	0x53, 0x3b, 0x30, 0x3a, 0x07, 0x86, 0x39, 0xf6, 0x7a, 0x09, 0x6d, 0xc2, 0xdd, 0x29, 0xee, 0xe4,
	0x21, 0xdf, 0x84, 0xda, 0x14, 0x7f, 0x5e, 0x30, 0x92, 0xe8, 0x01, 0x6c, 0xcc, 0xec, 0xd2, 0xee,
	0xec, 0x1f, 0x0a, 0x76, 0xaa, 0xb9, 0xfb, 0xd5, 0xe5, 0x66, 0xe2, 0xeb, 0xcb, 0xcd, 0xc4, 0x3f,
	0x2f, 0x37, 0x13, 0x5f, 0xbe, 0xda, 0x5c, 0xfa, 0xfa, 0xd5, 0xe6, 0xd2, 0xdf, 0x5e, 0x6d, 0x2e,
	0x7d, 0xf6, 0x56, 0xcf, 0x61, 0xa7, 0xc3, 0x6e, 0xdd, 0xa2, 0xfd, 0x1d, 0x89, 0x4c, 0x2e, 0xee,
	0x06, 0xea, 0x73, 0x67, 0x14, 0xfd, 0xa7, 0x88, 0x8f, 0x81, 0x41, 0x37, 0x23, 0x4a, 0xe4, 0xdd,
	0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x0f, 0x0a, 0xbe, 0x48, 0x1a, 0x00, 0x00,
}

func (m *AssetMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsBasePriceAsset {
		i--
		if m.IsBasePriceAsset {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.PriceSymbol) > 0 {
		i -= len(m.PriceSymbol)
		copy(dAtA[i:], m.PriceSymbol)
		i = encodeVarintLending(dAtA, i, uint64(len(m.PriceSymbol)))
		i--
		dAtA[i] = 0x22
	}
	if m.Decimals != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolTrancheConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolTrancheConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolTrancheConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BorrowAPR != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.BorrowAPR))
		i--
		dAtA[i] = 0x10
	}
	if m.Maturity != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Maturity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PoolConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.LiquidationThreshold != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.LiquidationThreshold))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxLtv != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.MaxLtv))
		i--
		dAtA[i] = 0x58
	}
	if m.ReserveFactor != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.ReserveFactor))
		i--
		dAtA[i] = 0x50
	}
	if m.OriginationFeeFactor != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.OriginationFeeFactor))
		i--
		dAtA[i] = 0x48
	}
	{
		size, err := m.RequestFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Tranches) > 0 {
		for iNdEx := len(m.Tranches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tranches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLending(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size := m.MaxBorrowAmount.Size()
		i -= size
		if _, err := m.MaxBorrowAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MinBorrowAmount.Size()
		i -= size
		if _, err := m.MinBorrowAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.BorrowCap.Size()
		i -= size
		if _, err := m.BorrowCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SupplyCap.Size()
		i -= size
		if _, err := m.SupplyCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LendingAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.CollateralAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolTranche) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolTranche) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolTranche) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalReserve.Size()
		i -= size
		if _, err := m.TotalReserve.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalBorrowed.Size()
		i -= size
		if _, err := m.TotalBorrowed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.BorrowIndex.Size()
		i -= size
		if _, err := m.BorrowIndex.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Maturity != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Maturity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LendingPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LendingPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LendingPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.Tranches) > 0 {
		for iNdEx := len(m.Tranches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tranches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLending(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.TotalYTokens.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.TotalReserve.Size()
		i -= size
		if _, err := m.TotalReserve.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.ReserveAmount.Size()
		i -= size
		if _, err := m.ReserveAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.TotalBorrowed.Size()
		i -= size
		if _, err := m.TotalBorrowed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.BorrowedAmount.Size()
		i -= size
		if _, err := m.BorrowedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AvailableAmount.Size()
		i -= size
		if _, err := m.AvailableAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Supply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Authorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DepositTxs) > 0 {
		for iNdEx := len(m.DepositTxs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DepositTxs[iNdEx])
			copy(dAtA[i:], m.DepositTxs[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.DepositTxs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Loan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Loan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Loan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.DisburseAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DisburseAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintLending(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreateAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateAt):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintLending(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	if m.Referrer != nil {
		{
			size, err := m.Referrer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLending(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.LiquidationId != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.LiquidationId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	{
		size := m.CollateralAmount.Size()
		i -= size
		if _, err := m.CollateralAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	if len(m.Authorizations) > 0 {
		for iNdEx := len(m.Authorizations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Authorizations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLending(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.DlcEventId != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.DlcEventId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	{
		size := m.LiquidationPrice.Size()
		i -= size
		if _, err := m.LiquidationPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size := m.StartBorrowIndex.Size()
		i -= size
		if _, err := m.StartBorrowIndex.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if m.BorrowAPR != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.BorrowAPR))
		i--
		dAtA[i] = 0x78
	}
	if m.Maturity != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Maturity))
		i--
		dAtA[i] = 0x70
	}
	{
		size := m.ProtocolFee.Size()
		i -= size
		if _, err := m.ProtocolFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.Interest.Size()
		i -= size
		if _, err := m.Interest.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.OriginationFee.Size()
		i -= size
		if _, err := m.OriginationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.RequestFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.BorrowAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.PoolId) > 0 {
		i -= len(m.PoolId)
		copy(dAtA[i:], m.PoolId)
		i = encodeVarintLending(dAtA, i, uint64(len(m.PoolId)))
		i--
		dAtA[i] = 0x42
	}
	if m.FinalTimeout != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.FinalTimeout))
		i--
		dAtA[i] = 0x38
	}
	if m.MaturityTime != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.MaturityTime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DCM) > 0 {
		i -= len(m.DCM)
		copy(dAtA[i:], m.DCM)
		i = encodeVarintLending(dAtA, i, uint64(len(m.DCM)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BorrowerAuthPubKey) > 0 {
		i -= len(m.BorrowerAuthPubKey)
		copy(dAtA[i:], m.BorrowerAuthPubKey)
		i = encodeVarintLending(dAtA, i, uint64(len(m.BorrowerAuthPubKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BorrowerPubKey) > 0 {
		i -= len(m.BorrowerPubKey)
		copy(dAtA[i:], m.BorrowerPubKey)
		i = encodeVarintLending(dAtA, i, uint64(len(m.BorrowerPubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Borrower) > 0 {
		i -= len(m.Borrower)
		copy(dAtA[i:], m.Borrower)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Borrower)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintLending(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Referrer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Referrer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Referrer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ReferralFeeFactor.Size()
		i -= size
		if _, err := m.ReferralFeeFactor.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReferralCode) > 0 {
		i -= len(m.ReferralCode)
		copy(dAtA[i:], m.ReferralCode)
		i = encodeVarintLending(dAtA, i, uint64(len(m.ReferralCode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeafScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeafScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ControlBlock) > 0 {
		i -= len(m.ControlBlock)
		copy(dAtA[i:], m.ControlBlock)
		i = encodeVarintLending(dAtA, i, uint64(len(m.ControlBlock)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Script) > 0 {
		i -= len(m.Script)
		copy(dAtA[i:], m.Script)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Script)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SighashType != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.SighashType))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Script.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.SignaturePoint) > 0 {
		i -= len(m.SignaturePoint)
		copy(dAtA[i:], m.SignaturePoint)
		i = encodeVarintLending(dAtA, i, uint64(len(m.SignaturePoint)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OutcomeIndex != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.OutcomeIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.EventId != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LiquidationCet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidationCet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidationCet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SignedTxHex) > 0 {
		i -= len(m.SignedTxHex)
		copy(dAtA[i:], m.SignedTxHex)
		i = encodeVarintLending(dAtA, i, uint64(len(m.SignedTxHex)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DCMSignatures) > 0 {
		for iNdEx := len(m.DCMSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DCMSignatures[iNdEx])
			copy(dAtA[i:], m.DCMSignatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.DCMSignatures[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.BorrowerAdaptedSignatures) > 0 {
		for iNdEx := len(m.BorrowerAdaptedSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BorrowerAdaptedSignatures[iNdEx])
			copy(dAtA[i:], m.BorrowerAdaptedSignatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.BorrowerAdaptedSignatures[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BorrowerAdaptorSignatures) > 0 {
		for iNdEx := len(m.BorrowerAdaptorSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BorrowerAdaptorSignatures[iNdEx])
			copy(dAtA[i:], m.BorrowerAdaptorSignatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.BorrowerAdaptorSignatures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepaymentCet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepaymentCet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepaymentCet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SignedTxHex) > 0 {
		i -= len(m.SignedTxHex)
		copy(dAtA[i:], m.SignedTxHex)
		i = encodeVarintLending(dAtA, i, uint64(len(m.SignedTxHex)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BorrowerSignatures) > 0 {
		for iNdEx := len(m.BorrowerSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BorrowerSignatures[iNdEx])
			copy(dAtA[i:], m.BorrowerSignatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.BorrowerSignatures[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DCMAdaptedSignatures) > 0 {
		for iNdEx := len(m.DCMAdaptedSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DCMAdaptedSignatures[iNdEx])
			copy(dAtA[i:], m.DCMAdaptedSignatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.DCMAdaptedSignatures[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DCMAdaptorSignatures) > 0 {
		for iNdEx := len(m.DCMAdaptorSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DCMAdaptorSignatures[iNdEx])
			copy(dAtA[i:], m.DCMAdaptorSignatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.DCMAdaptorSignatures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DLCMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DLCMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DLCMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TimeoutRefundScript.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.RepaymentScript.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.LiquidationScript.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.InternalKey) > 0 {
		i -= len(m.InternalKey)
		copy(dAtA[i:], m.InternalKey)
		i = encodeVarintLending(dAtA, i, uint64(len(m.InternalKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.VaultUtxos) > 0 {
		for iNdEx := len(m.VaultUtxos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VaultUtxos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLending(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TimeoutRefundTx) > 0 {
		i -= len(m.TimeoutRefundTx)
		copy(dAtA[i:], m.TimeoutRefundTx)
		i = encodeVarintLending(dAtA, i, uint64(len(m.TimeoutRefundTx)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.RepaymentCet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.DefaultLiquidationCet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LiquidationCet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DepositLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DepositTx) > 0 {
		i -= len(m.DepositTx)
		copy(dAtA[i:], m.DepositTx)
		i = encodeVarintLending(dAtA, i, uint64(len(m.DepositTx)))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthorizationId != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.AuthorizationId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintLending(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Repayment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repayment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Repayment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n19, err19 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreateAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateAt):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintLending(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLending(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.LoanId) > 0 {
		i -= len(m.LoanId)
		copy(dAtA[i:], m.LoanId)
		i = encodeVarintLending(dAtA, i, uint64(len(m.LoanId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Redemption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Redemption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Redemption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n21, err21 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreateAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateAt):])
	if err21 != nil {
		return 0, err21
	}
	i -= n21
	i = encodeVarintLending(dAtA, i, uint64(n21))
	i--
	dAtA[i] = 0x3a
	if len(m.DCMSignatures) > 0 {
		for iNdEx := len(m.DCMSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DCMSignatures[iNdEx])
			copy(dAtA[i:], m.DCMSignatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.DCMSignatures[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signatures[iNdEx])
			copy(dAtA[i:], m.Signatures[iNdEx])
			i = encodeVarintLending(dAtA, i, uint64(len(m.Signatures[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintLending(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LoanId) > 0 {
		i -= len(m.LoanId)
		copy(dAtA[i:], m.LoanId)
		i = encodeVarintLending(dAtA, i, uint64(len(m.LoanId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintLending(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLending(dAtA []byte, offset int, v uint64) int {
	offset -= sovLending(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AssetMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovLending(uint64(m.Decimals))
	}
	l = len(m.PriceSymbol)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if m.IsBasePriceAsset {
		n += 2
	}
	return n
}

func (m *PoolTrancheConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Maturity != 0 {
		n += 1 + sovLending(uint64(m.Maturity))
	}
	if m.BorrowAPR != 0 {
		n += 1 + sovLending(uint64(m.BorrowAPR))
	}
	return n
}

func (m *PoolConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollateralAsset.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.LendingAsset.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.SupplyCap.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.BorrowCap.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.MinBorrowAmount.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.MaxBorrowAmount.Size()
	n += 1 + l + sovLending(uint64(l))
	if len(m.Tranches) > 0 {
		for _, e := range m.Tranches {
			l = e.Size()
			n += 1 + l + sovLending(uint64(l))
		}
	}
	l = m.RequestFee.Size()
	n += 1 + l + sovLending(uint64(l))
	if m.OriginationFeeFactor != 0 {
		n += 1 + sovLending(uint64(m.OriginationFeeFactor))
	}
	if m.ReserveFactor != 0 {
		n += 1 + sovLending(uint64(m.ReserveFactor))
	}
	if m.MaxLtv != 0 {
		n += 1 + sovLending(uint64(m.MaxLtv))
	}
	if m.LiquidationThreshold != 0 {
		n += 1 + sovLending(uint64(m.LiquidationThreshold))
	}
	if m.Paused {
		n += 2
	}
	return n
}

func (m *PoolTranche) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Maturity != 0 {
		n += 1 + sovLending(uint64(m.Maturity))
	}
	l = m.BorrowIndex.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.TotalBorrowed.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.TotalReserve.Size()
	n += 1 + l + sovLending(uint64(l))
	return n
}

func (m *LendingPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = m.Supply.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.AvailableAmount.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.BorrowedAmount.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.TotalBorrowed.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.ReserveAmount.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.TotalReserve.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.TotalYTokens.Size()
	n += 1 + l + sovLending(uint64(l))
	if len(m.Tranches) > 0 {
		for _, e := range m.Tranches {
			l = e.Size()
			n += 1 + l + sovLending(uint64(l))
		}
	}
	l = m.Config.Size()
	n += 1 + l + sovLending(uint64(l))
	if m.Status != 0 {
		n += 1 + sovLending(uint64(m.Status))
	}
	return n
}

func (m *Authorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLending(uint64(m.Id))
	}
	if len(m.DepositTxs) > 0 {
		for _, s := range m.DepositTxs {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovLending(uint64(m.Status))
	}
	return n
}

func (m *Loan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.Borrower)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.BorrowerPubKey)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.BorrowerAuthPubKey)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.DCM)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if m.MaturityTime != 0 {
		n += 1 + sovLending(uint64(m.MaturityTime))
	}
	if m.FinalTimeout != 0 {
		n += 1 + sovLending(uint64(m.FinalTimeout))
	}
	l = len(m.PoolId)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = m.BorrowAmount.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.RequestFee.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.OriginationFee.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.Interest.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.ProtocolFee.Size()
	n += 1 + l + sovLending(uint64(l))
	if m.Maturity != 0 {
		n += 1 + sovLending(uint64(m.Maturity))
	}
	if m.BorrowAPR != 0 {
		n += 1 + sovLending(uint64(m.BorrowAPR))
	}
	l = m.StartBorrowIndex.Size()
	n += 2 + l + sovLending(uint64(l))
	l = m.LiquidationPrice.Size()
	n += 2 + l + sovLending(uint64(l))
	if m.DlcEventId != 0 {
		n += 2 + sovLending(uint64(m.DlcEventId))
	}
	if len(m.Authorizations) > 0 {
		for _, e := range m.Authorizations {
			l = e.Size()
			n += 2 + l + sovLending(uint64(l))
		}
	}
	l = m.CollateralAmount.Size()
	n += 2 + l + sovLending(uint64(l))
	if m.LiquidationId != 0 {
		n += 2 + sovLending(uint64(m.LiquidationId))
	}
	if m.Referrer != nil {
		l = m.Referrer.Size()
		n += 2 + l + sovLending(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateAt)
	n += 2 + l + sovLending(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DisburseAt)
	n += 2 + l + sovLending(uint64(l))
	if m.Status != 0 {
		n += 2 + sovLending(uint64(m.Status))
	}
	return n
}

func (m *Referrer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.ReferralCode)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = m.ReferralFeeFactor.Size()
	n += 1 + l + sovLending(uint64(l))
	return n
}

func (m *LeafScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.ControlBlock)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	return n
}

func (m *CetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventId != 0 {
		n += 1 + sovLending(uint64(m.EventId))
	}
	if m.OutcomeIndex != 0 {
		n += 1 + sovLending(uint64(m.OutcomeIndex))
	}
	l = len(m.SignaturePoint)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = m.Script.Size()
	n += 1 + l + sovLending(uint64(l))
	if m.SighashType != 0 {
		n += 1 + sovLending(uint64(m.SighashType))
	}
	return n
}

func (m *LiquidationCet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if len(m.BorrowerAdaptorSignatures) > 0 {
		for _, s := range m.BorrowerAdaptorSignatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	if len(m.BorrowerAdaptedSignatures) > 0 {
		for _, s := range m.BorrowerAdaptedSignatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	if len(m.DCMSignatures) > 0 {
		for _, s := range m.DCMSignatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	l = len(m.SignedTxHex)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	return n
}

func (m *RepaymentCet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if len(m.DCMAdaptorSignatures) > 0 {
		for _, s := range m.DCMAdaptorSignatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	if len(m.DCMAdaptedSignatures) > 0 {
		for _, s := range m.DCMAdaptedSignatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	if len(m.BorrowerSignatures) > 0 {
		for _, s := range m.BorrowerSignatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	l = len(m.SignedTxHex)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	return n
}

func (m *DLCMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LiquidationCet.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.DefaultLiquidationCet.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.RepaymentCet.Size()
	n += 1 + l + sovLending(uint64(l))
	l = len(m.TimeoutRefundTx)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if len(m.VaultUtxos) > 0 {
		for _, e := range m.VaultUtxos {
			l = e.Size()
			n += 1 + l + sovLending(uint64(l))
		}
	}
	l = len(m.InternalKey)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = m.LiquidationScript.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.RepaymentScript.Size()
	n += 1 + l + sovLending(uint64(l))
	l = m.TimeoutRefundScript.Size()
	n += 1 + l + sovLending(uint64(l))
	return n
}

func (m *DepositLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if m.AuthorizationId != 0 {
		n += 1 + sovLending(uint64(m.AuthorizationId))
	}
	l = len(m.DepositTx)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovLending(uint64(m.Status))
	}
	return n
}

func (m *Repayment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LoanId)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovLending(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateAt)
	n += 1 + l + sovLending(uint64(l))
	return n
}

func (m *Redemption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLending(uint64(m.Id))
	}
	l = len(m.LoanId)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovLending(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, s := range m.Signatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	if len(m.DCMSignatures) > 0 {
		for _, s := range m.DCMSignatures {
			l = len(s)
			n += 1 + l + sovLending(uint64(l))
		}
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateAt)
	n += 1 + l + sovLending(uint64(l))
	return n
}

func sovLending(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLending(x uint64) (n int) {
	return sovLending(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AssetMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBasePriceAsset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBasePriceAsset = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolTrancheConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolTrancheConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolTrancheConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maturity", wireType)
			}
			m.Maturity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maturity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowAPR", wireType)
			}
			m.BorrowAPR = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BorrowAPR |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LendingAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LendingAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SupplyCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BorrowCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBorrowAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinBorrowAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBorrowAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxBorrowAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tranches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tranches = append(m.Tranches, PoolTrancheConfig{})
			if err := m.Tranches[len(m.Tranches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginationFeeFactor", wireType)
			}
			m.OriginationFeeFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginationFeeFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveFactor", wireType)
			}
			m.ReserveFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReserveFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLtv", wireType)
			}
			m.MaxLtv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLtv |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationThreshold", wireType)
			}
			m.LiquidationThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidationThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolTranche) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolTranche: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolTranche: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maturity", wireType)
			}
			m.Maturity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maturity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BorrowIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBorrowed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBorrowed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalReserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LendingPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LendingPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LendingPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Supply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailableAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BorrowedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBorrowed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBorrowed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReserveAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalReserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalYTokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tranches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tranches = append(m.Tranches, PoolTranche{})
			if err := m.Tranches[len(m.Tranches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PoolStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositTxs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositTxs = append(m.DepositTxs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AuthorizationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Loan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Loan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Loan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Borrower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Borrower = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowerPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowerPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowerAuthPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowerAuthPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DCM", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DCM = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaturityTime", wireType)
			}
			m.MaturityTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaturityTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalTimeout", wireType)
			}
			m.FinalTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BorrowAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OriginationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Interest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtocolFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maturity", wireType)
			}
			m.Maturity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maturity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowAPR", wireType)
			}
			m.BorrowAPR = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BorrowAPR |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBorrowIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartBorrowIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidationPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DlcEventId", wireType)
			}
			m.DlcEventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DlcEventId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authorizations = append(m.Authorizations, Authorization{})
			if err := m.Authorizations[len(m.Authorizations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationId", wireType)
			}
			m.LiquidationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referrer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Referrer == nil {
				m.Referrer = &Referrer{}
			}
			if err := m.Referrer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreateAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisburseAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.DisburseAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LoanStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Referrer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Referrer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Referrer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferralCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferralCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferralFeeFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReferralFeeFactor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlBlock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlBlock = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutcomeIndex", wireType)
			}
			m.OutcomeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutcomeIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignaturePoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignaturePoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Script.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SighashType", wireType)
			}
			m.SighashType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SighashType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidationCet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidationCet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidationCet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowerAdaptorSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowerAdaptorSignatures = append(m.BorrowerAdaptorSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowerAdaptedSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowerAdaptedSignatures = append(m.BorrowerAdaptedSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DCMSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DCMSignatures = append(m.DCMSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTxHex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedTxHex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepaymentCet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepaymentCet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepaymentCet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DCMAdaptorSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DCMAdaptorSignatures = append(m.DCMAdaptorSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DCMAdaptedSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DCMAdaptedSignatures = append(m.DCMAdaptedSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowerSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowerSignatures = append(m.BorrowerSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTxHex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedTxHex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DLCMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DLCMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DLCMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationCet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidationCet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultLiquidationCet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultLiquidationCet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepaymentCet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepaymentCet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutRefundTx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeoutRefundTx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultUtxos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultUtxos = append(m.VaultUtxos, &types1.UTXO{})
			if err := m.VaultUtxos[len(m.VaultUtxos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationScript", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidationScript.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepaymentScript", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepaymentScript.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutRefundScript", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeoutRefundScript.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationId", wireType)
			}
			m.AuthorizationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorizationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositTx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositTx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DepositStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repayment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repayment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repayment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreateAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Redemption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLending
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Redemption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Redemption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DCMSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DCMSignatures = append(m.DCMSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLending
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLending
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLending
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreateAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLending(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLending
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLending(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLending
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLending
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLending
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLending
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLending
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLending
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLending        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLending          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLending = fmt.Errorf("proto: unexpected end of group")
)
