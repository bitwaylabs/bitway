// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: bitway/farming/query.proto

package farming

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Query_Params_FullMethodName                 = "/bitway.farming.Query/Params"
	Query_Staking_FullMethodName                = "/bitway.farming.Query/Staking"
	Query_Stakings_FullMethodName               = "/bitway.farming.Query/Stakings"
	Query_StakingsByAddress_FullMethodName      = "/bitway.farming.Query/StakingsByAddress"
	Query_TotalStaking_FullMethodName           = "/bitway.farming.Query/TotalStaking"
	Query_CurrentEpoch_FullMethodName           = "/bitway.farming.Query/CurrentEpoch"
	Query_Rewards_FullMethodName                = "/bitway.farming.Query/Rewards"
	Query_PendingReward_FullMethodName          = "/bitway.farming.Query/PendingReward"
	Query_PendingRewardByAddress_FullMethodName = "/bitway.farming.Query/PendingRewardByAddress"
	Query_EstimatedReward_FullMethodName        = "/bitway.farming.Query/EstimatedReward"
)

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	// Params queries the parameters of the module.
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	Staking(ctx context.Context, in *QueryStakingRequest, opts ...grpc.CallOption) (*QueryStakingResponse, error)
	Stakings(ctx context.Context, in *QueryStakingsRequest, opts ...grpc.CallOption) (*QueryStakingsResponse, error)
	StakingsByAddress(ctx context.Context, in *QueryStakingsByAddressRequest, opts ...grpc.CallOption) (*QueryStakingsByAddressResponse, error)
	TotalStaking(ctx context.Context, in *QueryTotalStakingRequest, opts ...grpc.CallOption) (*QueryTotalStakingResponse, error)
	CurrentEpoch(ctx context.Context, in *QueryCurrentEpochRequest, opts ...grpc.CallOption) (*QueryCurrentEpochResponse, error)
	Rewards(ctx context.Context, in *QueryRewardsRequest, opts ...grpc.CallOption) (*QueryRewardsResponse, error)
	PendingReward(ctx context.Context, in *QueryPendingRewardRequest, opts ...grpc.CallOption) (*QueryPendingRewardResponse, error)
	PendingRewardByAddress(ctx context.Context, in *QueryPendingRewardByAddressRequest, opts ...grpc.CallOption) (*QueryPendingRewardByAddressResponse, error)
	EstimatedReward(ctx context.Context, in *QueryEstimatedRewardRequest, opts ...grpc.CallOption) (*QueryEstimatedRewardResponse, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, Query_Params_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Staking(ctx context.Context, in *QueryStakingRequest, opts ...grpc.CallOption) (*QueryStakingResponse, error) {
	out := new(QueryStakingResponse)
	err := c.cc.Invoke(ctx, Query_Staking_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Stakings(ctx context.Context, in *QueryStakingsRequest, opts ...grpc.CallOption) (*QueryStakingsResponse, error) {
	out := new(QueryStakingsResponse)
	err := c.cc.Invoke(ctx, Query_Stakings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) StakingsByAddress(ctx context.Context, in *QueryStakingsByAddressRequest, opts ...grpc.CallOption) (*QueryStakingsByAddressResponse, error) {
	out := new(QueryStakingsByAddressResponse)
	err := c.cc.Invoke(ctx, Query_StakingsByAddress_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TotalStaking(ctx context.Context, in *QueryTotalStakingRequest, opts ...grpc.CallOption) (*QueryTotalStakingResponse, error) {
	out := new(QueryTotalStakingResponse)
	err := c.cc.Invoke(ctx, Query_TotalStaking_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CurrentEpoch(ctx context.Context, in *QueryCurrentEpochRequest, opts ...grpc.CallOption) (*QueryCurrentEpochResponse, error) {
	out := new(QueryCurrentEpochResponse)
	err := c.cc.Invoke(ctx, Query_CurrentEpoch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Rewards(ctx context.Context, in *QueryRewardsRequest, opts ...grpc.CallOption) (*QueryRewardsResponse, error) {
	out := new(QueryRewardsResponse)
	err := c.cc.Invoke(ctx, Query_Rewards_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PendingReward(ctx context.Context, in *QueryPendingRewardRequest, opts ...grpc.CallOption) (*QueryPendingRewardResponse, error) {
	out := new(QueryPendingRewardResponse)
	err := c.cc.Invoke(ctx, Query_PendingReward_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PendingRewardByAddress(ctx context.Context, in *QueryPendingRewardByAddressRequest, opts ...grpc.CallOption) (*QueryPendingRewardByAddressResponse, error) {
	out := new(QueryPendingRewardByAddressResponse)
	err := c.cc.Invoke(ctx, Query_PendingRewardByAddress_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EstimatedReward(ctx context.Context, in *QueryEstimatedRewardRequest, opts ...grpc.CallOption) (*QueryEstimatedRewardResponse, error) {
	out := new(QueryEstimatedRewardResponse)
	err := c.cc.Invoke(ctx, Query_EstimatedReward_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility
type QueryServer interface {
	// Params queries the parameters of the module.
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	Staking(context.Context, *QueryStakingRequest) (*QueryStakingResponse, error)
	Stakings(context.Context, *QueryStakingsRequest) (*QueryStakingsResponse, error)
	StakingsByAddress(context.Context, *QueryStakingsByAddressRequest) (*QueryStakingsByAddressResponse, error)
	TotalStaking(context.Context, *QueryTotalStakingRequest) (*QueryTotalStakingResponse, error)
	CurrentEpoch(context.Context, *QueryCurrentEpochRequest) (*QueryCurrentEpochResponse, error)
	Rewards(context.Context, *QueryRewardsRequest) (*QueryRewardsResponse, error)
	PendingReward(context.Context, *QueryPendingRewardRequest) (*QueryPendingRewardResponse, error)
	PendingRewardByAddress(context.Context, *QueryPendingRewardByAddressRequest) (*QueryPendingRewardByAddressResponse, error)
	EstimatedReward(context.Context, *QueryEstimatedRewardRequest) (*QueryEstimatedRewardResponse, error)
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (UnimplementedQueryServer) Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (UnimplementedQueryServer) Staking(context.Context, *QueryStakingRequest) (*QueryStakingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Staking not implemented")
}
func (UnimplementedQueryServer) Stakings(context.Context, *QueryStakingsRequest) (*QueryStakingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stakings not implemented")
}
func (UnimplementedQueryServer) StakingsByAddress(context.Context, *QueryStakingsByAddressRequest) (*QueryStakingsByAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StakingsByAddress not implemented")
}
func (UnimplementedQueryServer) TotalStaking(context.Context, *QueryTotalStakingRequest) (*QueryTotalStakingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TotalStaking not implemented")
}
func (UnimplementedQueryServer) CurrentEpoch(context.Context, *QueryCurrentEpochRequest) (*QueryCurrentEpochResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentEpoch not implemented")
}
func (UnimplementedQueryServer) Rewards(context.Context, *QueryRewardsRequest) (*QueryRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rewards not implemented")
}
func (UnimplementedQueryServer) PendingReward(context.Context, *QueryPendingRewardRequest) (*QueryPendingRewardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PendingReward not implemented")
}
func (UnimplementedQueryServer) PendingRewardByAddress(context.Context, *QueryPendingRewardByAddressRequest) (*QueryPendingRewardByAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PendingRewardByAddress not implemented")
}
func (UnimplementedQueryServer) EstimatedReward(context.Context, *QueryEstimatedRewardRequest) (*QueryEstimatedRewardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimatedReward not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Params_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Staking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStakingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Staking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Staking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Staking(ctx, req.(*QueryStakingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Stakings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStakingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Stakings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Stakings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Stakings(ctx, req.(*QueryStakingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_StakingsByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStakingsByAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).StakingsByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_StakingsByAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).StakingsByAddress(ctx, req.(*QueryStakingsByAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TotalStaking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTotalStakingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TotalStaking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_TotalStaking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TotalStaking(ctx, req.(*QueryTotalStakingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CurrentEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCurrentEpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CurrentEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_CurrentEpoch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CurrentEpoch(ctx, req.(*QueryCurrentEpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Rewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRewardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Rewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Rewards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Rewards(ctx, req.(*QueryRewardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PendingReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPendingRewardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PendingReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_PendingReward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PendingReward(ctx, req.(*QueryPendingRewardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PendingRewardByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPendingRewardByAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PendingRewardByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_PendingRewardByAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PendingRewardByAddress(ctx, req.(*QueryPendingRewardByAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EstimatedReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEstimatedRewardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EstimatedReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_EstimatedReward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EstimatedReward(ctx, req.(*QueryEstimatedRewardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bitway.farming.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "Staking",
			Handler:    _Query_Staking_Handler,
		},
		{
			MethodName: "Stakings",
			Handler:    _Query_Stakings_Handler,
		},
		{
			MethodName: "StakingsByAddress",
			Handler:    _Query_StakingsByAddress_Handler,
		},
		{
			MethodName: "TotalStaking",
			Handler:    _Query_TotalStaking_Handler,
		},
		{
			MethodName: "CurrentEpoch",
			Handler:    _Query_CurrentEpoch_Handler,
		},
		{
			MethodName: "Rewards",
			Handler:    _Query_Rewards_Handler,
		},
		{
			MethodName: "PendingReward",
			Handler:    _Query_PendingReward_Handler,
		},
		{
			MethodName: "PendingRewardByAddress",
			Handler:    _Query_PendingRewardByAddress_Handler,
		},
		{
			MethodName: "EstimatedReward",
			Handler:    _Query_EstimatedReward_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bitway/farming/query.proto",
}
