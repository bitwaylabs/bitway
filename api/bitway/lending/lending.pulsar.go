// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package lending

import (
	v1beta1 "cosmossdk.io/api/cosmos/base/v1beta1"
	fmt "fmt"
	btcbridge "github.com/bitwaylabs/bitway/api/bitway/btcbridge"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_AssetMetadata                     protoreflect.MessageDescriptor
	fd_AssetMetadata_denom               protoreflect.FieldDescriptor
	fd_AssetMetadata_symbol              protoreflect.FieldDescriptor
	fd_AssetMetadata_decimals            protoreflect.FieldDescriptor
	fd_AssetMetadata_price_symbol        protoreflect.FieldDescriptor
	fd_AssetMetadata_is_base_price_asset protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_AssetMetadata = File_bitway_lending_lending_proto.Messages().ByName("AssetMetadata")
	fd_AssetMetadata_denom = md_AssetMetadata.Fields().ByName("denom")
	fd_AssetMetadata_symbol = md_AssetMetadata.Fields().ByName("symbol")
	fd_AssetMetadata_decimals = md_AssetMetadata.Fields().ByName("decimals")
	fd_AssetMetadata_price_symbol = md_AssetMetadata.Fields().ByName("price_symbol")
	fd_AssetMetadata_is_base_price_asset = md_AssetMetadata.Fields().ByName("is_base_price_asset")
}

var _ protoreflect.Message = (*fastReflection_AssetMetadata)(nil)

type fastReflection_AssetMetadata AssetMetadata

func (x *AssetMetadata) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AssetMetadata)(x)
}

func (x *AssetMetadata) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AssetMetadata_messageType fastReflection_AssetMetadata_messageType
var _ protoreflect.MessageType = fastReflection_AssetMetadata_messageType{}

type fastReflection_AssetMetadata_messageType struct{}

func (x fastReflection_AssetMetadata_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AssetMetadata)(nil)
}
func (x fastReflection_AssetMetadata_messageType) New() protoreflect.Message {
	return new(fastReflection_AssetMetadata)
}
func (x fastReflection_AssetMetadata_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AssetMetadata
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AssetMetadata) Descriptor() protoreflect.MessageDescriptor {
	return md_AssetMetadata
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AssetMetadata) Type() protoreflect.MessageType {
	return _fastReflection_AssetMetadata_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AssetMetadata) New() protoreflect.Message {
	return new(fastReflection_AssetMetadata)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AssetMetadata) Interface() protoreflect.ProtoMessage {
	return (*AssetMetadata)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AssetMetadata) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Denom != "" {
		value := protoreflect.ValueOfString(x.Denom)
		if !f(fd_AssetMetadata_denom, value) {
			return
		}
	}
	if x.Symbol != "" {
		value := protoreflect.ValueOfString(x.Symbol)
		if !f(fd_AssetMetadata_symbol, value) {
			return
		}
	}
	if x.Decimals != int32(0) {
		value := protoreflect.ValueOfInt32(x.Decimals)
		if !f(fd_AssetMetadata_decimals, value) {
			return
		}
	}
	if x.PriceSymbol != "" {
		value := protoreflect.ValueOfString(x.PriceSymbol)
		if !f(fd_AssetMetadata_price_symbol, value) {
			return
		}
	}
	if x.IsBasePriceAsset != false {
		value := protoreflect.ValueOfBool(x.IsBasePriceAsset)
		if !f(fd_AssetMetadata_is_base_price_asset, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AssetMetadata) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.AssetMetadata.denom":
		return x.Denom != ""
	case "bitway.lending.AssetMetadata.symbol":
		return x.Symbol != ""
	case "bitway.lending.AssetMetadata.decimals":
		return x.Decimals != int32(0)
	case "bitway.lending.AssetMetadata.price_symbol":
		return x.PriceSymbol != ""
	case "bitway.lending.AssetMetadata.is_base_price_asset":
		return x.IsBasePriceAsset != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.AssetMetadata"))
		}
		panic(fmt.Errorf("message bitway.lending.AssetMetadata does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssetMetadata) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.AssetMetadata.denom":
		x.Denom = ""
	case "bitway.lending.AssetMetadata.symbol":
		x.Symbol = ""
	case "bitway.lending.AssetMetadata.decimals":
		x.Decimals = int32(0)
	case "bitway.lending.AssetMetadata.price_symbol":
		x.PriceSymbol = ""
	case "bitway.lending.AssetMetadata.is_base_price_asset":
		x.IsBasePriceAsset = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.AssetMetadata"))
		}
		panic(fmt.Errorf("message bitway.lending.AssetMetadata does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AssetMetadata) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.AssetMetadata.denom":
		value := x.Denom
		return protoreflect.ValueOfString(value)
	case "bitway.lending.AssetMetadata.symbol":
		value := x.Symbol
		return protoreflect.ValueOfString(value)
	case "bitway.lending.AssetMetadata.decimals":
		value := x.Decimals
		return protoreflect.ValueOfInt32(value)
	case "bitway.lending.AssetMetadata.price_symbol":
		value := x.PriceSymbol
		return protoreflect.ValueOfString(value)
	case "bitway.lending.AssetMetadata.is_base_price_asset":
		value := x.IsBasePriceAsset
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.AssetMetadata"))
		}
		panic(fmt.Errorf("message bitway.lending.AssetMetadata does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssetMetadata) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.AssetMetadata.denom":
		x.Denom = value.Interface().(string)
	case "bitway.lending.AssetMetadata.symbol":
		x.Symbol = value.Interface().(string)
	case "bitway.lending.AssetMetadata.decimals":
		x.Decimals = int32(value.Int())
	case "bitway.lending.AssetMetadata.price_symbol":
		x.PriceSymbol = value.Interface().(string)
	case "bitway.lending.AssetMetadata.is_base_price_asset":
		x.IsBasePriceAsset = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.AssetMetadata"))
		}
		panic(fmt.Errorf("message bitway.lending.AssetMetadata does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssetMetadata) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.AssetMetadata.denom":
		panic(fmt.Errorf("field denom of message bitway.lending.AssetMetadata is not mutable"))
	case "bitway.lending.AssetMetadata.symbol":
		panic(fmt.Errorf("field symbol of message bitway.lending.AssetMetadata is not mutable"))
	case "bitway.lending.AssetMetadata.decimals":
		panic(fmt.Errorf("field decimals of message bitway.lending.AssetMetadata is not mutable"))
	case "bitway.lending.AssetMetadata.price_symbol":
		panic(fmt.Errorf("field price_symbol of message bitway.lending.AssetMetadata is not mutable"))
	case "bitway.lending.AssetMetadata.is_base_price_asset":
		panic(fmt.Errorf("field is_base_price_asset of message bitway.lending.AssetMetadata is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.AssetMetadata"))
		}
		panic(fmt.Errorf("message bitway.lending.AssetMetadata does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AssetMetadata) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.AssetMetadata.denom":
		return protoreflect.ValueOfString("")
	case "bitway.lending.AssetMetadata.symbol":
		return protoreflect.ValueOfString("")
	case "bitway.lending.AssetMetadata.decimals":
		return protoreflect.ValueOfInt32(int32(0))
	case "bitway.lending.AssetMetadata.price_symbol":
		return protoreflect.ValueOfString("")
	case "bitway.lending.AssetMetadata.is_base_price_asset":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.AssetMetadata"))
		}
		panic(fmt.Errorf("message bitway.lending.AssetMetadata does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AssetMetadata) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.AssetMetadata", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AssetMetadata) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AssetMetadata) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AssetMetadata) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AssetMetadata) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AssetMetadata)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Denom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Symbol)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Decimals != 0 {
			n += 1 + runtime.Sov(uint64(x.Decimals))
		}
		l = len(x.PriceSymbol)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.IsBasePriceAsset {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AssetMetadata)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.IsBasePriceAsset {
			i--
			if x.IsBasePriceAsset {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if len(x.PriceSymbol) > 0 {
			i -= len(x.PriceSymbol)
			copy(dAtA[i:], x.PriceSymbol)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PriceSymbol)))
			i--
			dAtA[i] = 0x22
		}
		if x.Decimals != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Decimals))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Symbol) > 0 {
			i -= len(x.Symbol)
			copy(dAtA[i:], x.Symbol)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Symbol)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Denom) > 0 {
			i -= len(x.Denom)
			copy(dAtA[i:], x.Denom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Denom)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AssetMetadata)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AssetMetadata: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AssetMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Denom = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Symbol = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
				}
				x.Decimals = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Decimals |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PriceSymbol", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PriceSymbol = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IsBasePriceAsset", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.IsBasePriceAsset = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PoolTrancheConfig            protoreflect.MessageDescriptor
	fd_PoolTrancheConfig_maturity   protoreflect.FieldDescriptor
	fd_PoolTrancheConfig_borrow_apr protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_PoolTrancheConfig = File_bitway_lending_lending_proto.Messages().ByName("PoolTrancheConfig")
	fd_PoolTrancheConfig_maturity = md_PoolTrancheConfig.Fields().ByName("maturity")
	fd_PoolTrancheConfig_borrow_apr = md_PoolTrancheConfig.Fields().ByName("borrow_apr")
}

var _ protoreflect.Message = (*fastReflection_PoolTrancheConfig)(nil)

type fastReflection_PoolTrancheConfig PoolTrancheConfig

func (x *PoolTrancheConfig) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PoolTrancheConfig)(x)
}

func (x *PoolTrancheConfig) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PoolTrancheConfig_messageType fastReflection_PoolTrancheConfig_messageType
var _ protoreflect.MessageType = fastReflection_PoolTrancheConfig_messageType{}

type fastReflection_PoolTrancheConfig_messageType struct{}

func (x fastReflection_PoolTrancheConfig_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PoolTrancheConfig)(nil)
}
func (x fastReflection_PoolTrancheConfig_messageType) New() protoreflect.Message {
	return new(fastReflection_PoolTrancheConfig)
}
func (x fastReflection_PoolTrancheConfig_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolTrancheConfig
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PoolTrancheConfig) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolTrancheConfig
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PoolTrancheConfig) Type() protoreflect.MessageType {
	return _fastReflection_PoolTrancheConfig_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PoolTrancheConfig) New() protoreflect.Message {
	return new(fastReflection_PoolTrancheConfig)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PoolTrancheConfig) Interface() protoreflect.ProtoMessage {
	return (*PoolTrancheConfig)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PoolTrancheConfig) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Maturity != int64(0) {
		value := protoreflect.ValueOfInt64(x.Maturity)
		if !f(fd_PoolTrancheConfig_maturity, value) {
			return
		}
	}
	if x.BorrowApr != uint32(0) {
		value := protoreflect.ValueOfUint32(x.BorrowApr)
		if !f(fd_PoolTrancheConfig_borrow_apr, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PoolTrancheConfig) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.PoolTrancheConfig.maturity":
		return x.Maturity != int64(0)
	case "bitway.lending.PoolTrancheConfig.borrow_apr":
		return x.BorrowApr != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTrancheConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTrancheConfig does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTrancheConfig) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.PoolTrancheConfig.maturity":
		x.Maturity = int64(0)
	case "bitway.lending.PoolTrancheConfig.borrow_apr":
		x.BorrowApr = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTrancheConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTrancheConfig does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PoolTrancheConfig) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.PoolTrancheConfig.maturity":
		value := x.Maturity
		return protoreflect.ValueOfInt64(value)
	case "bitway.lending.PoolTrancheConfig.borrow_apr":
		value := x.BorrowApr
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTrancheConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTrancheConfig does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTrancheConfig) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.PoolTrancheConfig.maturity":
		x.Maturity = value.Int()
	case "bitway.lending.PoolTrancheConfig.borrow_apr":
		x.BorrowApr = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTrancheConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTrancheConfig does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTrancheConfig) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.PoolTrancheConfig.maturity":
		panic(fmt.Errorf("field maturity of message bitway.lending.PoolTrancheConfig is not mutable"))
	case "bitway.lending.PoolTrancheConfig.borrow_apr":
		panic(fmt.Errorf("field borrow_apr of message bitway.lending.PoolTrancheConfig is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTrancheConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTrancheConfig does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PoolTrancheConfig) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.PoolTrancheConfig.maturity":
		return protoreflect.ValueOfInt64(int64(0))
	case "bitway.lending.PoolTrancheConfig.borrow_apr":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTrancheConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTrancheConfig does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PoolTrancheConfig) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.PoolTrancheConfig", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PoolTrancheConfig) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTrancheConfig) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PoolTrancheConfig) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PoolTrancheConfig) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PoolTrancheConfig)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Maturity != 0 {
			n += 1 + runtime.Sov(uint64(x.Maturity))
		}
		if x.BorrowApr != 0 {
			n += 1 + runtime.Sov(uint64(x.BorrowApr))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PoolTrancheConfig)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.BorrowApr != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BorrowApr))
			i--
			dAtA[i] = 0x10
		}
		if x.Maturity != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Maturity))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PoolTrancheConfig)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolTrancheConfig: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolTrancheConfig: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Maturity", wireType)
				}
				x.Maturity = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Maturity |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowApr", wireType)
				}
				x.BorrowApr = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BorrowApr |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_PoolConfig_7_list)(nil)

type _PoolConfig_7_list struct {
	list *[]*PoolTrancheConfig
}

func (x *_PoolConfig_7_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_PoolConfig_7_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_PoolConfig_7_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolTrancheConfig)
	(*x.list)[i] = concreteValue
}

func (x *_PoolConfig_7_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolTrancheConfig)
	*x.list = append(*x.list, concreteValue)
}

func (x *_PoolConfig_7_list) AppendMutable() protoreflect.Value {
	v := new(PoolTrancheConfig)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PoolConfig_7_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_PoolConfig_7_list) NewElement() protoreflect.Value {
	v := new(PoolTrancheConfig)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PoolConfig_7_list) IsValid() bool {
	return x.list != nil
}

var (
	md_PoolConfig                        protoreflect.MessageDescriptor
	fd_PoolConfig_collateral_asset       protoreflect.FieldDescriptor
	fd_PoolConfig_lending_asset          protoreflect.FieldDescriptor
	fd_PoolConfig_supply_cap             protoreflect.FieldDescriptor
	fd_PoolConfig_borrow_cap             protoreflect.FieldDescriptor
	fd_PoolConfig_min_borrow_amount      protoreflect.FieldDescriptor
	fd_PoolConfig_max_borrow_amount      protoreflect.FieldDescriptor
	fd_PoolConfig_tranches               protoreflect.FieldDescriptor
	fd_PoolConfig_request_fee            protoreflect.FieldDescriptor
	fd_PoolConfig_origination_fee_factor protoreflect.FieldDescriptor
	fd_PoolConfig_reserve_factor         protoreflect.FieldDescriptor
	fd_PoolConfig_max_ltv                protoreflect.FieldDescriptor
	fd_PoolConfig_liquidation_threshold  protoreflect.FieldDescriptor
	fd_PoolConfig_paused                 protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_PoolConfig = File_bitway_lending_lending_proto.Messages().ByName("PoolConfig")
	fd_PoolConfig_collateral_asset = md_PoolConfig.Fields().ByName("collateral_asset")
	fd_PoolConfig_lending_asset = md_PoolConfig.Fields().ByName("lending_asset")
	fd_PoolConfig_supply_cap = md_PoolConfig.Fields().ByName("supply_cap")
	fd_PoolConfig_borrow_cap = md_PoolConfig.Fields().ByName("borrow_cap")
	fd_PoolConfig_min_borrow_amount = md_PoolConfig.Fields().ByName("min_borrow_amount")
	fd_PoolConfig_max_borrow_amount = md_PoolConfig.Fields().ByName("max_borrow_amount")
	fd_PoolConfig_tranches = md_PoolConfig.Fields().ByName("tranches")
	fd_PoolConfig_request_fee = md_PoolConfig.Fields().ByName("request_fee")
	fd_PoolConfig_origination_fee_factor = md_PoolConfig.Fields().ByName("origination_fee_factor")
	fd_PoolConfig_reserve_factor = md_PoolConfig.Fields().ByName("reserve_factor")
	fd_PoolConfig_max_ltv = md_PoolConfig.Fields().ByName("max_ltv")
	fd_PoolConfig_liquidation_threshold = md_PoolConfig.Fields().ByName("liquidation_threshold")
	fd_PoolConfig_paused = md_PoolConfig.Fields().ByName("paused")
}

var _ protoreflect.Message = (*fastReflection_PoolConfig)(nil)

type fastReflection_PoolConfig PoolConfig

func (x *PoolConfig) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PoolConfig)(x)
}

func (x *PoolConfig) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PoolConfig_messageType fastReflection_PoolConfig_messageType
var _ protoreflect.MessageType = fastReflection_PoolConfig_messageType{}

type fastReflection_PoolConfig_messageType struct{}

func (x fastReflection_PoolConfig_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PoolConfig)(nil)
}
func (x fastReflection_PoolConfig_messageType) New() protoreflect.Message {
	return new(fastReflection_PoolConfig)
}
func (x fastReflection_PoolConfig_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolConfig
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PoolConfig) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolConfig
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PoolConfig) Type() protoreflect.MessageType {
	return _fastReflection_PoolConfig_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PoolConfig) New() protoreflect.Message {
	return new(fastReflection_PoolConfig)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PoolConfig) Interface() protoreflect.ProtoMessage {
	return (*PoolConfig)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PoolConfig) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.CollateralAsset != nil {
		value := protoreflect.ValueOfMessage(x.CollateralAsset.ProtoReflect())
		if !f(fd_PoolConfig_collateral_asset, value) {
			return
		}
	}
	if x.LendingAsset != nil {
		value := protoreflect.ValueOfMessage(x.LendingAsset.ProtoReflect())
		if !f(fd_PoolConfig_lending_asset, value) {
			return
		}
	}
	if x.SupplyCap != "" {
		value := protoreflect.ValueOfString(x.SupplyCap)
		if !f(fd_PoolConfig_supply_cap, value) {
			return
		}
	}
	if x.BorrowCap != "" {
		value := protoreflect.ValueOfString(x.BorrowCap)
		if !f(fd_PoolConfig_borrow_cap, value) {
			return
		}
	}
	if x.MinBorrowAmount != "" {
		value := protoreflect.ValueOfString(x.MinBorrowAmount)
		if !f(fd_PoolConfig_min_borrow_amount, value) {
			return
		}
	}
	if x.MaxBorrowAmount != "" {
		value := protoreflect.ValueOfString(x.MaxBorrowAmount)
		if !f(fd_PoolConfig_max_borrow_amount, value) {
			return
		}
	}
	if len(x.Tranches) != 0 {
		value := protoreflect.ValueOfList(&_PoolConfig_7_list{list: &x.Tranches})
		if !f(fd_PoolConfig_tranches, value) {
			return
		}
	}
	if x.RequestFee != nil {
		value := protoreflect.ValueOfMessage(x.RequestFee.ProtoReflect())
		if !f(fd_PoolConfig_request_fee, value) {
			return
		}
	}
	if x.OriginationFeeFactor != uint32(0) {
		value := protoreflect.ValueOfUint32(x.OriginationFeeFactor)
		if !f(fd_PoolConfig_origination_fee_factor, value) {
			return
		}
	}
	if x.ReserveFactor != uint32(0) {
		value := protoreflect.ValueOfUint32(x.ReserveFactor)
		if !f(fd_PoolConfig_reserve_factor, value) {
			return
		}
	}
	if x.MaxLtv != uint32(0) {
		value := protoreflect.ValueOfUint32(x.MaxLtv)
		if !f(fd_PoolConfig_max_ltv, value) {
			return
		}
	}
	if x.LiquidationThreshold != uint32(0) {
		value := protoreflect.ValueOfUint32(x.LiquidationThreshold)
		if !f(fd_PoolConfig_liquidation_threshold, value) {
			return
		}
	}
	if x.Paused != false {
		value := protoreflect.ValueOfBool(x.Paused)
		if !f(fd_PoolConfig_paused, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PoolConfig) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.PoolConfig.collateral_asset":
		return x.CollateralAsset != nil
	case "bitway.lending.PoolConfig.lending_asset":
		return x.LendingAsset != nil
	case "bitway.lending.PoolConfig.supply_cap":
		return x.SupplyCap != ""
	case "bitway.lending.PoolConfig.borrow_cap":
		return x.BorrowCap != ""
	case "bitway.lending.PoolConfig.min_borrow_amount":
		return x.MinBorrowAmount != ""
	case "bitway.lending.PoolConfig.max_borrow_amount":
		return x.MaxBorrowAmount != ""
	case "bitway.lending.PoolConfig.tranches":
		return len(x.Tranches) != 0
	case "bitway.lending.PoolConfig.request_fee":
		return x.RequestFee != nil
	case "bitway.lending.PoolConfig.origination_fee_factor":
		return x.OriginationFeeFactor != uint32(0)
	case "bitway.lending.PoolConfig.reserve_factor":
		return x.ReserveFactor != uint32(0)
	case "bitway.lending.PoolConfig.max_ltv":
		return x.MaxLtv != uint32(0)
	case "bitway.lending.PoolConfig.liquidation_threshold":
		return x.LiquidationThreshold != uint32(0)
	case "bitway.lending.PoolConfig.paused":
		return x.Paused != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolConfig does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolConfig) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.PoolConfig.collateral_asset":
		x.CollateralAsset = nil
	case "bitway.lending.PoolConfig.lending_asset":
		x.LendingAsset = nil
	case "bitway.lending.PoolConfig.supply_cap":
		x.SupplyCap = ""
	case "bitway.lending.PoolConfig.borrow_cap":
		x.BorrowCap = ""
	case "bitway.lending.PoolConfig.min_borrow_amount":
		x.MinBorrowAmount = ""
	case "bitway.lending.PoolConfig.max_borrow_amount":
		x.MaxBorrowAmount = ""
	case "bitway.lending.PoolConfig.tranches":
		x.Tranches = nil
	case "bitway.lending.PoolConfig.request_fee":
		x.RequestFee = nil
	case "bitway.lending.PoolConfig.origination_fee_factor":
		x.OriginationFeeFactor = uint32(0)
	case "bitway.lending.PoolConfig.reserve_factor":
		x.ReserveFactor = uint32(0)
	case "bitway.lending.PoolConfig.max_ltv":
		x.MaxLtv = uint32(0)
	case "bitway.lending.PoolConfig.liquidation_threshold":
		x.LiquidationThreshold = uint32(0)
	case "bitway.lending.PoolConfig.paused":
		x.Paused = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolConfig does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PoolConfig) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.PoolConfig.collateral_asset":
		value := x.CollateralAsset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.PoolConfig.lending_asset":
		value := x.LendingAsset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.PoolConfig.supply_cap":
		value := x.SupplyCap
		return protoreflect.ValueOfString(value)
	case "bitway.lending.PoolConfig.borrow_cap":
		value := x.BorrowCap
		return protoreflect.ValueOfString(value)
	case "bitway.lending.PoolConfig.min_borrow_amount":
		value := x.MinBorrowAmount
		return protoreflect.ValueOfString(value)
	case "bitway.lending.PoolConfig.max_borrow_amount":
		value := x.MaxBorrowAmount
		return protoreflect.ValueOfString(value)
	case "bitway.lending.PoolConfig.tranches":
		if len(x.Tranches) == 0 {
			return protoreflect.ValueOfList(&_PoolConfig_7_list{})
		}
		listValue := &_PoolConfig_7_list{list: &x.Tranches}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.PoolConfig.request_fee":
		value := x.RequestFee
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.PoolConfig.origination_fee_factor":
		value := x.OriginationFeeFactor
		return protoreflect.ValueOfUint32(value)
	case "bitway.lending.PoolConfig.reserve_factor":
		value := x.ReserveFactor
		return protoreflect.ValueOfUint32(value)
	case "bitway.lending.PoolConfig.max_ltv":
		value := x.MaxLtv
		return protoreflect.ValueOfUint32(value)
	case "bitway.lending.PoolConfig.liquidation_threshold":
		value := x.LiquidationThreshold
		return protoreflect.ValueOfUint32(value)
	case "bitway.lending.PoolConfig.paused":
		value := x.Paused
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolConfig does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolConfig) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.PoolConfig.collateral_asset":
		x.CollateralAsset = value.Message().Interface().(*AssetMetadata)
	case "bitway.lending.PoolConfig.lending_asset":
		x.LendingAsset = value.Message().Interface().(*AssetMetadata)
	case "bitway.lending.PoolConfig.supply_cap":
		x.SupplyCap = value.Interface().(string)
	case "bitway.lending.PoolConfig.borrow_cap":
		x.BorrowCap = value.Interface().(string)
	case "bitway.lending.PoolConfig.min_borrow_amount":
		x.MinBorrowAmount = value.Interface().(string)
	case "bitway.lending.PoolConfig.max_borrow_amount":
		x.MaxBorrowAmount = value.Interface().(string)
	case "bitway.lending.PoolConfig.tranches":
		lv := value.List()
		clv := lv.(*_PoolConfig_7_list)
		x.Tranches = *clv.list
	case "bitway.lending.PoolConfig.request_fee":
		x.RequestFee = value.Message().Interface().(*v1beta1.Coin)
	case "bitway.lending.PoolConfig.origination_fee_factor":
		x.OriginationFeeFactor = uint32(value.Uint())
	case "bitway.lending.PoolConfig.reserve_factor":
		x.ReserveFactor = uint32(value.Uint())
	case "bitway.lending.PoolConfig.max_ltv":
		x.MaxLtv = uint32(value.Uint())
	case "bitway.lending.PoolConfig.liquidation_threshold":
		x.LiquidationThreshold = uint32(value.Uint())
	case "bitway.lending.PoolConfig.paused":
		x.Paused = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolConfig does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolConfig) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.PoolConfig.collateral_asset":
		if x.CollateralAsset == nil {
			x.CollateralAsset = new(AssetMetadata)
		}
		return protoreflect.ValueOfMessage(x.CollateralAsset.ProtoReflect())
	case "bitway.lending.PoolConfig.lending_asset":
		if x.LendingAsset == nil {
			x.LendingAsset = new(AssetMetadata)
		}
		return protoreflect.ValueOfMessage(x.LendingAsset.ProtoReflect())
	case "bitway.lending.PoolConfig.tranches":
		if x.Tranches == nil {
			x.Tranches = []*PoolTrancheConfig{}
		}
		value := &_PoolConfig_7_list{list: &x.Tranches}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.PoolConfig.request_fee":
		if x.RequestFee == nil {
			x.RequestFee = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.RequestFee.ProtoReflect())
	case "bitway.lending.PoolConfig.supply_cap":
		panic(fmt.Errorf("field supply_cap of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.borrow_cap":
		panic(fmt.Errorf("field borrow_cap of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.min_borrow_amount":
		panic(fmt.Errorf("field min_borrow_amount of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.max_borrow_amount":
		panic(fmt.Errorf("field max_borrow_amount of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.origination_fee_factor":
		panic(fmt.Errorf("field origination_fee_factor of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.reserve_factor":
		panic(fmt.Errorf("field reserve_factor of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.max_ltv":
		panic(fmt.Errorf("field max_ltv of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.liquidation_threshold":
		panic(fmt.Errorf("field liquidation_threshold of message bitway.lending.PoolConfig is not mutable"))
	case "bitway.lending.PoolConfig.paused":
		panic(fmt.Errorf("field paused of message bitway.lending.PoolConfig is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolConfig does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PoolConfig) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.PoolConfig.collateral_asset":
		m := new(AssetMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.PoolConfig.lending_asset":
		m := new(AssetMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.PoolConfig.supply_cap":
		return protoreflect.ValueOfString("")
	case "bitway.lending.PoolConfig.borrow_cap":
		return protoreflect.ValueOfString("")
	case "bitway.lending.PoolConfig.min_borrow_amount":
		return protoreflect.ValueOfString("")
	case "bitway.lending.PoolConfig.max_borrow_amount":
		return protoreflect.ValueOfString("")
	case "bitway.lending.PoolConfig.tranches":
		list := []*PoolTrancheConfig{}
		return protoreflect.ValueOfList(&_PoolConfig_7_list{list: &list})
	case "bitway.lending.PoolConfig.request_fee":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.PoolConfig.origination_fee_factor":
		return protoreflect.ValueOfUint32(uint32(0))
	case "bitway.lending.PoolConfig.reserve_factor":
		return protoreflect.ValueOfUint32(uint32(0))
	case "bitway.lending.PoolConfig.max_ltv":
		return protoreflect.ValueOfUint32(uint32(0))
	case "bitway.lending.PoolConfig.liquidation_threshold":
		return protoreflect.ValueOfUint32(uint32(0))
	case "bitway.lending.PoolConfig.paused":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolConfig"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolConfig does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PoolConfig) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.PoolConfig", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PoolConfig) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolConfig) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PoolConfig) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PoolConfig) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PoolConfig)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.CollateralAsset != nil {
			l = options.Size(x.CollateralAsset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.LendingAsset != nil {
			l = options.Size(x.LendingAsset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SupplyCap)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BorrowCap)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MinBorrowAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MaxBorrowAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Tranches) > 0 {
			for _, e := range x.Tranches {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.RequestFee != nil {
			l = options.Size(x.RequestFee)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.OriginationFeeFactor != 0 {
			n += 1 + runtime.Sov(uint64(x.OriginationFeeFactor))
		}
		if x.ReserveFactor != 0 {
			n += 1 + runtime.Sov(uint64(x.ReserveFactor))
		}
		if x.MaxLtv != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxLtv))
		}
		if x.LiquidationThreshold != 0 {
			n += 1 + runtime.Sov(uint64(x.LiquidationThreshold))
		}
		if x.Paused {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PoolConfig)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Paused {
			i--
			if x.Paused {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x68
		}
		if x.LiquidationThreshold != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LiquidationThreshold))
			i--
			dAtA[i] = 0x60
		}
		if x.MaxLtv != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxLtv))
			i--
			dAtA[i] = 0x58
		}
		if x.ReserveFactor != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ReserveFactor))
			i--
			dAtA[i] = 0x50
		}
		if x.OriginationFeeFactor != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OriginationFeeFactor))
			i--
			dAtA[i] = 0x48
		}
		if x.RequestFee != nil {
			encoded, err := options.Marshal(x.RequestFee)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.Tranches) > 0 {
			for iNdEx := len(x.Tranches) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Tranches[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x3a
			}
		}
		if len(x.MaxBorrowAmount) > 0 {
			i -= len(x.MaxBorrowAmount)
			copy(dAtA[i:], x.MaxBorrowAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxBorrowAmount)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.MinBorrowAmount) > 0 {
			i -= len(x.MinBorrowAmount)
			copy(dAtA[i:], x.MinBorrowAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MinBorrowAmount)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.BorrowCap) > 0 {
			i -= len(x.BorrowCap)
			copy(dAtA[i:], x.BorrowCap)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowCap)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.SupplyCap) > 0 {
			i -= len(x.SupplyCap)
			copy(dAtA[i:], x.SupplyCap)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SupplyCap)))
			i--
			dAtA[i] = 0x1a
		}
		if x.LendingAsset != nil {
			encoded, err := options.Marshal(x.LendingAsset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.CollateralAsset != nil {
			encoded, err := options.Marshal(x.CollateralAsset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PoolConfig)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolConfig: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolConfig: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CollateralAsset == nil {
					x.CollateralAsset = &AssetMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CollateralAsset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LendingAsset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LendingAsset == nil {
					x.LendingAsset = &AssetMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LendingAsset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SupplyCap", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SupplyCap = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowCap", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowCap = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinBorrowAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MinBorrowAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxBorrowAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxBorrowAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tranches", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Tranches = append(x.Tranches, &PoolTrancheConfig{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Tranches[len(x.Tranches)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequestFee", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequestFee == nil {
					x.RequestFee = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequestFee); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OriginationFeeFactor", wireType)
				}
				x.OriginationFeeFactor = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OriginationFeeFactor |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReserveFactor", wireType)
				}
				x.ReserveFactor = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ReserveFactor |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxLtv", wireType)
				}
				x.MaxLtv = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxLtv |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidationThreshold", wireType)
				}
				x.LiquidationThreshold = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LiquidationThreshold |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 13:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Paused = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PoolTranche                protoreflect.MessageDescriptor
	fd_PoolTranche_maturity       protoreflect.FieldDescriptor
	fd_PoolTranche_borrow_index   protoreflect.FieldDescriptor
	fd_PoolTranche_total_borrowed protoreflect.FieldDescriptor
	fd_PoolTranche_total_reserve  protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_PoolTranche = File_bitway_lending_lending_proto.Messages().ByName("PoolTranche")
	fd_PoolTranche_maturity = md_PoolTranche.Fields().ByName("maturity")
	fd_PoolTranche_borrow_index = md_PoolTranche.Fields().ByName("borrow_index")
	fd_PoolTranche_total_borrowed = md_PoolTranche.Fields().ByName("total_borrowed")
	fd_PoolTranche_total_reserve = md_PoolTranche.Fields().ByName("total_reserve")
}

var _ protoreflect.Message = (*fastReflection_PoolTranche)(nil)

type fastReflection_PoolTranche PoolTranche

func (x *PoolTranche) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PoolTranche)(x)
}

func (x *PoolTranche) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PoolTranche_messageType fastReflection_PoolTranche_messageType
var _ protoreflect.MessageType = fastReflection_PoolTranche_messageType{}

type fastReflection_PoolTranche_messageType struct{}

func (x fastReflection_PoolTranche_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PoolTranche)(nil)
}
func (x fastReflection_PoolTranche_messageType) New() protoreflect.Message {
	return new(fastReflection_PoolTranche)
}
func (x fastReflection_PoolTranche_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolTranche
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PoolTranche) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolTranche
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PoolTranche) Type() protoreflect.MessageType {
	return _fastReflection_PoolTranche_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PoolTranche) New() protoreflect.Message {
	return new(fastReflection_PoolTranche)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PoolTranche) Interface() protoreflect.ProtoMessage {
	return (*PoolTranche)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PoolTranche) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Maturity != int64(0) {
		value := protoreflect.ValueOfInt64(x.Maturity)
		if !f(fd_PoolTranche_maturity, value) {
			return
		}
	}
	if x.BorrowIndex != "" {
		value := protoreflect.ValueOfString(x.BorrowIndex)
		if !f(fd_PoolTranche_borrow_index, value) {
			return
		}
	}
	if x.TotalBorrowed != "" {
		value := protoreflect.ValueOfString(x.TotalBorrowed)
		if !f(fd_PoolTranche_total_borrowed, value) {
			return
		}
	}
	if x.TotalReserve != "" {
		value := protoreflect.ValueOfString(x.TotalReserve)
		if !f(fd_PoolTranche_total_reserve, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PoolTranche) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.PoolTranche.maturity":
		return x.Maturity != int64(0)
	case "bitway.lending.PoolTranche.borrow_index":
		return x.BorrowIndex != ""
	case "bitway.lending.PoolTranche.total_borrowed":
		return x.TotalBorrowed != ""
	case "bitway.lending.PoolTranche.total_reserve":
		return x.TotalReserve != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTranche"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTranche does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTranche) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.PoolTranche.maturity":
		x.Maturity = int64(0)
	case "bitway.lending.PoolTranche.borrow_index":
		x.BorrowIndex = ""
	case "bitway.lending.PoolTranche.total_borrowed":
		x.TotalBorrowed = ""
	case "bitway.lending.PoolTranche.total_reserve":
		x.TotalReserve = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTranche"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTranche does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PoolTranche) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.PoolTranche.maturity":
		value := x.Maturity
		return protoreflect.ValueOfInt64(value)
	case "bitway.lending.PoolTranche.borrow_index":
		value := x.BorrowIndex
		return protoreflect.ValueOfString(value)
	case "bitway.lending.PoolTranche.total_borrowed":
		value := x.TotalBorrowed
		return protoreflect.ValueOfString(value)
	case "bitway.lending.PoolTranche.total_reserve":
		value := x.TotalReserve
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTranche"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTranche does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTranche) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.PoolTranche.maturity":
		x.Maturity = value.Int()
	case "bitway.lending.PoolTranche.borrow_index":
		x.BorrowIndex = value.Interface().(string)
	case "bitway.lending.PoolTranche.total_borrowed":
		x.TotalBorrowed = value.Interface().(string)
	case "bitway.lending.PoolTranche.total_reserve":
		x.TotalReserve = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTranche"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTranche does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTranche) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.PoolTranche.maturity":
		panic(fmt.Errorf("field maturity of message bitway.lending.PoolTranche is not mutable"))
	case "bitway.lending.PoolTranche.borrow_index":
		panic(fmt.Errorf("field borrow_index of message bitway.lending.PoolTranche is not mutable"))
	case "bitway.lending.PoolTranche.total_borrowed":
		panic(fmt.Errorf("field total_borrowed of message bitway.lending.PoolTranche is not mutable"))
	case "bitway.lending.PoolTranche.total_reserve":
		panic(fmt.Errorf("field total_reserve of message bitway.lending.PoolTranche is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTranche"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTranche does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PoolTranche) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.PoolTranche.maturity":
		return protoreflect.ValueOfInt64(int64(0))
	case "bitway.lending.PoolTranche.borrow_index":
		return protoreflect.ValueOfString("")
	case "bitway.lending.PoolTranche.total_borrowed":
		return protoreflect.ValueOfString("")
	case "bitway.lending.PoolTranche.total_reserve":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.PoolTranche"))
		}
		panic(fmt.Errorf("message bitway.lending.PoolTranche does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PoolTranche) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.PoolTranche", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PoolTranche) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTranche) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PoolTranche) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PoolTranche) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PoolTranche)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Maturity != 0 {
			n += 1 + runtime.Sov(uint64(x.Maturity))
		}
		l = len(x.BorrowIndex)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalBorrowed)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalReserve)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PoolTranche)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TotalReserve) > 0 {
			i -= len(x.TotalReserve)
			copy(dAtA[i:], x.TotalReserve)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalReserve)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.TotalBorrowed) > 0 {
			i -= len(x.TotalBorrowed)
			copy(dAtA[i:], x.TotalBorrowed)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalBorrowed)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.BorrowIndex) > 0 {
			i -= len(x.BorrowIndex)
			copy(dAtA[i:], x.BorrowIndex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowIndex)))
			i--
			dAtA[i] = 0x12
		}
		if x.Maturity != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Maturity))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PoolTranche)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolTranche: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolTranche: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Maturity", wireType)
				}
				x.Maturity = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Maturity |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowIndex", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowIndex = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalBorrowed", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalBorrowed = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalReserve", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalReserve = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_LendingPool_9_list)(nil)

type _LendingPool_9_list struct {
	list *[]*PoolTranche
}

func (x *_LendingPool_9_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_LendingPool_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_LendingPool_9_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolTranche)
	(*x.list)[i] = concreteValue
}

func (x *_LendingPool_9_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolTranche)
	*x.list = append(*x.list, concreteValue)
}

func (x *_LendingPool_9_list) AppendMutable() protoreflect.Value {
	v := new(PoolTranche)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_LendingPool_9_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_LendingPool_9_list) NewElement() protoreflect.Value {
	v := new(PoolTranche)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_LendingPool_9_list) IsValid() bool {
	return x.list != nil
}

var (
	md_LendingPool                  protoreflect.MessageDescriptor
	fd_LendingPool_id               protoreflect.FieldDescriptor
	fd_LendingPool_supply           protoreflect.FieldDescriptor
	fd_LendingPool_available_amount protoreflect.FieldDescriptor
	fd_LendingPool_borrowed_amount  protoreflect.FieldDescriptor
	fd_LendingPool_total_borrowed   protoreflect.FieldDescriptor
	fd_LendingPool_reserve_amount   protoreflect.FieldDescriptor
	fd_LendingPool_total_reserve    protoreflect.FieldDescriptor
	fd_LendingPool_total_ytokens    protoreflect.FieldDescriptor
	fd_LendingPool_tranches         protoreflect.FieldDescriptor
	fd_LendingPool_config           protoreflect.FieldDescriptor
	fd_LendingPool_status           protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_LendingPool = File_bitway_lending_lending_proto.Messages().ByName("LendingPool")
	fd_LendingPool_id = md_LendingPool.Fields().ByName("id")
	fd_LendingPool_supply = md_LendingPool.Fields().ByName("supply")
	fd_LendingPool_available_amount = md_LendingPool.Fields().ByName("available_amount")
	fd_LendingPool_borrowed_amount = md_LendingPool.Fields().ByName("borrowed_amount")
	fd_LendingPool_total_borrowed = md_LendingPool.Fields().ByName("total_borrowed")
	fd_LendingPool_reserve_amount = md_LendingPool.Fields().ByName("reserve_amount")
	fd_LendingPool_total_reserve = md_LendingPool.Fields().ByName("total_reserve")
	fd_LendingPool_total_ytokens = md_LendingPool.Fields().ByName("total_ytokens")
	fd_LendingPool_tranches = md_LendingPool.Fields().ByName("tranches")
	fd_LendingPool_config = md_LendingPool.Fields().ByName("config")
	fd_LendingPool_status = md_LendingPool.Fields().ByName("status")
}

var _ protoreflect.Message = (*fastReflection_LendingPool)(nil)

type fastReflection_LendingPool LendingPool

func (x *LendingPool) ProtoReflect() protoreflect.Message {
	return (*fastReflection_LendingPool)(x)
}

func (x *LendingPool) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_LendingPool_messageType fastReflection_LendingPool_messageType
var _ protoreflect.MessageType = fastReflection_LendingPool_messageType{}

type fastReflection_LendingPool_messageType struct{}

func (x fastReflection_LendingPool_messageType) Zero() protoreflect.Message {
	return (*fastReflection_LendingPool)(nil)
}
func (x fastReflection_LendingPool_messageType) New() protoreflect.Message {
	return new(fastReflection_LendingPool)
}
func (x fastReflection_LendingPool_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_LendingPool
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_LendingPool) Descriptor() protoreflect.MessageDescriptor {
	return md_LendingPool
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_LendingPool) Type() protoreflect.MessageType {
	return _fastReflection_LendingPool_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_LendingPool) New() protoreflect.Message {
	return new(fastReflection_LendingPool)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_LendingPool) Interface() protoreflect.ProtoMessage {
	return (*LendingPool)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_LendingPool) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != "" {
		value := protoreflect.ValueOfString(x.Id)
		if !f(fd_LendingPool_id, value) {
			return
		}
	}
	if x.Supply != nil {
		value := protoreflect.ValueOfMessage(x.Supply.ProtoReflect())
		if !f(fd_LendingPool_supply, value) {
			return
		}
	}
	if x.AvailableAmount != "" {
		value := protoreflect.ValueOfString(x.AvailableAmount)
		if !f(fd_LendingPool_available_amount, value) {
			return
		}
	}
	if x.BorrowedAmount != "" {
		value := protoreflect.ValueOfString(x.BorrowedAmount)
		if !f(fd_LendingPool_borrowed_amount, value) {
			return
		}
	}
	if x.TotalBorrowed != "" {
		value := protoreflect.ValueOfString(x.TotalBorrowed)
		if !f(fd_LendingPool_total_borrowed, value) {
			return
		}
	}
	if x.ReserveAmount != "" {
		value := protoreflect.ValueOfString(x.ReserveAmount)
		if !f(fd_LendingPool_reserve_amount, value) {
			return
		}
	}
	if x.TotalReserve != "" {
		value := protoreflect.ValueOfString(x.TotalReserve)
		if !f(fd_LendingPool_total_reserve, value) {
			return
		}
	}
	if x.TotalYtokens != nil {
		value := protoreflect.ValueOfMessage(x.TotalYtokens.ProtoReflect())
		if !f(fd_LendingPool_total_ytokens, value) {
			return
		}
	}
	if len(x.Tranches) != 0 {
		value := protoreflect.ValueOfList(&_LendingPool_9_list{list: &x.Tranches})
		if !f(fd_LendingPool_tranches, value) {
			return
		}
	}
	if x.Config != nil {
		value := protoreflect.ValueOfMessage(x.Config.ProtoReflect())
		if !f(fd_LendingPool_config, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_LendingPool_status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_LendingPool) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.LendingPool.id":
		return x.Id != ""
	case "bitway.lending.LendingPool.supply":
		return x.Supply != nil
	case "bitway.lending.LendingPool.available_amount":
		return x.AvailableAmount != ""
	case "bitway.lending.LendingPool.borrowed_amount":
		return x.BorrowedAmount != ""
	case "bitway.lending.LendingPool.total_borrowed":
		return x.TotalBorrowed != ""
	case "bitway.lending.LendingPool.reserve_amount":
		return x.ReserveAmount != ""
	case "bitway.lending.LendingPool.total_reserve":
		return x.TotalReserve != ""
	case "bitway.lending.LendingPool.total_ytokens":
		return x.TotalYtokens != nil
	case "bitway.lending.LendingPool.tranches":
		return len(x.Tranches) != 0
	case "bitway.lending.LendingPool.config":
		return x.Config != nil
	case "bitway.lending.LendingPool.status":
		return x.Status != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LendingPool"))
		}
		panic(fmt.Errorf("message bitway.lending.LendingPool does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LendingPool) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.LendingPool.id":
		x.Id = ""
	case "bitway.lending.LendingPool.supply":
		x.Supply = nil
	case "bitway.lending.LendingPool.available_amount":
		x.AvailableAmount = ""
	case "bitway.lending.LendingPool.borrowed_amount":
		x.BorrowedAmount = ""
	case "bitway.lending.LendingPool.total_borrowed":
		x.TotalBorrowed = ""
	case "bitway.lending.LendingPool.reserve_amount":
		x.ReserveAmount = ""
	case "bitway.lending.LendingPool.total_reserve":
		x.TotalReserve = ""
	case "bitway.lending.LendingPool.total_ytokens":
		x.TotalYtokens = nil
	case "bitway.lending.LendingPool.tranches":
		x.Tranches = nil
	case "bitway.lending.LendingPool.config":
		x.Config = nil
	case "bitway.lending.LendingPool.status":
		x.Status = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LendingPool"))
		}
		panic(fmt.Errorf("message bitway.lending.LendingPool does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_LendingPool) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.LendingPool.id":
		value := x.Id
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LendingPool.supply":
		value := x.Supply
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.LendingPool.available_amount":
		value := x.AvailableAmount
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LendingPool.borrowed_amount":
		value := x.BorrowedAmount
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LendingPool.total_borrowed":
		value := x.TotalBorrowed
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LendingPool.reserve_amount":
		value := x.ReserveAmount
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LendingPool.total_reserve":
		value := x.TotalReserve
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LendingPool.total_ytokens":
		value := x.TotalYtokens
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.LendingPool.tranches":
		if len(x.Tranches) == 0 {
			return protoreflect.ValueOfList(&_LendingPool_9_list{})
		}
		listValue := &_LendingPool_9_list{list: &x.Tranches}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.LendingPool.config":
		value := x.Config
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.LendingPool.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LendingPool"))
		}
		panic(fmt.Errorf("message bitway.lending.LendingPool does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LendingPool) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.LendingPool.id":
		x.Id = value.Interface().(string)
	case "bitway.lending.LendingPool.supply":
		x.Supply = value.Message().Interface().(*v1beta1.Coin)
	case "bitway.lending.LendingPool.available_amount":
		x.AvailableAmount = value.Interface().(string)
	case "bitway.lending.LendingPool.borrowed_amount":
		x.BorrowedAmount = value.Interface().(string)
	case "bitway.lending.LendingPool.total_borrowed":
		x.TotalBorrowed = value.Interface().(string)
	case "bitway.lending.LendingPool.reserve_amount":
		x.ReserveAmount = value.Interface().(string)
	case "bitway.lending.LendingPool.total_reserve":
		x.TotalReserve = value.Interface().(string)
	case "bitway.lending.LendingPool.total_ytokens":
		x.TotalYtokens = value.Message().Interface().(*v1beta1.Coin)
	case "bitway.lending.LendingPool.tranches":
		lv := value.List()
		clv := lv.(*_LendingPool_9_list)
		x.Tranches = *clv.list
	case "bitway.lending.LendingPool.config":
		x.Config = value.Message().Interface().(*PoolConfig)
	case "bitway.lending.LendingPool.status":
		x.Status = (PoolStatus)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LendingPool"))
		}
		panic(fmt.Errorf("message bitway.lending.LendingPool does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LendingPool) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.LendingPool.supply":
		if x.Supply == nil {
			x.Supply = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.Supply.ProtoReflect())
	case "bitway.lending.LendingPool.total_ytokens":
		if x.TotalYtokens == nil {
			x.TotalYtokens = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.TotalYtokens.ProtoReflect())
	case "bitway.lending.LendingPool.tranches":
		if x.Tranches == nil {
			x.Tranches = []*PoolTranche{}
		}
		value := &_LendingPool_9_list{list: &x.Tranches}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.LendingPool.config":
		if x.Config == nil {
			x.Config = new(PoolConfig)
		}
		return protoreflect.ValueOfMessage(x.Config.ProtoReflect())
	case "bitway.lending.LendingPool.id":
		panic(fmt.Errorf("field id of message bitway.lending.LendingPool is not mutable"))
	case "bitway.lending.LendingPool.available_amount":
		panic(fmt.Errorf("field available_amount of message bitway.lending.LendingPool is not mutable"))
	case "bitway.lending.LendingPool.borrowed_amount":
		panic(fmt.Errorf("field borrowed_amount of message bitway.lending.LendingPool is not mutable"))
	case "bitway.lending.LendingPool.total_borrowed":
		panic(fmt.Errorf("field total_borrowed of message bitway.lending.LendingPool is not mutable"))
	case "bitway.lending.LendingPool.reserve_amount":
		panic(fmt.Errorf("field reserve_amount of message bitway.lending.LendingPool is not mutable"))
	case "bitway.lending.LendingPool.total_reserve":
		panic(fmt.Errorf("field total_reserve of message bitway.lending.LendingPool is not mutable"))
	case "bitway.lending.LendingPool.status":
		panic(fmt.Errorf("field status of message bitway.lending.LendingPool is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LendingPool"))
		}
		panic(fmt.Errorf("message bitway.lending.LendingPool does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_LendingPool) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.LendingPool.id":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LendingPool.supply":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.LendingPool.available_amount":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LendingPool.borrowed_amount":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LendingPool.total_borrowed":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LendingPool.reserve_amount":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LendingPool.total_reserve":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LendingPool.total_ytokens":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.LendingPool.tranches":
		list := []*PoolTranche{}
		return protoreflect.ValueOfList(&_LendingPool_9_list{list: &list})
	case "bitway.lending.LendingPool.config":
		m := new(PoolConfig)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.LendingPool.status":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LendingPool"))
		}
		panic(fmt.Errorf("message bitway.lending.LendingPool does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_LendingPool) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.LendingPool", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_LendingPool) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LendingPool) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_LendingPool) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_LendingPool) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*LendingPool)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Id)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Supply != nil {
			l = options.Size(x.Supply)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AvailableAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BorrowedAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalBorrowed)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReserveAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalReserve)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.TotalYtokens != nil {
			l = options.Size(x.TotalYtokens)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Tranches) > 0 {
			for _, e := range x.Tranches {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.Config != nil {
			l = options.Size(x.Config)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*LendingPool)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x58
		}
		if x.Config != nil {
			encoded, err := options.Marshal(x.Config)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if len(x.Tranches) > 0 {
			for iNdEx := len(x.Tranches) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Tranches[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x4a
			}
		}
		if x.TotalYtokens != nil {
			encoded, err := options.Marshal(x.TotalYtokens)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.TotalReserve) > 0 {
			i -= len(x.TotalReserve)
			copy(dAtA[i:], x.TotalReserve)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalReserve)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.ReserveAmount) > 0 {
			i -= len(x.ReserveAmount)
			copy(dAtA[i:], x.ReserveAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReserveAmount)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.TotalBorrowed) > 0 {
			i -= len(x.TotalBorrowed)
			copy(dAtA[i:], x.TotalBorrowed)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalBorrowed)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.BorrowedAmount) > 0 {
			i -= len(x.BorrowedAmount)
			copy(dAtA[i:], x.BorrowedAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowedAmount)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AvailableAmount) > 0 {
			i -= len(x.AvailableAmount)
			copy(dAtA[i:], x.AvailableAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AvailableAmount)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Supply != nil {
			encoded, err := options.Marshal(x.Supply)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Id) > 0 {
			i -= len(x.Id)
			copy(dAtA[i:], x.Id)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Id)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*LendingPool)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LendingPool: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LendingPool: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Id = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Supply == nil {
					x.Supply = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Supply); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AvailableAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AvailableAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowedAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowedAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalBorrowed", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalBorrowed = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReserveAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReserveAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalReserve", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalReserve = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalYtokens", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.TotalYtokens == nil {
					x.TotalYtokens = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TotalYtokens); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tranches", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Tranches = append(x.Tranches, &PoolTranche{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Tranches[len(x.Tranches)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Config == nil {
					x.Config = &PoolConfig{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Config); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 11:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= PoolStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_Authorization_2_list)(nil)

type _Authorization_2_list struct {
	list *[]string
}

func (x *_Authorization_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Authorization_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_Authorization_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_Authorization_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_Authorization_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message Authorization at list field DepositTxs as it is not of Message kind"))
}

func (x *_Authorization_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_Authorization_2_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_Authorization_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Authorization             protoreflect.MessageDescriptor
	fd_Authorization_id          protoreflect.FieldDescriptor
	fd_Authorization_deposit_txs protoreflect.FieldDescriptor
	fd_Authorization_status      protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_Authorization = File_bitway_lending_lending_proto.Messages().ByName("Authorization")
	fd_Authorization_id = md_Authorization.Fields().ByName("id")
	fd_Authorization_deposit_txs = md_Authorization.Fields().ByName("deposit_txs")
	fd_Authorization_status = md_Authorization.Fields().ByName("status")
}

var _ protoreflect.Message = (*fastReflection_Authorization)(nil)

type fastReflection_Authorization Authorization

func (x *Authorization) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Authorization)(x)
}

func (x *Authorization) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Authorization_messageType fastReflection_Authorization_messageType
var _ protoreflect.MessageType = fastReflection_Authorization_messageType{}

type fastReflection_Authorization_messageType struct{}

func (x fastReflection_Authorization_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Authorization)(nil)
}
func (x fastReflection_Authorization_messageType) New() protoreflect.Message {
	return new(fastReflection_Authorization)
}
func (x fastReflection_Authorization_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Authorization
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Authorization) Descriptor() protoreflect.MessageDescriptor {
	return md_Authorization
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Authorization) Type() protoreflect.MessageType {
	return _fastReflection_Authorization_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Authorization) New() protoreflect.Message {
	return new(fastReflection_Authorization)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Authorization) Interface() protoreflect.ProtoMessage {
	return (*Authorization)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Authorization) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_Authorization_id, value) {
			return
		}
	}
	if len(x.DepositTxs) != 0 {
		value := protoreflect.ValueOfList(&_Authorization_2_list{list: &x.DepositTxs})
		if !f(fd_Authorization_deposit_txs, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_Authorization_status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Authorization) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.Authorization.id":
		return x.Id != uint64(0)
	case "bitway.lending.Authorization.deposit_txs":
		return len(x.DepositTxs) != 0
	case "bitway.lending.Authorization.status":
		return x.Status != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Authorization"))
		}
		panic(fmt.Errorf("message bitway.lending.Authorization does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Authorization) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.Authorization.id":
		x.Id = uint64(0)
	case "bitway.lending.Authorization.deposit_txs":
		x.DepositTxs = nil
	case "bitway.lending.Authorization.status":
		x.Status = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Authorization"))
		}
		panic(fmt.Errorf("message bitway.lending.Authorization does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Authorization) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.Authorization.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "bitway.lending.Authorization.deposit_txs":
		if len(x.DepositTxs) == 0 {
			return protoreflect.ValueOfList(&_Authorization_2_list{})
		}
		listValue := &_Authorization_2_list{list: &x.DepositTxs}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.Authorization.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Authorization"))
		}
		panic(fmt.Errorf("message bitway.lending.Authorization does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Authorization) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.Authorization.id":
		x.Id = value.Uint()
	case "bitway.lending.Authorization.deposit_txs":
		lv := value.List()
		clv := lv.(*_Authorization_2_list)
		x.DepositTxs = *clv.list
	case "bitway.lending.Authorization.status":
		x.Status = (AuthorizationStatus)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Authorization"))
		}
		panic(fmt.Errorf("message bitway.lending.Authorization does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Authorization) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Authorization.deposit_txs":
		if x.DepositTxs == nil {
			x.DepositTxs = []string{}
		}
		value := &_Authorization_2_list{list: &x.DepositTxs}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.Authorization.id":
		panic(fmt.Errorf("field id of message bitway.lending.Authorization is not mutable"))
	case "bitway.lending.Authorization.status":
		panic(fmt.Errorf("field status of message bitway.lending.Authorization is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Authorization"))
		}
		panic(fmt.Errorf("message bitway.lending.Authorization does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Authorization) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Authorization.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "bitway.lending.Authorization.deposit_txs":
		list := []string{}
		return protoreflect.ValueOfList(&_Authorization_2_list{list: &list})
	case "bitway.lending.Authorization.status":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Authorization"))
		}
		panic(fmt.Errorf("message bitway.lending.Authorization does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Authorization) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.Authorization", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Authorization) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Authorization) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Authorization) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Authorization) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Authorization)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		if len(x.DepositTxs) > 0 {
			for _, s := range x.DepositTxs {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Authorization)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x18
		}
		if len(x.DepositTxs) > 0 {
			for iNdEx := len(x.DepositTxs) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.DepositTxs[iNdEx])
				copy(dAtA[i:], x.DepositTxs[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DepositTxs[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Authorization)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Authorization: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Authorization: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DepositTxs", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DepositTxs = append(x.DepositTxs, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= AuthorizationStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_Loan_19_list)(nil)

type _Loan_19_list struct {
	list *[]*Authorization
}

func (x *_Loan_19_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Loan_19_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Loan_19_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Authorization)
	(*x.list)[i] = concreteValue
}

func (x *_Loan_19_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Authorization)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Loan_19_list) AppendMutable() protoreflect.Value {
	v := new(Authorization)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Loan_19_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Loan_19_list) NewElement() protoreflect.Value {
	v := new(Authorization)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Loan_19_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Loan                    protoreflect.MessageDescriptor
	fd_Loan_vault_address      protoreflect.FieldDescriptor
	fd_Loan_borrower           protoreflect.FieldDescriptor
	fd_Loan_borrowerPubKey     protoreflect.FieldDescriptor
	fd_Loan_borrowerAuthPubKey protoreflect.FieldDescriptor
	fd_Loan_dcm                protoreflect.FieldDescriptor
	fd_Loan_maturity_time      protoreflect.FieldDescriptor
	fd_Loan_final_timeout      protoreflect.FieldDescriptor
	fd_Loan_pool_id            protoreflect.FieldDescriptor
	fd_Loan_borrow_amount      protoreflect.FieldDescriptor
	fd_Loan_request_fee        protoreflect.FieldDescriptor
	fd_Loan_origination_fee    protoreflect.FieldDescriptor
	fd_Loan_interest           protoreflect.FieldDescriptor
	fd_Loan_protocol_fee       protoreflect.FieldDescriptor
	fd_Loan_maturity           protoreflect.FieldDescriptor
	fd_Loan_borrow_apr         protoreflect.FieldDescriptor
	fd_Loan_start_borrow_index protoreflect.FieldDescriptor
	fd_Loan_liquidation_price  protoreflect.FieldDescriptor
	fd_Loan_dlc_event_id       protoreflect.FieldDescriptor
	fd_Loan_authorizations     protoreflect.FieldDescriptor
	fd_Loan_collateral_amount  protoreflect.FieldDescriptor
	fd_Loan_liquidation_id     protoreflect.FieldDescriptor
	fd_Loan_referrer           protoreflect.FieldDescriptor
	fd_Loan_create_at          protoreflect.FieldDescriptor
	fd_Loan_disburse_at        protoreflect.FieldDescriptor
	fd_Loan_status             protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_Loan = File_bitway_lending_lending_proto.Messages().ByName("Loan")
	fd_Loan_vault_address = md_Loan.Fields().ByName("vault_address")
	fd_Loan_borrower = md_Loan.Fields().ByName("borrower")
	fd_Loan_borrowerPubKey = md_Loan.Fields().ByName("borrowerPubKey")
	fd_Loan_borrowerAuthPubKey = md_Loan.Fields().ByName("borrowerAuthPubKey")
	fd_Loan_dcm = md_Loan.Fields().ByName("dcm")
	fd_Loan_maturity_time = md_Loan.Fields().ByName("maturity_time")
	fd_Loan_final_timeout = md_Loan.Fields().ByName("final_timeout")
	fd_Loan_pool_id = md_Loan.Fields().ByName("pool_id")
	fd_Loan_borrow_amount = md_Loan.Fields().ByName("borrow_amount")
	fd_Loan_request_fee = md_Loan.Fields().ByName("request_fee")
	fd_Loan_origination_fee = md_Loan.Fields().ByName("origination_fee")
	fd_Loan_interest = md_Loan.Fields().ByName("interest")
	fd_Loan_protocol_fee = md_Loan.Fields().ByName("protocol_fee")
	fd_Loan_maturity = md_Loan.Fields().ByName("maturity")
	fd_Loan_borrow_apr = md_Loan.Fields().ByName("borrow_apr")
	fd_Loan_start_borrow_index = md_Loan.Fields().ByName("start_borrow_index")
	fd_Loan_liquidation_price = md_Loan.Fields().ByName("liquidation_price")
	fd_Loan_dlc_event_id = md_Loan.Fields().ByName("dlc_event_id")
	fd_Loan_authorizations = md_Loan.Fields().ByName("authorizations")
	fd_Loan_collateral_amount = md_Loan.Fields().ByName("collateral_amount")
	fd_Loan_liquidation_id = md_Loan.Fields().ByName("liquidation_id")
	fd_Loan_referrer = md_Loan.Fields().ByName("referrer")
	fd_Loan_create_at = md_Loan.Fields().ByName("create_at")
	fd_Loan_disburse_at = md_Loan.Fields().ByName("disburse_at")
	fd_Loan_status = md_Loan.Fields().ByName("status")
}

var _ protoreflect.Message = (*fastReflection_Loan)(nil)

type fastReflection_Loan Loan

func (x *Loan) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Loan)(x)
}

func (x *Loan) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Loan_messageType fastReflection_Loan_messageType
var _ protoreflect.MessageType = fastReflection_Loan_messageType{}

type fastReflection_Loan_messageType struct{}

func (x fastReflection_Loan_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Loan)(nil)
}
func (x fastReflection_Loan_messageType) New() protoreflect.Message {
	return new(fastReflection_Loan)
}
func (x fastReflection_Loan_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Loan
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Loan) Descriptor() protoreflect.MessageDescriptor {
	return md_Loan
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Loan) Type() protoreflect.MessageType {
	return _fastReflection_Loan_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Loan) New() protoreflect.Message {
	return new(fastReflection_Loan)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Loan) Interface() protoreflect.ProtoMessage {
	return (*Loan)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Loan) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.VaultAddress != "" {
		value := protoreflect.ValueOfString(x.VaultAddress)
		if !f(fd_Loan_vault_address, value) {
			return
		}
	}
	if x.Borrower != "" {
		value := protoreflect.ValueOfString(x.Borrower)
		if !f(fd_Loan_borrower, value) {
			return
		}
	}
	if x.BorrowerPubKey != "" {
		value := protoreflect.ValueOfString(x.BorrowerPubKey)
		if !f(fd_Loan_borrowerPubKey, value) {
			return
		}
	}
	if x.BorrowerAuthPubKey != "" {
		value := protoreflect.ValueOfString(x.BorrowerAuthPubKey)
		if !f(fd_Loan_borrowerAuthPubKey, value) {
			return
		}
	}
	if x.Dcm != "" {
		value := protoreflect.ValueOfString(x.Dcm)
		if !f(fd_Loan_dcm, value) {
			return
		}
	}
	if x.MaturityTime != int64(0) {
		value := protoreflect.ValueOfInt64(x.MaturityTime)
		if !f(fd_Loan_maturity_time, value) {
			return
		}
	}
	if x.FinalTimeout != int64(0) {
		value := protoreflect.ValueOfInt64(x.FinalTimeout)
		if !f(fd_Loan_final_timeout, value) {
			return
		}
	}
	if x.PoolId != "" {
		value := protoreflect.ValueOfString(x.PoolId)
		if !f(fd_Loan_pool_id, value) {
			return
		}
	}
	if x.BorrowAmount != nil {
		value := protoreflect.ValueOfMessage(x.BorrowAmount.ProtoReflect())
		if !f(fd_Loan_borrow_amount, value) {
			return
		}
	}
	if x.RequestFee != nil {
		value := protoreflect.ValueOfMessage(x.RequestFee.ProtoReflect())
		if !f(fd_Loan_request_fee, value) {
			return
		}
	}
	if x.OriginationFee != "" {
		value := protoreflect.ValueOfString(x.OriginationFee)
		if !f(fd_Loan_origination_fee, value) {
			return
		}
	}
	if x.Interest != "" {
		value := protoreflect.ValueOfString(x.Interest)
		if !f(fd_Loan_interest, value) {
			return
		}
	}
	if x.ProtocolFee != "" {
		value := protoreflect.ValueOfString(x.ProtocolFee)
		if !f(fd_Loan_protocol_fee, value) {
			return
		}
	}
	if x.Maturity != int64(0) {
		value := protoreflect.ValueOfInt64(x.Maturity)
		if !f(fd_Loan_maturity, value) {
			return
		}
	}
	if x.BorrowApr != uint32(0) {
		value := protoreflect.ValueOfUint32(x.BorrowApr)
		if !f(fd_Loan_borrow_apr, value) {
			return
		}
	}
	if x.StartBorrowIndex != "" {
		value := protoreflect.ValueOfString(x.StartBorrowIndex)
		if !f(fd_Loan_start_borrow_index, value) {
			return
		}
	}
	if x.LiquidationPrice != "" {
		value := protoreflect.ValueOfString(x.LiquidationPrice)
		if !f(fd_Loan_liquidation_price, value) {
			return
		}
	}
	if x.DlcEventId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.DlcEventId)
		if !f(fd_Loan_dlc_event_id, value) {
			return
		}
	}
	if len(x.Authorizations) != 0 {
		value := protoreflect.ValueOfList(&_Loan_19_list{list: &x.Authorizations})
		if !f(fd_Loan_authorizations, value) {
			return
		}
	}
	if x.CollateralAmount != "" {
		value := protoreflect.ValueOfString(x.CollateralAmount)
		if !f(fd_Loan_collateral_amount, value) {
			return
		}
	}
	if x.LiquidationId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.LiquidationId)
		if !f(fd_Loan_liquidation_id, value) {
			return
		}
	}
	if x.Referrer != nil {
		value := protoreflect.ValueOfMessage(x.Referrer.ProtoReflect())
		if !f(fd_Loan_referrer, value) {
			return
		}
	}
	if x.CreateAt != nil {
		value := protoreflect.ValueOfMessage(x.CreateAt.ProtoReflect())
		if !f(fd_Loan_create_at, value) {
			return
		}
	}
	if x.DisburseAt != nil {
		value := protoreflect.ValueOfMessage(x.DisburseAt.ProtoReflect())
		if !f(fd_Loan_disburse_at, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_Loan_status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Loan) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.Loan.vault_address":
		return x.VaultAddress != ""
	case "bitway.lending.Loan.borrower":
		return x.Borrower != ""
	case "bitway.lending.Loan.borrowerPubKey":
		return x.BorrowerPubKey != ""
	case "bitway.lending.Loan.borrowerAuthPubKey":
		return x.BorrowerAuthPubKey != ""
	case "bitway.lending.Loan.dcm":
		return x.Dcm != ""
	case "bitway.lending.Loan.maturity_time":
		return x.MaturityTime != int64(0)
	case "bitway.lending.Loan.final_timeout":
		return x.FinalTimeout != int64(0)
	case "bitway.lending.Loan.pool_id":
		return x.PoolId != ""
	case "bitway.lending.Loan.borrow_amount":
		return x.BorrowAmount != nil
	case "bitway.lending.Loan.request_fee":
		return x.RequestFee != nil
	case "bitway.lending.Loan.origination_fee":
		return x.OriginationFee != ""
	case "bitway.lending.Loan.interest":
		return x.Interest != ""
	case "bitway.lending.Loan.protocol_fee":
		return x.ProtocolFee != ""
	case "bitway.lending.Loan.maturity":
		return x.Maturity != int64(0)
	case "bitway.lending.Loan.borrow_apr":
		return x.BorrowApr != uint32(0)
	case "bitway.lending.Loan.start_borrow_index":
		return x.StartBorrowIndex != ""
	case "bitway.lending.Loan.liquidation_price":
		return x.LiquidationPrice != ""
	case "bitway.lending.Loan.dlc_event_id":
		return x.DlcEventId != uint64(0)
	case "bitway.lending.Loan.authorizations":
		return len(x.Authorizations) != 0
	case "bitway.lending.Loan.collateral_amount":
		return x.CollateralAmount != ""
	case "bitway.lending.Loan.liquidation_id":
		return x.LiquidationId != uint64(0)
	case "bitway.lending.Loan.referrer":
		return x.Referrer != nil
	case "bitway.lending.Loan.create_at":
		return x.CreateAt != nil
	case "bitway.lending.Loan.disburse_at":
		return x.DisburseAt != nil
	case "bitway.lending.Loan.status":
		return x.Status != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Loan"))
		}
		panic(fmt.Errorf("message bitway.lending.Loan does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Loan) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.Loan.vault_address":
		x.VaultAddress = ""
	case "bitway.lending.Loan.borrower":
		x.Borrower = ""
	case "bitway.lending.Loan.borrowerPubKey":
		x.BorrowerPubKey = ""
	case "bitway.lending.Loan.borrowerAuthPubKey":
		x.BorrowerAuthPubKey = ""
	case "bitway.lending.Loan.dcm":
		x.Dcm = ""
	case "bitway.lending.Loan.maturity_time":
		x.MaturityTime = int64(0)
	case "bitway.lending.Loan.final_timeout":
		x.FinalTimeout = int64(0)
	case "bitway.lending.Loan.pool_id":
		x.PoolId = ""
	case "bitway.lending.Loan.borrow_amount":
		x.BorrowAmount = nil
	case "bitway.lending.Loan.request_fee":
		x.RequestFee = nil
	case "bitway.lending.Loan.origination_fee":
		x.OriginationFee = ""
	case "bitway.lending.Loan.interest":
		x.Interest = ""
	case "bitway.lending.Loan.protocol_fee":
		x.ProtocolFee = ""
	case "bitway.lending.Loan.maturity":
		x.Maturity = int64(0)
	case "bitway.lending.Loan.borrow_apr":
		x.BorrowApr = uint32(0)
	case "bitway.lending.Loan.start_borrow_index":
		x.StartBorrowIndex = ""
	case "bitway.lending.Loan.liquidation_price":
		x.LiquidationPrice = ""
	case "bitway.lending.Loan.dlc_event_id":
		x.DlcEventId = uint64(0)
	case "bitway.lending.Loan.authorizations":
		x.Authorizations = nil
	case "bitway.lending.Loan.collateral_amount":
		x.CollateralAmount = ""
	case "bitway.lending.Loan.liquidation_id":
		x.LiquidationId = uint64(0)
	case "bitway.lending.Loan.referrer":
		x.Referrer = nil
	case "bitway.lending.Loan.create_at":
		x.CreateAt = nil
	case "bitway.lending.Loan.disburse_at":
		x.DisburseAt = nil
	case "bitway.lending.Loan.status":
		x.Status = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Loan"))
		}
		panic(fmt.Errorf("message bitway.lending.Loan does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Loan) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.Loan.vault_address":
		value := x.VaultAddress
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.borrower":
		value := x.Borrower
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.borrowerPubKey":
		value := x.BorrowerPubKey
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.borrowerAuthPubKey":
		value := x.BorrowerAuthPubKey
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.dcm":
		value := x.Dcm
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.maturity_time":
		value := x.MaturityTime
		return protoreflect.ValueOfInt64(value)
	case "bitway.lending.Loan.final_timeout":
		value := x.FinalTimeout
		return protoreflect.ValueOfInt64(value)
	case "bitway.lending.Loan.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.borrow_amount":
		value := x.BorrowAmount
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.Loan.request_fee":
		value := x.RequestFee
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.Loan.origination_fee":
		value := x.OriginationFee
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.interest":
		value := x.Interest
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.protocol_fee":
		value := x.ProtocolFee
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.maturity":
		value := x.Maturity
		return protoreflect.ValueOfInt64(value)
	case "bitway.lending.Loan.borrow_apr":
		value := x.BorrowApr
		return protoreflect.ValueOfUint32(value)
	case "bitway.lending.Loan.start_borrow_index":
		value := x.StartBorrowIndex
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.liquidation_price":
		value := x.LiquidationPrice
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.dlc_event_id":
		value := x.DlcEventId
		return protoreflect.ValueOfUint64(value)
	case "bitway.lending.Loan.authorizations":
		if len(x.Authorizations) == 0 {
			return protoreflect.ValueOfList(&_Loan_19_list{})
		}
		listValue := &_Loan_19_list{list: &x.Authorizations}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.Loan.collateral_amount":
		value := x.CollateralAmount
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Loan.liquidation_id":
		value := x.LiquidationId
		return protoreflect.ValueOfUint64(value)
	case "bitway.lending.Loan.referrer":
		value := x.Referrer
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.Loan.create_at":
		value := x.CreateAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.Loan.disburse_at":
		value := x.DisburseAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.Loan.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Loan"))
		}
		panic(fmt.Errorf("message bitway.lending.Loan does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Loan) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.Loan.vault_address":
		x.VaultAddress = value.Interface().(string)
	case "bitway.lending.Loan.borrower":
		x.Borrower = value.Interface().(string)
	case "bitway.lending.Loan.borrowerPubKey":
		x.BorrowerPubKey = value.Interface().(string)
	case "bitway.lending.Loan.borrowerAuthPubKey":
		x.BorrowerAuthPubKey = value.Interface().(string)
	case "bitway.lending.Loan.dcm":
		x.Dcm = value.Interface().(string)
	case "bitway.lending.Loan.maturity_time":
		x.MaturityTime = value.Int()
	case "bitway.lending.Loan.final_timeout":
		x.FinalTimeout = value.Int()
	case "bitway.lending.Loan.pool_id":
		x.PoolId = value.Interface().(string)
	case "bitway.lending.Loan.borrow_amount":
		x.BorrowAmount = value.Message().Interface().(*v1beta1.Coin)
	case "bitway.lending.Loan.request_fee":
		x.RequestFee = value.Message().Interface().(*v1beta1.Coin)
	case "bitway.lending.Loan.origination_fee":
		x.OriginationFee = value.Interface().(string)
	case "bitway.lending.Loan.interest":
		x.Interest = value.Interface().(string)
	case "bitway.lending.Loan.protocol_fee":
		x.ProtocolFee = value.Interface().(string)
	case "bitway.lending.Loan.maturity":
		x.Maturity = value.Int()
	case "bitway.lending.Loan.borrow_apr":
		x.BorrowApr = uint32(value.Uint())
	case "bitway.lending.Loan.start_borrow_index":
		x.StartBorrowIndex = value.Interface().(string)
	case "bitway.lending.Loan.liquidation_price":
		x.LiquidationPrice = value.Interface().(string)
	case "bitway.lending.Loan.dlc_event_id":
		x.DlcEventId = value.Uint()
	case "bitway.lending.Loan.authorizations":
		lv := value.List()
		clv := lv.(*_Loan_19_list)
		x.Authorizations = *clv.list
	case "bitway.lending.Loan.collateral_amount":
		x.CollateralAmount = value.Interface().(string)
	case "bitway.lending.Loan.liquidation_id":
		x.LiquidationId = value.Uint()
	case "bitway.lending.Loan.referrer":
		x.Referrer = value.Message().Interface().(*Referrer)
	case "bitway.lending.Loan.create_at":
		x.CreateAt = value.Message().Interface().(*timestamppb.Timestamp)
	case "bitway.lending.Loan.disburse_at":
		x.DisburseAt = value.Message().Interface().(*timestamppb.Timestamp)
	case "bitway.lending.Loan.status":
		x.Status = (LoanStatus)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Loan"))
		}
		panic(fmt.Errorf("message bitway.lending.Loan does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Loan) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Loan.borrow_amount":
		if x.BorrowAmount == nil {
			x.BorrowAmount = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.BorrowAmount.ProtoReflect())
	case "bitway.lending.Loan.request_fee":
		if x.RequestFee == nil {
			x.RequestFee = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.RequestFee.ProtoReflect())
	case "bitway.lending.Loan.authorizations":
		if x.Authorizations == nil {
			x.Authorizations = []*Authorization{}
		}
		value := &_Loan_19_list{list: &x.Authorizations}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.Loan.referrer":
		if x.Referrer == nil {
			x.Referrer = new(Referrer)
		}
		return protoreflect.ValueOfMessage(x.Referrer.ProtoReflect())
	case "bitway.lending.Loan.create_at":
		if x.CreateAt == nil {
			x.CreateAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.CreateAt.ProtoReflect())
	case "bitway.lending.Loan.disburse_at":
		if x.DisburseAt == nil {
			x.DisburseAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.DisburseAt.ProtoReflect())
	case "bitway.lending.Loan.vault_address":
		panic(fmt.Errorf("field vault_address of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.borrower":
		panic(fmt.Errorf("field borrower of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.borrowerPubKey":
		panic(fmt.Errorf("field borrowerPubKey of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.borrowerAuthPubKey":
		panic(fmt.Errorf("field borrowerAuthPubKey of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.dcm":
		panic(fmt.Errorf("field dcm of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.maturity_time":
		panic(fmt.Errorf("field maturity_time of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.final_timeout":
		panic(fmt.Errorf("field final_timeout of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.pool_id":
		panic(fmt.Errorf("field pool_id of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.origination_fee":
		panic(fmt.Errorf("field origination_fee of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.interest":
		panic(fmt.Errorf("field interest of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.protocol_fee":
		panic(fmt.Errorf("field protocol_fee of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.maturity":
		panic(fmt.Errorf("field maturity of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.borrow_apr":
		panic(fmt.Errorf("field borrow_apr of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.start_borrow_index":
		panic(fmt.Errorf("field start_borrow_index of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.liquidation_price":
		panic(fmt.Errorf("field liquidation_price of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.dlc_event_id":
		panic(fmt.Errorf("field dlc_event_id of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.collateral_amount":
		panic(fmt.Errorf("field collateral_amount of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.liquidation_id":
		panic(fmt.Errorf("field liquidation_id of message bitway.lending.Loan is not mutable"))
	case "bitway.lending.Loan.status":
		panic(fmt.Errorf("field status of message bitway.lending.Loan is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Loan"))
		}
		panic(fmt.Errorf("message bitway.lending.Loan does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Loan) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Loan.vault_address":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.borrower":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.borrowerPubKey":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.borrowerAuthPubKey":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.dcm":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.maturity_time":
		return protoreflect.ValueOfInt64(int64(0))
	case "bitway.lending.Loan.final_timeout":
		return protoreflect.ValueOfInt64(int64(0))
	case "bitway.lending.Loan.pool_id":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.borrow_amount":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.Loan.request_fee":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.Loan.origination_fee":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.interest":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.protocol_fee":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.maturity":
		return protoreflect.ValueOfInt64(int64(0))
	case "bitway.lending.Loan.borrow_apr":
		return protoreflect.ValueOfUint32(uint32(0))
	case "bitway.lending.Loan.start_borrow_index":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.liquidation_price":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.dlc_event_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "bitway.lending.Loan.authorizations":
		list := []*Authorization{}
		return protoreflect.ValueOfList(&_Loan_19_list{list: &list})
	case "bitway.lending.Loan.collateral_amount":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Loan.liquidation_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "bitway.lending.Loan.referrer":
		m := new(Referrer)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.Loan.create_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.Loan.disburse_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.Loan.status":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Loan"))
		}
		panic(fmt.Errorf("message bitway.lending.Loan does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Loan) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.Loan", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Loan) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Loan) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Loan) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Loan) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Loan)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.VaultAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Borrower)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BorrowerPubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BorrowerAuthPubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Dcm)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaturityTime != 0 {
			n += 1 + runtime.Sov(uint64(x.MaturityTime))
		}
		if x.FinalTimeout != 0 {
			n += 1 + runtime.Sov(uint64(x.FinalTimeout))
		}
		l = len(x.PoolId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BorrowAmount != nil {
			l = options.Size(x.BorrowAmount)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequestFee != nil {
			l = options.Size(x.RequestFee)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.OriginationFee)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Interest)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ProtocolFee)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Maturity != 0 {
			n += 1 + runtime.Sov(uint64(x.Maturity))
		}
		if x.BorrowApr != 0 {
			n += 1 + runtime.Sov(uint64(x.BorrowApr))
		}
		l = len(x.StartBorrowIndex)
		if l > 0 {
			n += 2 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LiquidationPrice)
		if l > 0 {
			n += 2 + l + runtime.Sov(uint64(l))
		}
		if x.DlcEventId != 0 {
			n += 2 + runtime.Sov(uint64(x.DlcEventId))
		}
		if len(x.Authorizations) > 0 {
			for _, e := range x.Authorizations {
				l = options.Size(e)
				n += 2 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.CollateralAmount)
		if l > 0 {
			n += 2 + l + runtime.Sov(uint64(l))
		}
		if x.LiquidationId != 0 {
			n += 2 + runtime.Sov(uint64(x.LiquidationId))
		}
		if x.Referrer != nil {
			l = options.Size(x.Referrer)
			n += 2 + l + runtime.Sov(uint64(l))
		}
		if x.CreateAt != nil {
			l = options.Size(x.CreateAt)
			n += 2 + l + runtime.Sov(uint64(l))
		}
		if x.DisburseAt != nil {
			l = options.Size(x.DisburseAt)
			n += 2 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 2 + runtime.Sov(uint64(x.Status))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Loan)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc8
		}
		if x.DisburseAt != nil {
			encoded, err := options.Marshal(x.DisburseAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
		if x.CreateAt != nil {
			encoded, err := options.Marshal(x.CreateAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
		if x.Referrer != nil {
			encoded, err := options.Marshal(x.Referrer)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
		if x.LiquidationId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LiquidationId))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa8
		}
		if len(x.CollateralAmount) > 0 {
			i -= len(x.CollateralAmount)
			copy(dAtA[i:], x.CollateralAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollateralAmount)))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
		if len(x.Authorizations) > 0 {
			for iNdEx := len(x.Authorizations) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Authorizations[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x1
				i--
				dAtA[i] = 0x9a
			}
		}
		if x.DlcEventId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.DlcEventId))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x90
		}
		if len(x.LiquidationPrice) > 0 {
			i -= len(x.LiquidationPrice)
			copy(dAtA[i:], x.LiquidationPrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LiquidationPrice)))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
		if len(x.StartBorrowIndex) > 0 {
			i -= len(x.StartBorrowIndex)
			copy(dAtA[i:], x.StartBorrowIndex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StartBorrowIndex)))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
		if x.BorrowApr != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BorrowApr))
			i--
			dAtA[i] = 0x78
		}
		if x.Maturity != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Maturity))
			i--
			dAtA[i] = 0x70
		}
		if len(x.ProtocolFee) > 0 {
			i -= len(x.ProtocolFee)
			copy(dAtA[i:], x.ProtocolFee)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ProtocolFee)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.Interest) > 0 {
			i -= len(x.Interest)
			copy(dAtA[i:], x.Interest)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Interest)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.OriginationFee) > 0 {
			i -= len(x.OriginationFee)
			copy(dAtA[i:], x.OriginationFee)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OriginationFee)))
			i--
			dAtA[i] = 0x5a
		}
		if x.RequestFee != nil {
			encoded, err := options.Marshal(x.RequestFee)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if x.BorrowAmount != nil {
			encoded, err := options.Marshal(x.BorrowAmount)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.PoolId) > 0 {
			i -= len(x.PoolId)
			copy(dAtA[i:], x.PoolId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PoolId)))
			i--
			dAtA[i] = 0x42
		}
		if x.FinalTimeout != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.FinalTimeout))
			i--
			dAtA[i] = 0x38
		}
		if x.MaturityTime != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaturityTime))
			i--
			dAtA[i] = 0x30
		}
		if len(x.Dcm) > 0 {
			i -= len(x.Dcm)
			copy(dAtA[i:], x.Dcm)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Dcm)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.BorrowerAuthPubKey) > 0 {
			i -= len(x.BorrowerAuthPubKey)
			copy(dAtA[i:], x.BorrowerAuthPubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowerAuthPubKey)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.BorrowerPubKey) > 0 {
			i -= len(x.BorrowerPubKey)
			copy(dAtA[i:], x.BorrowerPubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowerPubKey)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Borrower) > 0 {
			i -= len(x.Borrower)
			copy(dAtA[i:], x.Borrower)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Borrower)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.VaultAddress) > 0 {
			i -= len(x.VaultAddress)
			copy(dAtA[i:], x.VaultAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.VaultAddress)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Loan)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Loan: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Loan: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VaultAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Borrower", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Borrower = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowerPubKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowerPubKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowerAuthPubKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowerAuthPubKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Dcm", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Dcm = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaturityTime", wireType)
				}
				x.MaturityTime = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaturityTime |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FinalTimeout", wireType)
				}
				x.FinalTimeout = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.FinalTimeout |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PoolId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowAmount", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.BorrowAmount == nil {
					x.BorrowAmount = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.BorrowAmount); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequestFee", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequestFee == nil {
					x.RequestFee = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequestFee); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OriginationFee", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OriginationFee = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Interest", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Interest = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProtocolFee", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ProtocolFee = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 14:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Maturity", wireType)
				}
				x.Maturity = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Maturity |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 15:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowApr", wireType)
				}
				x.BorrowApr = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BorrowApr |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 16:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StartBorrowIndex", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StartBorrowIndex = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 17:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidationPrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LiquidationPrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 18:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DlcEventId", wireType)
				}
				x.DlcEventId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.DlcEventId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 19:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Authorizations", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Authorizations = append(x.Authorizations, &Authorization{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Authorizations[len(x.Authorizations)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 20:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollateralAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollateralAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 21:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidationId", wireType)
				}
				x.LiquidationId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LiquidationId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 22:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Referrer", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Referrer == nil {
					x.Referrer = &Referrer{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Referrer); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 23:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CreateAt == nil {
					x.CreateAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CreateAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 24:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DisburseAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.DisburseAt == nil {
					x.DisburseAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.DisburseAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 25:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= LoanStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Referrer                     protoreflect.MessageDescriptor
	fd_Referrer_name                protoreflect.FieldDescriptor
	fd_Referrer_referral_code       protoreflect.FieldDescriptor
	fd_Referrer_address             protoreflect.FieldDescriptor
	fd_Referrer_referral_fee_factor protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_Referrer = File_bitway_lending_lending_proto.Messages().ByName("Referrer")
	fd_Referrer_name = md_Referrer.Fields().ByName("name")
	fd_Referrer_referral_code = md_Referrer.Fields().ByName("referral_code")
	fd_Referrer_address = md_Referrer.Fields().ByName("address")
	fd_Referrer_referral_fee_factor = md_Referrer.Fields().ByName("referral_fee_factor")
}

var _ protoreflect.Message = (*fastReflection_Referrer)(nil)

type fastReflection_Referrer Referrer

func (x *Referrer) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Referrer)(x)
}

func (x *Referrer) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Referrer_messageType fastReflection_Referrer_messageType
var _ protoreflect.MessageType = fastReflection_Referrer_messageType{}

type fastReflection_Referrer_messageType struct{}

func (x fastReflection_Referrer_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Referrer)(nil)
}
func (x fastReflection_Referrer_messageType) New() protoreflect.Message {
	return new(fastReflection_Referrer)
}
func (x fastReflection_Referrer_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Referrer
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Referrer) Descriptor() protoreflect.MessageDescriptor {
	return md_Referrer
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Referrer) Type() protoreflect.MessageType {
	return _fastReflection_Referrer_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Referrer) New() protoreflect.Message {
	return new(fastReflection_Referrer)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Referrer) Interface() protoreflect.ProtoMessage {
	return (*Referrer)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Referrer) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Name != "" {
		value := protoreflect.ValueOfString(x.Name)
		if !f(fd_Referrer_name, value) {
			return
		}
	}
	if x.ReferralCode != "" {
		value := protoreflect.ValueOfString(x.ReferralCode)
		if !f(fd_Referrer_referral_code, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_Referrer_address, value) {
			return
		}
	}
	if x.ReferralFeeFactor != "" {
		value := protoreflect.ValueOfString(x.ReferralFeeFactor)
		if !f(fd_Referrer_referral_fee_factor, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Referrer) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.Referrer.name":
		return x.Name != ""
	case "bitway.lending.Referrer.referral_code":
		return x.ReferralCode != ""
	case "bitway.lending.Referrer.address":
		return x.Address != ""
	case "bitway.lending.Referrer.referral_fee_factor":
		return x.ReferralFeeFactor != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Referrer"))
		}
		panic(fmt.Errorf("message bitway.lending.Referrer does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Referrer) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.Referrer.name":
		x.Name = ""
	case "bitway.lending.Referrer.referral_code":
		x.ReferralCode = ""
	case "bitway.lending.Referrer.address":
		x.Address = ""
	case "bitway.lending.Referrer.referral_fee_factor":
		x.ReferralFeeFactor = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Referrer"))
		}
		panic(fmt.Errorf("message bitway.lending.Referrer does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Referrer) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.Referrer.name":
		value := x.Name
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Referrer.referral_code":
		value := x.ReferralCode
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Referrer.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Referrer.referral_fee_factor":
		value := x.ReferralFeeFactor
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Referrer"))
		}
		panic(fmt.Errorf("message bitway.lending.Referrer does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Referrer) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.Referrer.name":
		x.Name = value.Interface().(string)
	case "bitway.lending.Referrer.referral_code":
		x.ReferralCode = value.Interface().(string)
	case "bitway.lending.Referrer.address":
		x.Address = value.Interface().(string)
	case "bitway.lending.Referrer.referral_fee_factor":
		x.ReferralFeeFactor = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Referrer"))
		}
		panic(fmt.Errorf("message bitway.lending.Referrer does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Referrer) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Referrer.name":
		panic(fmt.Errorf("field name of message bitway.lending.Referrer is not mutable"))
	case "bitway.lending.Referrer.referral_code":
		panic(fmt.Errorf("field referral_code of message bitway.lending.Referrer is not mutable"))
	case "bitway.lending.Referrer.address":
		panic(fmt.Errorf("field address of message bitway.lending.Referrer is not mutable"))
	case "bitway.lending.Referrer.referral_fee_factor":
		panic(fmt.Errorf("field referral_fee_factor of message bitway.lending.Referrer is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Referrer"))
		}
		panic(fmt.Errorf("message bitway.lending.Referrer does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Referrer) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Referrer.name":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Referrer.referral_code":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Referrer.address":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Referrer.referral_fee_factor":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Referrer"))
		}
		panic(fmt.Errorf("message bitway.lending.Referrer does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Referrer) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.Referrer", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Referrer) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Referrer) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Referrer) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Referrer) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Referrer)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Name)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReferralCode)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReferralFeeFactor)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Referrer)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ReferralFeeFactor) > 0 {
			i -= len(x.ReferralFeeFactor)
			copy(dAtA[i:], x.ReferralFeeFactor)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReferralFeeFactor)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.ReferralCode) > 0 {
			i -= len(x.ReferralCode)
			copy(dAtA[i:], x.ReferralCode)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReferralCode)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Name) > 0 {
			i -= len(x.Name)
			copy(dAtA[i:], x.Name)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Name)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Referrer)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Referrer: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Referrer: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Name = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReferralCode", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReferralCode = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReferralFeeFactor", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReferralFeeFactor = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_LeafScript               protoreflect.MessageDescriptor
	fd_LeafScript_script        protoreflect.FieldDescriptor
	fd_LeafScript_control_block protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_LeafScript = File_bitway_lending_lending_proto.Messages().ByName("LeafScript")
	fd_LeafScript_script = md_LeafScript.Fields().ByName("script")
	fd_LeafScript_control_block = md_LeafScript.Fields().ByName("control_block")
}

var _ protoreflect.Message = (*fastReflection_LeafScript)(nil)

type fastReflection_LeafScript LeafScript

func (x *LeafScript) ProtoReflect() protoreflect.Message {
	return (*fastReflection_LeafScript)(x)
}

func (x *LeafScript) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_LeafScript_messageType fastReflection_LeafScript_messageType
var _ protoreflect.MessageType = fastReflection_LeafScript_messageType{}

type fastReflection_LeafScript_messageType struct{}

func (x fastReflection_LeafScript_messageType) Zero() protoreflect.Message {
	return (*fastReflection_LeafScript)(nil)
}
func (x fastReflection_LeafScript_messageType) New() protoreflect.Message {
	return new(fastReflection_LeafScript)
}
func (x fastReflection_LeafScript_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_LeafScript
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_LeafScript) Descriptor() protoreflect.MessageDescriptor {
	return md_LeafScript
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_LeafScript) Type() protoreflect.MessageType {
	return _fastReflection_LeafScript_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_LeafScript) New() protoreflect.Message {
	return new(fastReflection_LeafScript)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_LeafScript) Interface() protoreflect.ProtoMessage {
	return (*LeafScript)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_LeafScript) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Script != "" {
		value := protoreflect.ValueOfString(x.Script)
		if !f(fd_LeafScript_script, value) {
			return
		}
	}
	if x.ControlBlock != "" {
		value := protoreflect.ValueOfString(x.ControlBlock)
		if !f(fd_LeafScript_control_block, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_LeafScript) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.LeafScript.script":
		return x.Script != ""
	case "bitway.lending.LeafScript.control_block":
		return x.ControlBlock != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LeafScript"))
		}
		panic(fmt.Errorf("message bitway.lending.LeafScript does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafScript) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.LeafScript.script":
		x.Script = ""
	case "bitway.lending.LeafScript.control_block":
		x.ControlBlock = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LeafScript"))
		}
		panic(fmt.Errorf("message bitway.lending.LeafScript does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_LeafScript) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.LeafScript.script":
		value := x.Script
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LeafScript.control_block":
		value := x.ControlBlock
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LeafScript"))
		}
		panic(fmt.Errorf("message bitway.lending.LeafScript does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafScript) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.LeafScript.script":
		x.Script = value.Interface().(string)
	case "bitway.lending.LeafScript.control_block":
		x.ControlBlock = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LeafScript"))
		}
		panic(fmt.Errorf("message bitway.lending.LeafScript does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafScript) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.LeafScript.script":
		panic(fmt.Errorf("field script of message bitway.lending.LeafScript is not mutable"))
	case "bitway.lending.LeafScript.control_block":
		panic(fmt.Errorf("field control_block of message bitway.lending.LeafScript is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LeafScript"))
		}
		panic(fmt.Errorf("message bitway.lending.LeafScript does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_LeafScript) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.LeafScript.script":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LeafScript.control_block":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LeafScript"))
		}
		panic(fmt.Errorf("message bitway.lending.LeafScript does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_LeafScript) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.LeafScript", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_LeafScript) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LeafScript) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_LeafScript) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_LeafScript) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*LeafScript)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Script)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ControlBlock)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*LeafScript)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ControlBlock) > 0 {
			i -= len(x.ControlBlock)
			copy(dAtA[i:], x.ControlBlock)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ControlBlock)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Script) > 0 {
			i -= len(x.Script)
			copy(dAtA[i:], x.Script)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Script)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*LeafScript)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LeafScript: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LeafScript: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Script = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ControlBlock", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ControlBlock = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_CetInfo                 protoreflect.MessageDescriptor
	fd_CetInfo_event_id        protoreflect.FieldDescriptor
	fd_CetInfo_outcome_index   protoreflect.FieldDescriptor
	fd_CetInfo_signature_point protoreflect.FieldDescriptor
	fd_CetInfo_script          protoreflect.FieldDescriptor
	fd_CetInfo_sighash_type    protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_CetInfo = File_bitway_lending_lending_proto.Messages().ByName("CetInfo")
	fd_CetInfo_event_id = md_CetInfo.Fields().ByName("event_id")
	fd_CetInfo_outcome_index = md_CetInfo.Fields().ByName("outcome_index")
	fd_CetInfo_signature_point = md_CetInfo.Fields().ByName("signature_point")
	fd_CetInfo_script = md_CetInfo.Fields().ByName("script")
	fd_CetInfo_sighash_type = md_CetInfo.Fields().ByName("sighash_type")
}

var _ protoreflect.Message = (*fastReflection_CetInfo)(nil)

type fastReflection_CetInfo CetInfo

func (x *CetInfo) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CetInfo)(x)
}

func (x *CetInfo) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CetInfo_messageType fastReflection_CetInfo_messageType
var _ protoreflect.MessageType = fastReflection_CetInfo_messageType{}

type fastReflection_CetInfo_messageType struct{}

func (x fastReflection_CetInfo_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CetInfo)(nil)
}
func (x fastReflection_CetInfo_messageType) New() protoreflect.Message {
	return new(fastReflection_CetInfo)
}
func (x fastReflection_CetInfo_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CetInfo
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CetInfo) Descriptor() protoreflect.MessageDescriptor {
	return md_CetInfo
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CetInfo) Type() protoreflect.MessageType {
	return _fastReflection_CetInfo_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CetInfo) New() protoreflect.Message {
	return new(fastReflection_CetInfo)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CetInfo) Interface() protoreflect.ProtoMessage {
	return (*CetInfo)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CetInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.EventId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.EventId)
		if !f(fd_CetInfo_event_id, value) {
			return
		}
	}
	if x.OutcomeIndex != uint32(0) {
		value := protoreflect.ValueOfUint32(x.OutcomeIndex)
		if !f(fd_CetInfo_outcome_index, value) {
			return
		}
	}
	if x.SignaturePoint != "" {
		value := protoreflect.ValueOfString(x.SignaturePoint)
		if !f(fd_CetInfo_signature_point, value) {
			return
		}
	}
	if x.Script != nil {
		value := protoreflect.ValueOfMessage(x.Script.ProtoReflect())
		if !f(fd_CetInfo_script, value) {
			return
		}
	}
	if x.SighashType != uint32(0) {
		value := protoreflect.ValueOfUint32(x.SighashType)
		if !f(fd_CetInfo_sighash_type, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CetInfo) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.CetInfo.event_id":
		return x.EventId != uint64(0)
	case "bitway.lending.CetInfo.outcome_index":
		return x.OutcomeIndex != uint32(0)
	case "bitway.lending.CetInfo.signature_point":
		return x.SignaturePoint != ""
	case "bitway.lending.CetInfo.script":
		return x.Script != nil
	case "bitway.lending.CetInfo.sighash_type":
		return x.SighashType != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.CetInfo"))
		}
		panic(fmt.Errorf("message bitway.lending.CetInfo does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CetInfo) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.CetInfo.event_id":
		x.EventId = uint64(0)
	case "bitway.lending.CetInfo.outcome_index":
		x.OutcomeIndex = uint32(0)
	case "bitway.lending.CetInfo.signature_point":
		x.SignaturePoint = ""
	case "bitway.lending.CetInfo.script":
		x.Script = nil
	case "bitway.lending.CetInfo.sighash_type":
		x.SighashType = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.CetInfo"))
		}
		panic(fmt.Errorf("message bitway.lending.CetInfo does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CetInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.CetInfo.event_id":
		value := x.EventId
		return protoreflect.ValueOfUint64(value)
	case "bitway.lending.CetInfo.outcome_index":
		value := x.OutcomeIndex
		return protoreflect.ValueOfUint32(value)
	case "bitway.lending.CetInfo.signature_point":
		value := x.SignaturePoint
		return protoreflect.ValueOfString(value)
	case "bitway.lending.CetInfo.script":
		value := x.Script
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.CetInfo.sighash_type":
		value := x.SighashType
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.CetInfo"))
		}
		panic(fmt.Errorf("message bitway.lending.CetInfo does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CetInfo) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.CetInfo.event_id":
		x.EventId = value.Uint()
	case "bitway.lending.CetInfo.outcome_index":
		x.OutcomeIndex = uint32(value.Uint())
	case "bitway.lending.CetInfo.signature_point":
		x.SignaturePoint = value.Interface().(string)
	case "bitway.lending.CetInfo.script":
		x.Script = value.Message().Interface().(*LeafScript)
	case "bitway.lending.CetInfo.sighash_type":
		x.SighashType = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.CetInfo"))
		}
		panic(fmt.Errorf("message bitway.lending.CetInfo does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CetInfo) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.CetInfo.script":
		if x.Script == nil {
			x.Script = new(LeafScript)
		}
		return protoreflect.ValueOfMessage(x.Script.ProtoReflect())
	case "bitway.lending.CetInfo.event_id":
		panic(fmt.Errorf("field event_id of message bitway.lending.CetInfo is not mutable"))
	case "bitway.lending.CetInfo.outcome_index":
		panic(fmt.Errorf("field outcome_index of message bitway.lending.CetInfo is not mutable"))
	case "bitway.lending.CetInfo.signature_point":
		panic(fmt.Errorf("field signature_point of message bitway.lending.CetInfo is not mutable"))
	case "bitway.lending.CetInfo.sighash_type":
		panic(fmt.Errorf("field sighash_type of message bitway.lending.CetInfo is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.CetInfo"))
		}
		panic(fmt.Errorf("message bitway.lending.CetInfo does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CetInfo) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.CetInfo.event_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "bitway.lending.CetInfo.outcome_index":
		return protoreflect.ValueOfUint32(uint32(0))
	case "bitway.lending.CetInfo.signature_point":
		return protoreflect.ValueOfString("")
	case "bitway.lending.CetInfo.script":
		m := new(LeafScript)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.CetInfo.sighash_type":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.CetInfo"))
		}
		panic(fmt.Errorf("message bitway.lending.CetInfo does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CetInfo) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.CetInfo", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CetInfo) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CetInfo) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CetInfo) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CetInfo) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CetInfo)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.EventId != 0 {
			n += 1 + runtime.Sov(uint64(x.EventId))
		}
		if x.OutcomeIndex != 0 {
			n += 1 + runtime.Sov(uint64(x.OutcomeIndex))
		}
		l = len(x.SignaturePoint)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Script != nil {
			l = options.Size(x.Script)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.SighashType != 0 {
			n += 1 + runtime.Sov(uint64(x.SighashType))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CetInfo)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.SighashType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SighashType))
			i--
			dAtA[i] = 0x28
		}
		if x.Script != nil {
			encoded, err := options.Marshal(x.Script)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.SignaturePoint) > 0 {
			i -= len(x.SignaturePoint)
			copy(dAtA[i:], x.SignaturePoint)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SignaturePoint)))
			i--
			dAtA[i] = 0x1a
		}
		if x.OutcomeIndex != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OutcomeIndex))
			i--
			dAtA[i] = 0x10
		}
		if x.EventId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.EventId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CetInfo)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CetInfo: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
				}
				x.EventId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.EventId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OutcomeIndex", wireType)
				}
				x.OutcomeIndex = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OutcomeIndex |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SignaturePoint", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SignaturePoint = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Script == nil {
					x.Script = &LeafScript{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Script); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SighashType", wireType)
				}
				x.SighashType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SighashType |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_LiquidationCet_2_list)(nil)

type _LiquidationCet_2_list struct {
	list *[]string
}

func (x *_LiquidationCet_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_LiquidationCet_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_LiquidationCet_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_LiquidationCet_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_LiquidationCet_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message LiquidationCet at list field BorrowerAdaptorSignatures as it is not of Message kind"))
}

func (x *_LiquidationCet_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_LiquidationCet_2_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_LiquidationCet_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_LiquidationCet_3_list)(nil)

type _LiquidationCet_3_list struct {
	list *[]string
}

func (x *_LiquidationCet_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_LiquidationCet_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_LiquidationCet_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_LiquidationCet_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_LiquidationCet_3_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message LiquidationCet at list field BorrowerAdaptedSignatures as it is not of Message kind"))
}

func (x *_LiquidationCet_3_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_LiquidationCet_3_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_LiquidationCet_3_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_LiquidationCet_4_list)(nil)

type _LiquidationCet_4_list struct {
	list *[]string
}

func (x *_LiquidationCet_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_LiquidationCet_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_LiquidationCet_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_LiquidationCet_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_LiquidationCet_4_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message LiquidationCet at list field DcmSignatures as it is not of Message kind"))
}

func (x *_LiquidationCet_4_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_LiquidationCet_4_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_LiquidationCet_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_LiquidationCet                             protoreflect.MessageDescriptor
	fd_LiquidationCet_tx                          protoreflect.FieldDescriptor
	fd_LiquidationCet_borrower_adaptor_signatures protoreflect.FieldDescriptor
	fd_LiquidationCet_borrower_adapted_signatures protoreflect.FieldDescriptor
	fd_LiquidationCet_dcm_signatures              protoreflect.FieldDescriptor
	fd_LiquidationCet_signed_tx_hex               protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_LiquidationCet = File_bitway_lending_lending_proto.Messages().ByName("LiquidationCet")
	fd_LiquidationCet_tx = md_LiquidationCet.Fields().ByName("tx")
	fd_LiquidationCet_borrower_adaptor_signatures = md_LiquidationCet.Fields().ByName("borrower_adaptor_signatures")
	fd_LiquidationCet_borrower_adapted_signatures = md_LiquidationCet.Fields().ByName("borrower_adapted_signatures")
	fd_LiquidationCet_dcm_signatures = md_LiquidationCet.Fields().ByName("dcm_signatures")
	fd_LiquidationCet_signed_tx_hex = md_LiquidationCet.Fields().ByName("signed_tx_hex")
}

var _ protoreflect.Message = (*fastReflection_LiquidationCet)(nil)

type fastReflection_LiquidationCet LiquidationCet

func (x *LiquidationCet) ProtoReflect() protoreflect.Message {
	return (*fastReflection_LiquidationCet)(x)
}

func (x *LiquidationCet) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_LiquidationCet_messageType fastReflection_LiquidationCet_messageType
var _ protoreflect.MessageType = fastReflection_LiquidationCet_messageType{}

type fastReflection_LiquidationCet_messageType struct{}

func (x fastReflection_LiquidationCet_messageType) Zero() protoreflect.Message {
	return (*fastReflection_LiquidationCet)(nil)
}
func (x fastReflection_LiquidationCet_messageType) New() protoreflect.Message {
	return new(fastReflection_LiquidationCet)
}
func (x fastReflection_LiquidationCet_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_LiquidationCet
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_LiquidationCet) Descriptor() protoreflect.MessageDescriptor {
	return md_LiquidationCet
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_LiquidationCet) Type() protoreflect.MessageType {
	return _fastReflection_LiquidationCet_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_LiquidationCet) New() protoreflect.Message {
	return new(fastReflection_LiquidationCet)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_LiquidationCet) Interface() protoreflect.ProtoMessage {
	return (*LiquidationCet)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_LiquidationCet) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Tx != "" {
		value := protoreflect.ValueOfString(x.Tx)
		if !f(fd_LiquidationCet_tx, value) {
			return
		}
	}
	if len(x.BorrowerAdaptorSignatures) != 0 {
		value := protoreflect.ValueOfList(&_LiquidationCet_2_list{list: &x.BorrowerAdaptorSignatures})
		if !f(fd_LiquidationCet_borrower_adaptor_signatures, value) {
			return
		}
	}
	if len(x.BorrowerAdaptedSignatures) != 0 {
		value := protoreflect.ValueOfList(&_LiquidationCet_3_list{list: &x.BorrowerAdaptedSignatures})
		if !f(fd_LiquidationCet_borrower_adapted_signatures, value) {
			return
		}
	}
	if len(x.DcmSignatures) != 0 {
		value := protoreflect.ValueOfList(&_LiquidationCet_4_list{list: &x.DcmSignatures})
		if !f(fd_LiquidationCet_dcm_signatures, value) {
			return
		}
	}
	if x.SignedTxHex != "" {
		value := protoreflect.ValueOfString(x.SignedTxHex)
		if !f(fd_LiquidationCet_signed_tx_hex, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_LiquidationCet) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.LiquidationCet.tx":
		return x.Tx != ""
	case "bitway.lending.LiquidationCet.borrower_adaptor_signatures":
		return len(x.BorrowerAdaptorSignatures) != 0
	case "bitway.lending.LiquidationCet.borrower_adapted_signatures":
		return len(x.BorrowerAdaptedSignatures) != 0
	case "bitway.lending.LiquidationCet.dcm_signatures":
		return len(x.DcmSignatures) != 0
	case "bitway.lending.LiquidationCet.signed_tx_hex":
		return x.SignedTxHex != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LiquidationCet"))
		}
		panic(fmt.Errorf("message bitway.lending.LiquidationCet does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidationCet) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.LiquidationCet.tx":
		x.Tx = ""
	case "bitway.lending.LiquidationCet.borrower_adaptor_signatures":
		x.BorrowerAdaptorSignatures = nil
	case "bitway.lending.LiquidationCet.borrower_adapted_signatures":
		x.BorrowerAdaptedSignatures = nil
	case "bitway.lending.LiquidationCet.dcm_signatures":
		x.DcmSignatures = nil
	case "bitway.lending.LiquidationCet.signed_tx_hex":
		x.SignedTxHex = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LiquidationCet"))
		}
		panic(fmt.Errorf("message bitway.lending.LiquidationCet does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_LiquidationCet) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.LiquidationCet.tx":
		value := x.Tx
		return protoreflect.ValueOfString(value)
	case "bitway.lending.LiquidationCet.borrower_adaptor_signatures":
		if len(x.BorrowerAdaptorSignatures) == 0 {
			return protoreflect.ValueOfList(&_LiquidationCet_2_list{})
		}
		listValue := &_LiquidationCet_2_list{list: &x.BorrowerAdaptorSignatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.LiquidationCet.borrower_adapted_signatures":
		if len(x.BorrowerAdaptedSignatures) == 0 {
			return protoreflect.ValueOfList(&_LiquidationCet_3_list{})
		}
		listValue := &_LiquidationCet_3_list{list: &x.BorrowerAdaptedSignatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.LiquidationCet.dcm_signatures":
		if len(x.DcmSignatures) == 0 {
			return protoreflect.ValueOfList(&_LiquidationCet_4_list{})
		}
		listValue := &_LiquidationCet_4_list{list: &x.DcmSignatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.LiquidationCet.signed_tx_hex":
		value := x.SignedTxHex
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LiquidationCet"))
		}
		panic(fmt.Errorf("message bitway.lending.LiquidationCet does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidationCet) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.LiquidationCet.tx":
		x.Tx = value.Interface().(string)
	case "bitway.lending.LiquidationCet.borrower_adaptor_signatures":
		lv := value.List()
		clv := lv.(*_LiquidationCet_2_list)
		x.BorrowerAdaptorSignatures = *clv.list
	case "bitway.lending.LiquidationCet.borrower_adapted_signatures":
		lv := value.List()
		clv := lv.(*_LiquidationCet_3_list)
		x.BorrowerAdaptedSignatures = *clv.list
	case "bitway.lending.LiquidationCet.dcm_signatures":
		lv := value.List()
		clv := lv.(*_LiquidationCet_4_list)
		x.DcmSignatures = *clv.list
	case "bitway.lending.LiquidationCet.signed_tx_hex":
		x.SignedTxHex = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LiquidationCet"))
		}
		panic(fmt.Errorf("message bitway.lending.LiquidationCet does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidationCet) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.LiquidationCet.borrower_adaptor_signatures":
		if x.BorrowerAdaptorSignatures == nil {
			x.BorrowerAdaptorSignatures = []string{}
		}
		value := &_LiquidationCet_2_list{list: &x.BorrowerAdaptorSignatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.LiquidationCet.borrower_adapted_signatures":
		if x.BorrowerAdaptedSignatures == nil {
			x.BorrowerAdaptedSignatures = []string{}
		}
		value := &_LiquidationCet_3_list{list: &x.BorrowerAdaptedSignatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.LiquidationCet.dcm_signatures":
		if x.DcmSignatures == nil {
			x.DcmSignatures = []string{}
		}
		value := &_LiquidationCet_4_list{list: &x.DcmSignatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.LiquidationCet.tx":
		panic(fmt.Errorf("field tx of message bitway.lending.LiquidationCet is not mutable"))
	case "bitway.lending.LiquidationCet.signed_tx_hex":
		panic(fmt.Errorf("field signed_tx_hex of message bitway.lending.LiquidationCet is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LiquidationCet"))
		}
		panic(fmt.Errorf("message bitway.lending.LiquidationCet does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_LiquidationCet) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.LiquidationCet.tx":
		return protoreflect.ValueOfString("")
	case "bitway.lending.LiquidationCet.borrower_adaptor_signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_LiquidationCet_2_list{list: &list})
	case "bitway.lending.LiquidationCet.borrower_adapted_signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_LiquidationCet_3_list{list: &list})
	case "bitway.lending.LiquidationCet.dcm_signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_LiquidationCet_4_list{list: &list})
	case "bitway.lending.LiquidationCet.signed_tx_hex":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.LiquidationCet"))
		}
		panic(fmt.Errorf("message bitway.lending.LiquidationCet does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_LiquidationCet) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.LiquidationCet", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_LiquidationCet) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidationCet) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_LiquidationCet) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_LiquidationCet) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*LiquidationCet)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Tx)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.BorrowerAdaptorSignatures) > 0 {
			for _, s := range x.BorrowerAdaptorSignatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.BorrowerAdaptedSignatures) > 0 {
			for _, s := range x.BorrowerAdaptedSignatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.DcmSignatures) > 0 {
			for _, s := range x.DcmSignatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.SignedTxHex)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*LiquidationCet)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SignedTxHex) > 0 {
			i -= len(x.SignedTxHex)
			copy(dAtA[i:], x.SignedTxHex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SignedTxHex)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.DcmSignatures) > 0 {
			for iNdEx := len(x.DcmSignatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.DcmSignatures[iNdEx])
				copy(dAtA[i:], x.DcmSignatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DcmSignatures[iNdEx])))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.BorrowerAdaptedSignatures) > 0 {
			for iNdEx := len(x.BorrowerAdaptedSignatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.BorrowerAdaptedSignatures[iNdEx])
				copy(dAtA[i:], x.BorrowerAdaptedSignatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowerAdaptedSignatures[iNdEx])))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.BorrowerAdaptorSignatures) > 0 {
			for iNdEx := len(x.BorrowerAdaptorSignatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.BorrowerAdaptorSignatures[iNdEx])
				copy(dAtA[i:], x.BorrowerAdaptorSignatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowerAdaptorSignatures[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.Tx) > 0 {
			i -= len(x.Tx)
			copy(dAtA[i:], x.Tx)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Tx)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*LiquidationCet)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LiquidationCet: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LiquidationCet: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Tx = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowerAdaptorSignatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowerAdaptorSignatures = append(x.BorrowerAdaptorSignatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowerAdaptedSignatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowerAdaptedSignatures = append(x.BorrowerAdaptedSignatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DcmSignatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DcmSignatures = append(x.DcmSignatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SignedTxHex", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SignedTxHex = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_RepaymentCet_2_list)(nil)

type _RepaymentCet_2_list struct {
	list *[]string
}

func (x *_RepaymentCet_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_RepaymentCet_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_RepaymentCet_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_RepaymentCet_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_RepaymentCet_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message RepaymentCet at list field DcmAdaptorSignatures as it is not of Message kind"))
}

func (x *_RepaymentCet_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_RepaymentCet_2_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_RepaymentCet_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_RepaymentCet_3_list)(nil)

type _RepaymentCet_3_list struct {
	list *[]string
}

func (x *_RepaymentCet_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_RepaymentCet_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_RepaymentCet_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_RepaymentCet_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_RepaymentCet_3_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message RepaymentCet at list field DcmAdaptedSignatures as it is not of Message kind"))
}

func (x *_RepaymentCet_3_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_RepaymentCet_3_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_RepaymentCet_3_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_RepaymentCet_4_list)(nil)

type _RepaymentCet_4_list struct {
	list *[]string
}

func (x *_RepaymentCet_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_RepaymentCet_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_RepaymentCet_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_RepaymentCet_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_RepaymentCet_4_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message RepaymentCet at list field BorrowerSignatures as it is not of Message kind"))
}

func (x *_RepaymentCet_4_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_RepaymentCet_4_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_RepaymentCet_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_RepaymentCet                        protoreflect.MessageDescriptor
	fd_RepaymentCet_tx                     protoreflect.FieldDescriptor
	fd_RepaymentCet_dcm_adaptor_signatures protoreflect.FieldDescriptor
	fd_RepaymentCet_dcm_adapted_signatures protoreflect.FieldDescriptor
	fd_RepaymentCet_borrower_signatures    protoreflect.FieldDescriptor
	fd_RepaymentCet_signed_tx_hex          protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_RepaymentCet = File_bitway_lending_lending_proto.Messages().ByName("RepaymentCet")
	fd_RepaymentCet_tx = md_RepaymentCet.Fields().ByName("tx")
	fd_RepaymentCet_dcm_adaptor_signatures = md_RepaymentCet.Fields().ByName("dcm_adaptor_signatures")
	fd_RepaymentCet_dcm_adapted_signatures = md_RepaymentCet.Fields().ByName("dcm_adapted_signatures")
	fd_RepaymentCet_borrower_signatures = md_RepaymentCet.Fields().ByName("borrower_signatures")
	fd_RepaymentCet_signed_tx_hex = md_RepaymentCet.Fields().ByName("signed_tx_hex")
}

var _ protoreflect.Message = (*fastReflection_RepaymentCet)(nil)

type fastReflection_RepaymentCet RepaymentCet

func (x *RepaymentCet) ProtoReflect() protoreflect.Message {
	return (*fastReflection_RepaymentCet)(x)
}

func (x *RepaymentCet) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_RepaymentCet_messageType fastReflection_RepaymentCet_messageType
var _ protoreflect.MessageType = fastReflection_RepaymentCet_messageType{}

type fastReflection_RepaymentCet_messageType struct{}

func (x fastReflection_RepaymentCet_messageType) Zero() protoreflect.Message {
	return (*fastReflection_RepaymentCet)(nil)
}
func (x fastReflection_RepaymentCet_messageType) New() protoreflect.Message {
	return new(fastReflection_RepaymentCet)
}
func (x fastReflection_RepaymentCet_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_RepaymentCet
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_RepaymentCet) Descriptor() protoreflect.MessageDescriptor {
	return md_RepaymentCet
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_RepaymentCet) Type() protoreflect.MessageType {
	return _fastReflection_RepaymentCet_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_RepaymentCet) New() protoreflect.Message {
	return new(fastReflection_RepaymentCet)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_RepaymentCet) Interface() protoreflect.ProtoMessage {
	return (*RepaymentCet)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_RepaymentCet) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Tx != "" {
		value := protoreflect.ValueOfString(x.Tx)
		if !f(fd_RepaymentCet_tx, value) {
			return
		}
	}
	if len(x.DcmAdaptorSignatures) != 0 {
		value := protoreflect.ValueOfList(&_RepaymentCet_2_list{list: &x.DcmAdaptorSignatures})
		if !f(fd_RepaymentCet_dcm_adaptor_signatures, value) {
			return
		}
	}
	if len(x.DcmAdaptedSignatures) != 0 {
		value := protoreflect.ValueOfList(&_RepaymentCet_3_list{list: &x.DcmAdaptedSignatures})
		if !f(fd_RepaymentCet_dcm_adapted_signatures, value) {
			return
		}
	}
	if len(x.BorrowerSignatures) != 0 {
		value := protoreflect.ValueOfList(&_RepaymentCet_4_list{list: &x.BorrowerSignatures})
		if !f(fd_RepaymentCet_borrower_signatures, value) {
			return
		}
	}
	if x.SignedTxHex != "" {
		value := protoreflect.ValueOfString(x.SignedTxHex)
		if !f(fd_RepaymentCet_signed_tx_hex, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_RepaymentCet) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.RepaymentCet.tx":
		return x.Tx != ""
	case "bitway.lending.RepaymentCet.dcm_adaptor_signatures":
		return len(x.DcmAdaptorSignatures) != 0
	case "bitway.lending.RepaymentCet.dcm_adapted_signatures":
		return len(x.DcmAdaptedSignatures) != 0
	case "bitway.lending.RepaymentCet.borrower_signatures":
		return len(x.BorrowerSignatures) != 0
	case "bitway.lending.RepaymentCet.signed_tx_hex":
		return x.SignedTxHex != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.RepaymentCet"))
		}
		panic(fmt.Errorf("message bitway.lending.RepaymentCet does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RepaymentCet) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.RepaymentCet.tx":
		x.Tx = ""
	case "bitway.lending.RepaymentCet.dcm_adaptor_signatures":
		x.DcmAdaptorSignatures = nil
	case "bitway.lending.RepaymentCet.dcm_adapted_signatures":
		x.DcmAdaptedSignatures = nil
	case "bitway.lending.RepaymentCet.borrower_signatures":
		x.BorrowerSignatures = nil
	case "bitway.lending.RepaymentCet.signed_tx_hex":
		x.SignedTxHex = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.RepaymentCet"))
		}
		panic(fmt.Errorf("message bitway.lending.RepaymentCet does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_RepaymentCet) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.RepaymentCet.tx":
		value := x.Tx
		return protoreflect.ValueOfString(value)
	case "bitway.lending.RepaymentCet.dcm_adaptor_signatures":
		if len(x.DcmAdaptorSignatures) == 0 {
			return protoreflect.ValueOfList(&_RepaymentCet_2_list{})
		}
		listValue := &_RepaymentCet_2_list{list: &x.DcmAdaptorSignatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.RepaymentCet.dcm_adapted_signatures":
		if len(x.DcmAdaptedSignatures) == 0 {
			return protoreflect.ValueOfList(&_RepaymentCet_3_list{})
		}
		listValue := &_RepaymentCet_3_list{list: &x.DcmAdaptedSignatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.RepaymentCet.borrower_signatures":
		if len(x.BorrowerSignatures) == 0 {
			return protoreflect.ValueOfList(&_RepaymentCet_4_list{})
		}
		listValue := &_RepaymentCet_4_list{list: &x.BorrowerSignatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.RepaymentCet.signed_tx_hex":
		value := x.SignedTxHex
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.RepaymentCet"))
		}
		panic(fmt.Errorf("message bitway.lending.RepaymentCet does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RepaymentCet) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.RepaymentCet.tx":
		x.Tx = value.Interface().(string)
	case "bitway.lending.RepaymentCet.dcm_adaptor_signatures":
		lv := value.List()
		clv := lv.(*_RepaymentCet_2_list)
		x.DcmAdaptorSignatures = *clv.list
	case "bitway.lending.RepaymentCet.dcm_adapted_signatures":
		lv := value.List()
		clv := lv.(*_RepaymentCet_3_list)
		x.DcmAdaptedSignatures = *clv.list
	case "bitway.lending.RepaymentCet.borrower_signatures":
		lv := value.List()
		clv := lv.(*_RepaymentCet_4_list)
		x.BorrowerSignatures = *clv.list
	case "bitway.lending.RepaymentCet.signed_tx_hex":
		x.SignedTxHex = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.RepaymentCet"))
		}
		panic(fmt.Errorf("message bitway.lending.RepaymentCet does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RepaymentCet) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.RepaymentCet.dcm_adaptor_signatures":
		if x.DcmAdaptorSignatures == nil {
			x.DcmAdaptorSignatures = []string{}
		}
		value := &_RepaymentCet_2_list{list: &x.DcmAdaptorSignatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.RepaymentCet.dcm_adapted_signatures":
		if x.DcmAdaptedSignatures == nil {
			x.DcmAdaptedSignatures = []string{}
		}
		value := &_RepaymentCet_3_list{list: &x.DcmAdaptedSignatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.RepaymentCet.borrower_signatures":
		if x.BorrowerSignatures == nil {
			x.BorrowerSignatures = []string{}
		}
		value := &_RepaymentCet_4_list{list: &x.BorrowerSignatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.RepaymentCet.tx":
		panic(fmt.Errorf("field tx of message bitway.lending.RepaymentCet is not mutable"))
	case "bitway.lending.RepaymentCet.signed_tx_hex":
		panic(fmt.Errorf("field signed_tx_hex of message bitway.lending.RepaymentCet is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.RepaymentCet"))
		}
		panic(fmt.Errorf("message bitway.lending.RepaymentCet does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_RepaymentCet) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.RepaymentCet.tx":
		return protoreflect.ValueOfString("")
	case "bitway.lending.RepaymentCet.dcm_adaptor_signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_RepaymentCet_2_list{list: &list})
	case "bitway.lending.RepaymentCet.dcm_adapted_signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_RepaymentCet_3_list{list: &list})
	case "bitway.lending.RepaymentCet.borrower_signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_RepaymentCet_4_list{list: &list})
	case "bitway.lending.RepaymentCet.signed_tx_hex":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.RepaymentCet"))
		}
		panic(fmt.Errorf("message bitway.lending.RepaymentCet does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_RepaymentCet) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.RepaymentCet", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_RepaymentCet) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RepaymentCet) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_RepaymentCet) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_RepaymentCet) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*RepaymentCet)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Tx)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.DcmAdaptorSignatures) > 0 {
			for _, s := range x.DcmAdaptorSignatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.DcmAdaptedSignatures) > 0 {
			for _, s := range x.DcmAdaptedSignatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.BorrowerSignatures) > 0 {
			for _, s := range x.BorrowerSignatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.SignedTxHex)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*RepaymentCet)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SignedTxHex) > 0 {
			i -= len(x.SignedTxHex)
			copy(dAtA[i:], x.SignedTxHex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SignedTxHex)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.BorrowerSignatures) > 0 {
			for iNdEx := len(x.BorrowerSignatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.BorrowerSignatures[iNdEx])
				copy(dAtA[i:], x.BorrowerSignatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BorrowerSignatures[iNdEx])))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.DcmAdaptedSignatures) > 0 {
			for iNdEx := len(x.DcmAdaptedSignatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.DcmAdaptedSignatures[iNdEx])
				copy(dAtA[i:], x.DcmAdaptedSignatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DcmAdaptedSignatures[iNdEx])))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.DcmAdaptorSignatures) > 0 {
			for iNdEx := len(x.DcmAdaptorSignatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.DcmAdaptorSignatures[iNdEx])
				copy(dAtA[i:], x.DcmAdaptorSignatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DcmAdaptorSignatures[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.Tx) > 0 {
			i -= len(x.Tx)
			copy(dAtA[i:], x.Tx)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Tx)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*RepaymentCet)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RepaymentCet: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RepaymentCet: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Tx = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DcmAdaptorSignatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DcmAdaptorSignatures = append(x.DcmAdaptorSignatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DcmAdaptedSignatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DcmAdaptedSignatures = append(x.DcmAdaptedSignatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BorrowerSignatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BorrowerSignatures = append(x.BorrowerSignatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SignedTxHex", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SignedTxHex = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_DLCMeta_5_list)(nil)

type _DLCMeta_5_list struct {
	list *[]*btcbridge.UTXO
}

func (x *_DLCMeta_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_DLCMeta_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_DLCMeta_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*btcbridge.UTXO)
	(*x.list)[i] = concreteValue
}

func (x *_DLCMeta_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*btcbridge.UTXO)
	*x.list = append(*x.list, concreteValue)
}

func (x *_DLCMeta_5_list) AppendMutable() protoreflect.Value {
	v := new(btcbridge.UTXO)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_DLCMeta_5_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_DLCMeta_5_list) NewElement() protoreflect.Value {
	v := new(btcbridge.UTXO)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_DLCMeta_5_list) IsValid() bool {
	return x.list != nil
}

var (
	md_DLCMeta                         protoreflect.MessageDescriptor
	fd_DLCMeta_liquidation_cet         protoreflect.FieldDescriptor
	fd_DLCMeta_default_liquidation_cet protoreflect.FieldDescriptor
	fd_DLCMeta_repayment_cet           protoreflect.FieldDescriptor
	fd_DLCMeta_timeout_refund_tx       protoreflect.FieldDescriptor
	fd_DLCMeta_vault_utxos             protoreflect.FieldDescriptor
	fd_DLCMeta_internal_key            protoreflect.FieldDescriptor
	fd_DLCMeta_liquidation_script      protoreflect.FieldDescriptor
	fd_DLCMeta_repayment_script        protoreflect.FieldDescriptor
	fd_DLCMeta_timeout_refund_script   protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_DLCMeta = File_bitway_lending_lending_proto.Messages().ByName("DLCMeta")
	fd_DLCMeta_liquidation_cet = md_DLCMeta.Fields().ByName("liquidation_cet")
	fd_DLCMeta_default_liquidation_cet = md_DLCMeta.Fields().ByName("default_liquidation_cet")
	fd_DLCMeta_repayment_cet = md_DLCMeta.Fields().ByName("repayment_cet")
	fd_DLCMeta_timeout_refund_tx = md_DLCMeta.Fields().ByName("timeout_refund_tx")
	fd_DLCMeta_vault_utxos = md_DLCMeta.Fields().ByName("vault_utxos")
	fd_DLCMeta_internal_key = md_DLCMeta.Fields().ByName("internal_key")
	fd_DLCMeta_liquidation_script = md_DLCMeta.Fields().ByName("liquidation_script")
	fd_DLCMeta_repayment_script = md_DLCMeta.Fields().ByName("repayment_script")
	fd_DLCMeta_timeout_refund_script = md_DLCMeta.Fields().ByName("timeout_refund_script")
}

var _ protoreflect.Message = (*fastReflection_DLCMeta)(nil)

type fastReflection_DLCMeta DLCMeta

func (x *DLCMeta) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DLCMeta)(x)
}

func (x *DLCMeta) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DLCMeta_messageType fastReflection_DLCMeta_messageType
var _ protoreflect.MessageType = fastReflection_DLCMeta_messageType{}

type fastReflection_DLCMeta_messageType struct{}

func (x fastReflection_DLCMeta_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DLCMeta)(nil)
}
func (x fastReflection_DLCMeta_messageType) New() protoreflect.Message {
	return new(fastReflection_DLCMeta)
}
func (x fastReflection_DLCMeta_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DLCMeta
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DLCMeta) Descriptor() protoreflect.MessageDescriptor {
	return md_DLCMeta
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DLCMeta) Type() protoreflect.MessageType {
	return _fastReflection_DLCMeta_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DLCMeta) New() protoreflect.Message {
	return new(fastReflection_DLCMeta)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DLCMeta) Interface() protoreflect.ProtoMessage {
	return (*DLCMeta)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DLCMeta) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.LiquidationCet != nil {
		value := protoreflect.ValueOfMessage(x.LiquidationCet.ProtoReflect())
		if !f(fd_DLCMeta_liquidation_cet, value) {
			return
		}
	}
	if x.DefaultLiquidationCet != nil {
		value := protoreflect.ValueOfMessage(x.DefaultLiquidationCet.ProtoReflect())
		if !f(fd_DLCMeta_default_liquidation_cet, value) {
			return
		}
	}
	if x.RepaymentCet != nil {
		value := protoreflect.ValueOfMessage(x.RepaymentCet.ProtoReflect())
		if !f(fd_DLCMeta_repayment_cet, value) {
			return
		}
	}
	if x.TimeoutRefundTx != "" {
		value := protoreflect.ValueOfString(x.TimeoutRefundTx)
		if !f(fd_DLCMeta_timeout_refund_tx, value) {
			return
		}
	}
	if len(x.VaultUtxos) != 0 {
		value := protoreflect.ValueOfList(&_DLCMeta_5_list{list: &x.VaultUtxos})
		if !f(fd_DLCMeta_vault_utxos, value) {
			return
		}
	}
	if x.InternalKey != "" {
		value := protoreflect.ValueOfString(x.InternalKey)
		if !f(fd_DLCMeta_internal_key, value) {
			return
		}
	}
	if x.LiquidationScript != nil {
		value := protoreflect.ValueOfMessage(x.LiquidationScript.ProtoReflect())
		if !f(fd_DLCMeta_liquidation_script, value) {
			return
		}
	}
	if x.RepaymentScript != nil {
		value := protoreflect.ValueOfMessage(x.RepaymentScript.ProtoReflect())
		if !f(fd_DLCMeta_repayment_script, value) {
			return
		}
	}
	if x.TimeoutRefundScript != nil {
		value := protoreflect.ValueOfMessage(x.TimeoutRefundScript.ProtoReflect())
		if !f(fd_DLCMeta_timeout_refund_script, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DLCMeta) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.DLCMeta.liquidation_cet":
		return x.LiquidationCet != nil
	case "bitway.lending.DLCMeta.default_liquidation_cet":
		return x.DefaultLiquidationCet != nil
	case "bitway.lending.DLCMeta.repayment_cet":
		return x.RepaymentCet != nil
	case "bitway.lending.DLCMeta.timeout_refund_tx":
		return x.TimeoutRefundTx != ""
	case "bitway.lending.DLCMeta.vault_utxos":
		return len(x.VaultUtxos) != 0
	case "bitway.lending.DLCMeta.internal_key":
		return x.InternalKey != ""
	case "bitway.lending.DLCMeta.liquidation_script":
		return x.LiquidationScript != nil
	case "bitway.lending.DLCMeta.repayment_script":
		return x.RepaymentScript != nil
	case "bitway.lending.DLCMeta.timeout_refund_script":
		return x.TimeoutRefundScript != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DLCMeta"))
		}
		panic(fmt.Errorf("message bitway.lending.DLCMeta does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DLCMeta) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.DLCMeta.liquidation_cet":
		x.LiquidationCet = nil
	case "bitway.lending.DLCMeta.default_liquidation_cet":
		x.DefaultLiquidationCet = nil
	case "bitway.lending.DLCMeta.repayment_cet":
		x.RepaymentCet = nil
	case "bitway.lending.DLCMeta.timeout_refund_tx":
		x.TimeoutRefundTx = ""
	case "bitway.lending.DLCMeta.vault_utxos":
		x.VaultUtxos = nil
	case "bitway.lending.DLCMeta.internal_key":
		x.InternalKey = ""
	case "bitway.lending.DLCMeta.liquidation_script":
		x.LiquidationScript = nil
	case "bitway.lending.DLCMeta.repayment_script":
		x.RepaymentScript = nil
	case "bitway.lending.DLCMeta.timeout_refund_script":
		x.TimeoutRefundScript = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DLCMeta"))
		}
		panic(fmt.Errorf("message bitway.lending.DLCMeta does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DLCMeta) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.DLCMeta.liquidation_cet":
		value := x.LiquidationCet
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.DLCMeta.default_liquidation_cet":
		value := x.DefaultLiquidationCet
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.DLCMeta.repayment_cet":
		value := x.RepaymentCet
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.DLCMeta.timeout_refund_tx":
		value := x.TimeoutRefundTx
		return protoreflect.ValueOfString(value)
	case "bitway.lending.DLCMeta.vault_utxos":
		if len(x.VaultUtxos) == 0 {
			return protoreflect.ValueOfList(&_DLCMeta_5_list{})
		}
		listValue := &_DLCMeta_5_list{list: &x.VaultUtxos}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.DLCMeta.internal_key":
		value := x.InternalKey
		return protoreflect.ValueOfString(value)
	case "bitway.lending.DLCMeta.liquidation_script":
		value := x.LiquidationScript
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.DLCMeta.repayment_script":
		value := x.RepaymentScript
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.DLCMeta.timeout_refund_script":
		value := x.TimeoutRefundScript
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DLCMeta"))
		}
		panic(fmt.Errorf("message bitway.lending.DLCMeta does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DLCMeta) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.DLCMeta.liquidation_cet":
		x.LiquidationCet = value.Message().Interface().(*LiquidationCet)
	case "bitway.lending.DLCMeta.default_liquidation_cet":
		x.DefaultLiquidationCet = value.Message().Interface().(*LiquidationCet)
	case "bitway.lending.DLCMeta.repayment_cet":
		x.RepaymentCet = value.Message().Interface().(*RepaymentCet)
	case "bitway.lending.DLCMeta.timeout_refund_tx":
		x.TimeoutRefundTx = value.Interface().(string)
	case "bitway.lending.DLCMeta.vault_utxos":
		lv := value.List()
		clv := lv.(*_DLCMeta_5_list)
		x.VaultUtxos = *clv.list
	case "bitway.lending.DLCMeta.internal_key":
		x.InternalKey = value.Interface().(string)
	case "bitway.lending.DLCMeta.liquidation_script":
		x.LiquidationScript = value.Message().Interface().(*LeafScript)
	case "bitway.lending.DLCMeta.repayment_script":
		x.RepaymentScript = value.Message().Interface().(*LeafScript)
	case "bitway.lending.DLCMeta.timeout_refund_script":
		x.TimeoutRefundScript = value.Message().Interface().(*LeafScript)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DLCMeta"))
		}
		panic(fmt.Errorf("message bitway.lending.DLCMeta does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DLCMeta) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.DLCMeta.liquidation_cet":
		if x.LiquidationCet == nil {
			x.LiquidationCet = new(LiquidationCet)
		}
		return protoreflect.ValueOfMessage(x.LiquidationCet.ProtoReflect())
	case "bitway.lending.DLCMeta.default_liquidation_cet":
		if x.DefaultLiquidationCet == nil {
			x.DefaultLiquidationCet = new(LiquidationCet)
		}
		return protoreflect.ValueOfMessage(x.DefaultLiquidationCet.ProtoReflect())
	case "bitway.lending.DLCMeta.repayment_cet":
		if x.RepaymentCet == nil {
			x.RepaymentCet = new(RepaymentCet)
		}
		return protoreflect.ValueOfMessage(x.RepaymentCet.ProtoReflect())
	case "bitway.lending.DLCMeta.vault_utxos":
		if x.VaultUtxos == nil {
			x.VaultUtxos = []*btcbridge.UTXO{}
		}
		value := &_DLCMeta_5_list{list: &x.VaultUtxos}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.DLCMeta.liquidation_script":
		if x.LiquidationScript == nil {
			x.LiquidationScript = new(LeafScript)
		}
		return protoreflect.ValueOfMessage(x.LiquidationScript.ProtoReflect())
	case "bitway.lending.DLCMeta.repayment_script":
		if x.RepaymentScript == nil {
			x.RepaymentScript = new(LeafScript)
		}
		return protoreflect.ValueOfMessage(x.RepaymentScript.ProtoReflect())
	case "bitway.lending.DLCMeta.timeout_refund_script":
		if x.TimeoutRefundScript == nil {
			x.TimeoutRefundScript = new(LeafScript)
		}
		return protoreflect.ValueOfMessage(x.TimeoutRefundScript.ProtoReflect())
	case "bitway.lending.DLCMeta.timeout_refund_tx":
		panic(fmt.Errorf("field timeout_refund_tx of message bitway.lending.DLCMeta is not mutable"))
	case "bitway.lending.DLCMeta.internal_key":
		panic(fmt.Errorf("field internal_key of message bitway.lending.DLCMeta is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DLCMeta"))
		}
		panic(fmt.Errorf("message bitway.lending.DLCMeta does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DLCMeta) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.DLCMeta.liquidation_cet":
		m := new(LiquidationCet)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.DLCMeta.default_liquidation_cet":
		m := new(LiquidationCet)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.DLCMeta.repayment_cet":
		m := new(RepaymentCet)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.DLCMeta.timeout_refund_tx":
		return protoreflect.ValueOfString("")
	case "bitway.lending.DLCMeta.vault_utxos":
		list := []*btcbridge.UTXO{}
		return protoreflect.ValueOfList(&_DLCMeta_5_list{list: &list})
	case "bitway.lending.DLCMeta.internal_key":
		return protoreflect.ValueOfString("")
	case "bitway.lending.DLCMeta.liquidation_script":
		m := new(LeafScript)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.DLCMeta.repayment_script":
		m := new(LeafScript)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.DLCMeta.timeout_refund_script":
		m := new(LeafScript)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DLCMeta"))
		}
		panic(fmt.Errorf("message bitway.lending.DLCMeta does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DLCMeta) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.DLCMeta", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DLCMeta) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DLCMeta) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DLCMeta) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DLCMeta) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DLCMeta)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.LiquidationCet != nil {
			l = options.Size(x.LiquidationCet)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.DefaultLiquidationCet != nil {
			l = options.Size(x.DefaultLiquidationCet)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RepaymentCet != nil {
			l = options.Size(x.RepaymentCet)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TimeoutRefundTx)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.VaultUtxos) > 0 {
			for _, e := range x.VaultUtxos {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.InternalKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.LiquidationScript != nil {
			l = options.Size(x.LiquidationScript)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RepaymentScript != nil {
			l = options.Size(x.RepaymentScript)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.TimeoutRefundScript != nil {
			l = options.Size(x.TimeoutRefundScript)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DLCMeta)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.TimeoutRefundScript != nil {
			encoded, err := options.Marshal(x.TimeoutRefundScript)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x4a
		}
		if x.RepaymentScript != nil {
			encoded, err := options.Marshal(x.RepaymentScript)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x42
		}
		if x.LiquidationScript != nil {
			encoded, err := options.Marshal(x.LiquidationScript)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.InternalKey) > 0 {
			i -= len(x.InternalKey)
			copy(dAtA[i:], x.InternalKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.InternalKey)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.VaultUtxos) > 0 {
			for iNdEx := len(x.VaultUtxos) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.VaultUtxos[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x2a
			}
		}
		if len(x.TimeoutRefundTx) > 0 {
			i -= len(x.TimeoutRefundTx)
			copy(dAtA[i:], x.TimeoutRefundTx)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TimeoutRefundTx)))
			i--
			dAtA[i] = 0x22
		}
		if x.RepaymentCet != nil {
			encoded, err := options.Marshal(x.RepaymentCet)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.DefaultLiquidationCet != nil {
			encoded, err := options.Marshal(x.DefaultLiquidationCet)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.LiquidationCet != nil {
			encoded, err := options.Marshal(x.LiquidationCet)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DLCMeta)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DLCMeta: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DLCMeta: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidationCet", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LiquidationCet == nil {
					x.LiquidationCet = &LiquidationCet{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LiquidationCet); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DefaultLiquidationCet", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.DefaultLiquidationCet == nil {
					x.DefaultLiquidationCet = &LiquidationCet{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.DefaultLiquidationCet); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RepaymentCet", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RepaymentCet == nil {
					x.RepaymentCet = &RepaymentCet{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RepaymentCet); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TimeoutRefundTx", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TimeoutRefundTx = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultUtxos", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VaultUtxos = append(x.VaultUtxos, &btcbridge.UTXO{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.VaultUtxos[len(x.VaultUtxos)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InternalKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.InternalKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidationScript", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LiquidationScript == nil {
					x.LiquidationScript = &LeafScript{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LiquidationScript); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RepaymentScript", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RepaymentScript == nil {
					x.RepaymentScript = &LeafScript{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RepaymentScript); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TimeoutRefundScript", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.TimeoutRefundScript == nil {
					x.TimeoutRefundScript = &LeafScript{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TimeoutRefundScript); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_DepositLog                  protoreflect.MessageDescriptor
	fd_DepositLog_txid             protoreflect.FieldDescriptor
	fd_DepositLog_vault_address    protoreflect.FieldDescriptor
	fd_DepositLog_authorization_id protoreflect.FieldDescriptor
	fd_DepositLog_deposit_tx       protoreflect.FieldDescriptor
	fd_DepositLog_status           protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_DepositLog = File_bitway_lending_lending_proto.Messages().ByName("DepositLog")
	fd_DepositLog_txid = md_DepositLog.Fields().ByName("txid")
	fd_DepositLog_vault_address = md_DepositLog.Fields().ByName("vault_address")
	fd_DepositLog_authorization_id = md_DepositLog.Fields().ByName("authorization_id")
	fd_DepositLog_deposit_tx = md_DepositLog.Fields().ByName("deposit_tx")
	fd_DepositLog_status = md_DepositLog.Fields().ByName("status")
}

var _ protoreflect.Message = (*fastReflection_DepositLog)(nil)

type fastReflection_DepositLog DepositLog

func (x *DepositLog) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DepositLog)(x)
}

func (x *DepositLog) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DepositLog_messageType fastReflection_DepositLog_messageType
var _ protoreflect.MessageType = fastReflection_DepositLog_messageType{}

type fastReflection_DepositLog_messageType struct{}

func (x fastReflection_DepositLog_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DepositLog)(nil)
}
func (x fastReflection_DepositLog_messageType) New() protoreflect.Message {
	return new(fastReflection_DepositLog)
}
func (x fastReflection_DepositLog_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositLog
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DepositLog) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositLog
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DepositLog) Type() protoreflect.MessageType {
	return _fastReflection_DepositLog_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DepositLog) New() protoreflect.Message {
	return new(fastReflection_DepositLog)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DepositLog) Interface() protoreflect.ProtoMessage {
	return (*DepositLog)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DepositLog) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Txid != "" {
		value := protoreflect.ValueOfString(x.Txid)
		if !f(fd_DepositLog_txid, value) {
			return
		}
	}
	if x.VaultAddress != "" {
		value := protoreflect.ValueOfString(x.VaultAddress)
		if !f(fd_DepositLog_vault_address, value) {
			return
		}
	}
	if x.AuthorizationId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.AuthorizationId)
		if !f(fd_DepositLog_authorization_id, value) {
			return
		}
	}
	if x.DepositTx != "" {
		value := protoreflect.ValueOfString(x.DepositTx)
		if !f(fd_DepositLog_deposit_tx, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_DepositLog_status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DepositLog) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.DepositLog.txid":
		return x.Txid != ""
	case "bitway.lending.DepositLog.vault_address":
		return x.VaultAddress != ""
	case "bitway.lending.DepositLog.authorization_id":
		return x.AuthorizationId != uint64(0)
	case "bitway.lending.DepositLog.deposit_tx":
		return x.DepositTx != ""
	case "bitway.lending.DepositLog.status":
		return x.Status != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DepositLog"))
		}
		panic(fmt.Errorf("message bitway.lending.DepositLog does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLog) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.DepositLog.txid":
		x.Txid = ""
	case "bitway.lending.DepositLog.vault_address":
		x.VaultAddress = ""
	case "bitway.lending.DepositLog.authorization_id":
		x.AuthorizationId = uint64(0)
	case "bitway.lending.DepositLog.deposit_tx":
		x.DepositTx = ""
	case "bitway.lending.DepositLog.status":
		x.Status = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DepositLog"))
		}
		panic(fmt.Errorf("message bitway.lending.DepositLog does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DepositLog) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.DepositLog.txid":
		value := x.Txid
		return protoreflect.ValueOfString(value)
	case "bitway.lending.DepositLog.vault_address":
		value := x.VaultAddress
		return protoreflect.ValueOfString(value)
	case "bitway.lending.DepositLog.authorization_id":
		value := x.AuthorizationId
		return protoreflect.ValueOfUint64(value)
	case "bitway.lending.DepositLog.deposit_tx":
		value := x.DepositTx
		return protoreflect.ValueOfString(value)
	case "bitway.lending.DepositLog.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DepositLog"))
		}
		panic(fmt.Errorf("message bitway.lending.DepositLog does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLog) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.DepositLog.txid":
		x.Txid = value.Interface().(string)
	case "bitway.lending.DepositLog.vault_address":
		x.VaultAddress = value.Interface().(string)
	case "bitway.lending.DepositLog.authorization_id":
		x.AuthorizationId = value.Uint()
	case "bitway.lending.DepositLog.deposit_tx":
		x.DepositTx = value.Interface().(string)
	case "bitway.lending.DepositLog.status":
		x.Status = (DepositStatus)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DepositLog"))
		}
		panic(fmt.Errorf("message bitway.lending.DepositLog does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLog) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.DepositLog.txid":
		panic(fmt.Errorf("field txid of message bitway.lending.DepositLog is not mutable"))
	case "bitway.lending.DepositLog.vault_address":
		panic(fmt.Errorf("field vault_address of message bitway.lending.DepositLog is not mutable"))
	case "bitway.lending.DepositLog.authorization_id":
		panic(fmt.Errorf("field authorization_id of message bitway.lending.DepositLog is not mutable"))
	case "bitway.lending.DepositLog.deposit_tx":
		panic(fmt.Errorf("field deposit_tx of message bitway.lending.DepositLog is not mutable"))
	case "bitway.lending.DepositLog.status":
		panic(fmt.Errorf("field status of message bitway.lending.DepositLog is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DepositLog"))
		}
		panic(fmt.Errorf("message bitway.lending.DepositLog does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DepositLog) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.DepositLog.txid":
		return protoreflect.ValueOfString("")
	case "bitway.lending.DepositLog.vault_address":
		return protoreflect.ValueOfString("")
	case "bitway.lending.DepositLog.authorization_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "bitway.lending.DepositLog.deposit_tx":
		return protoreflect.ValueOfString("")
	case "bitway.lending.DepositLog.status":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.DepositLog"))
		}
		panic(fmt.Errorf("message bitway.lending.DepositLog does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DepositLog) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.DepositLog", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DepositLog) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLog) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DepositLog) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DepositLog) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DepositLog)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Txid)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.VaultAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.AuthorizationId != 0 {
			n += 1 + runtime.Sov(uint64(x.AuthorizationId))
		}
		l = len(x.DepositTx)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DepositLog)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x28
		}
		if len(x.DepositTx) > 0 {
			i -= len(x.DepositTx)
			copy(dAtA[i:], x.DepositTx)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DepositTx)))
			i--
			dAtA[i] = 0x22
		}
		if x.AuthorizationId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.AuthorizationId))
			i--
			dAtA[i] = 0x18
		}
		if len(x.VaultAddress) > 0 {
			i -= len(x.VaultAddress)
			copy(dAtA[i:], x.VaultAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.VaultAddress)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Txid) > 0 {
			i -= len(x.Txid)
			copy(dAtA[i:], x.Txid)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Txid)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DepositLog)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositLog: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositLog: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Txid = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VaultAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AuthorizationId", wireType)
				}
				x.AuthorizationId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.AuthorizationId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DepositTx", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DepositTx = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= DepositStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Repayment           protoreflect.MessageDescriptor
	fd_Repayment_loan_id   protoreflect.FieldDescriptor
	fd_Repayment_amount    protoreflect.FieldDescriptor
	fd_Repayment_create_at protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_Repayment = File_bitway_lending_lending_proto.Messages().ByName("Repayment")
	fd_Repayment_loan_id = md_Repayment.Fields().ByName("loan_id")
	fd_Repayment_amount = md_Repayment.Fields().ByName("amount")
	fd_Repayment_create_at = md_Repayment.Fields().ByName("create_at")
}

var _ protoreflect.Message = (*fastReflection_Repayment)(nil)

type fastReflection_Repayment Repayment

func (x *Repayment) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Repayment)(x)
}

func (x *Repayment) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Repayment_messageType fastReflection_Repayment_messageType
var _ protoreflect.MessageType = fastReflection_Repayment_messageType{}

type fastReflection_Repayment_messageType struct{}

func (x fastReflection_Repayment_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Repayment)(nil)
}
func (x fastReflection_Repayment_messageType) New() protoreflect.Message {
	return new(fastReflection_Repayment)
}
func (x fastReflection_Repayment_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Repayment
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Repayment) Descriptor() protoreflect.MessageDescriptor {
	return md_Repayment
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Repayment) Type() protoreflect.MessageType {
	return _fastReflection_Repayment_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Repayment) New() protoreflect.Message {
	return new(fastReflection_Repayment)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Repayment) Interface() protoreflect.ProtoMessage {
	return (*Repayment)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Repayment) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.LoanId != "" {
		value := protoreflect.ValueOfString(x.LoanId)
		if !f(fd_Repayment_loan_id, value) {
			return
		}
	}
	if x.Amount != nil {
		value := protoreflect.ValueOfMessage(x.Amount.ProtoReflect())
		if !f(fd_Repayment_amount, value) {
			return
		}
	}
	if x.CreateAt != nil {
		value := protoreflect.ValueOfMessage(x.CreateAt.ProtoReflect())
		if !f(fd_Repayment_create_at, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Repayment) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.Repayment.loan_id":
		return x.LoanId != ""
	case "bitway.lending.Repayment.amount":
		return x.Amount != nil
	case "bitway.lending.Repayment.create_at":
		return x.CreateAt != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Repayment"))
		}
		panic(fmt.Errorf("message bitway.lending.Repayment does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Repayment) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.Repayment.loan_id":
		x.LoanId = ""
	case "bitway.lending.Repayment.amount":
		x.Amount = nil
	case "bitway.lending.Repayment.create_at":
		x.CreateAt = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Repayment"))
		}
		panic(fmt.Errorf("message bitway.lending.Repayment does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Repayment) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.Repayment.loan_id":
		value := x.LoanId
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Repayment.amount":
		value := x.Amount
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "bitway.lending.Repayment.create_at":
		value := x.CreateAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Repayment"))
		}
		panic(fmt.Errorf("message bitway.lending.Repayment does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Repayment) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.Repayment.loan_id":
		x.LoanId = value.Interface().(string)
	case "bitway.lending.Repayment.amount":
		x.Amount = value.Message().Interface().(*v1beta1.Coin)
	case "bitway.lending.Repayment.create_at":
		x.CreateAt = value.Message().Interface().(*timestamppb.Timestamp)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Repayment"))
		}
		panic(fmt.Errorf("message bitway.lending.Repayment does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Repayment) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Repayment.amount":
		if x.Amount == nil {
			x.Amount = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.Amount.ProtoReflect())
	case "bitway.lending.Repayment.create_at":
		if x.CreateAt == nil {
			x.CreateAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.CreateAt.ProtoReflect())
	case "bitway.lending.Repayment.loan_id":
		panic(fmt.Errorf("field loan_id of message bitway.lending.Repayment is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Repayment"))
		}
		panic(fmt.Errorf("message bitway.lending.Repayment does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Repayment) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Repayment.loan_id":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Repayment.amount":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "bitway.lending.Repayment.create_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Repayment"))
		}
		panic(fmt.Errorf("message bitway.lending.Repayment does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Repayment) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.Repayment", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Repayment) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Repayment) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Repayment) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Repayment) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Repayment)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.LoanId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Amount != nil {
			l = options.Size(x.Amount)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CreateAt != nil {
			l = options.Size(x.CreateAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Repayment)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CreateAt != nil {
			encoded, err := options.Marshal(x.CreateAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Amount != nil {
			encoded, err := options.Marshal(x.Amount)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.LoanId) > 0 {
			i -= len(x.LoanId)
			copy(dAtA[i:], x.LoanId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LoanId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Repayment)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Repayment: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Repayment: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LoanId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LoanId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Amount == nil {
					x.Amount = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Amount); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CreateAt == nil {
					x.CreateAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CreateAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_Redemption_5_list)(nil)

type _Redemption_5_list struct {
	list *[]string
}

func (x *_Redemption_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Redemption_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_Redemption_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_Redemption_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_Redemption_5_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message Redemption at list field Signatures as it is not of Message kind"))
}

func (x *_Redemption_5_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_Redemption_5_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_Redemption_5_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_Redemption_6_list)(nil)

type _Redemption_6_list struct {
	list *[]string
}

func (x *_Redemption_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Redemption_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_Redemption_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_Redemption_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_Redemption_6_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message Redemption at list field DcmSignatures as it is not of Message kind"))
}

func (x *_Redemption_6_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_Redemption_6_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_Redemption_6_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Redemption                protoreflect.MessageDescriptor
	fd_Redemption_id             protoreflect.FieldDescriptor
	fd_Redemption_loan_id        protoreflect.FieldDescriptor
	fd_Redemption_txid           protoreflect.FieldDescriptor
	fd_Redemption_tx             protoreflect.FieldDescriptor
	fd_Redemption_signatures     protoreflect.FieldDescriptor
	fd_Redemption_dcm_signatures protoreflect.FieldDescriptor
	fd_Redemption_create_at      protoreflect.FieldDescriptor
)

func init() {
	file_bitway_lending_lending_proto_init()
	md_Redemption = File_bitway_lending_lending_proto.Messages().ByName("Redemption")
	fd_Redemption_id = md_Redemption.Fields().ByName("id")
	fd_Redemption_loan_id = md_Redemption.Fields().ByName("loan_id")
	fd_Redemption_txid = md_Redemption.Fields().ByName("txid")
	fd_Redemption_tx = md_Redemption.Fields().ByName("tx")
	fd_Redemption_signatures = md_Redemption.Fields().ByName("signatures")
	fd_Redemption_dcm_signatures = md_Redemption.Fields().ByName("dcm_signatures")
	fd_Redemption_create_at = md_Redemption.Fields().ByName("create_at")
}

var _ protoreflect.Message = (*fastReflection_Redemption)(nil)

type fastReflection_Redemption Redemption

func (x *Redemption) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Redemption)(x)
}

func (x *Redemption) slowProtoReflect() protoreflect.Message {
	mi := &file_bitway_lending_lending_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Redemption_messageType fastReflection_Redemption_messageType
var _ protoreflect.MessageType = fastReflection_Redemption_messageType{}

type fastReflection_Redemption_messageType struct{}

func (x fastReflection_Redemption_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Redemption)(nil)
}
func (x fastReflection_Redemption_messageType) New() protoreflect.Message {
	return new(fastReflection_Redemption)
}
func (x fastReflection_Redemption_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Redemption
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Redemption) Descriptor() protoreflect.MessageDescriptor {
	return md_Redemption
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Redemption) Type() protoreflect.MessageType {
	return _fastReflection_Redemption_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Redemption) New() protoreflect.Message {
	return new(fastReflection_Redemption)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Redemption) Interface() protoreflect.ProtoMessage {
	return (*Redemption)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Redemption) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_Redemption_id, value) {
			return
		}
	}
	if x.LoanId != "" {
		value := protoreflect.ValueOfString(x.LoanId)
		if !f(fd_Redemption_loan_id, value) {
			return
		}
	}
	if x.Txid != "" {
		value := protoreflect.ValueOfString(x.Txid)
		if !f(fd_Redemption_txid, value) {
			return
		}
	}
	if x.Tx != "" {
		value := protoreflect.ValueOfString(x.Tx)
		if !f(fd_Redemption_tx, value) {
			return
		}
	}
	if len(x.Signatures) != 0 {
		value := protoreflect.ValueOfList(&_Redemption_5_list{list: &x.Signatures})
		if !f(fd_Redemption_signatures, value) {
			return
		}
	}
	if len(x.DcmSignatures) != 0 {
		value := protoreflect.ValueOfList(&_Redemption_6_list{list: &x.DcmSignatures})
		if !f(fd_Redemption_dcm_signatures, value) {
			return
		}
	}
	if x.CreateAt != nil {
		value := protoreflect.ValueOfMessage(x.CreateAt.ProtoReflect())
		if !f(fd_Redemption_create_at, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Redemption) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "bitway.lending.Redemption.id":
		return x.Id != uint64(0)
	case "bitway.lending.Redemption.loan_id":
		return x.LoanId != ""
	case "bitway.lending.Redemption.txid":
		return x.Txid != ""
	case "bitway.lending.Redemption.tx":
		return x.Tx != ""
	case "bitway.lending.Redemption.signatures":
		return len(x.Signatures) != 0
	case "bitway.lending.Redemption.dcm_signatures":
		return len(x.DcmSignatures) != 0
	case "bitway.lending.Redemption.create_at":
		return x.CreateAt != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Redemption"))
		}
		panic(fmt.Errorf("message bitway.lending.Redemption does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Redemption) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "bitway.lending.Redemption.id":
		x.Id = uint64(0)
	case "bitway.lending.Redemption.loan_id":
		x.LoanId = ""
	case "bitway.lending.Redemption.txid":
		x.Txid = ""
	case "bitway.lending.Redemption.tx":
		x.Tx = ""
	case "bitway.lending.Redemption.signatures":
		x.Signatures = nil
	case "bitway.lending.Redemption.dcm_signatures":
		x.DcmSignatures = nil
	case "bitway.lending.Redemption.create_at":
		x.CreateAt = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Redemption"))
		}
		panic(fmt.Errorf("message bitway.lending.Redemption does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Redemption) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "bitway.lending.Redemption.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "bitway.lending.Redemption.loan_id":
		value := x.LoanId
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Redemption.txid":
		value := x.Txid
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Redemption.tx":
		value := x.Tx
		return protoreflect.ValueOfString(value)
	case "bitway.lending.Redemption.signatures":
		if len(x.Signatures) == 0 {
			return protoreflect.ValueOfList(&_Redemption_5_list{})
		}
		listValue := &_Redemption_5_list{list: &x.Signatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.Redemption.dcm_signatures":
		if len(x.DcmSignatures) == 0 {
			return protoreflect.ValueOfList(&_Redemption_6_list{})
		}
		listValue := &_Redemption_6_list{list: &x.DcmSignatures}
		return protoreflect.ValueOfList(listValue)
	case "bitway.lending.Redemption.create_at":
		value := x.CreateAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Redemption"))
		}
		panic(fmt.Errorf("message bitway.lending.Redemption does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Redemption) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "bitway.lending.Redemption.id":
		x.Id = value.Uint()
	case "bitway.lending.Redemption.loan_id":
		x.LoanId = value.Interface().(string)
	case "bitway.lending.Redemption.txid":
		x.Txid = value.Interface().(string)
	case "bitway.lending.Redemption.tx":
		x.Tx = value.Interface().(string)
	case "bitway.lending.Redemption.signatures":
		lv := value.List()
		clv := lv.(*_Redemption_5_list)
		x.Signatures = *clv.list
	case "bitway.lending.Redemption.dcm_signatures":
		lv := value.List()
		clv := lv.(*_Redemption_6_list)
		x.DcmSignatures = *clv.list
	case "bitway.lending.Redemption.create_at":
		x.CreateAt = value.Message().Interface().(*timestamppb.Timestamp)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Redemption"))
		}
		panic(fmt.Errorf("message bitway.lending.Redemption does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Redemption) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Redemption.signatures":
		if x.Signatures == nil {
			x.Signatures = []string{}
		}
		value := &_Redemption_5_list{list: &x.Signatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.Redemption.dcm_signatures":
		if x.DcmSignatures == nil {
			x.DcmSignatures = []string{}
		}
		value := &_Redemption_6_list{list: &x.DcmSignatures}
		return protoreflect.ValueOfList(value)
	case "bitway.lending.Redemption.create_at":
		if x.CreateAt == nil {
			x.CreateAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.CreateAt.ProtoReflect())
	case "bitway.lending.Redemption.id":
		panic(fmt.Errorf("field id of message bitway.lending.Redemption is not mutable"))
	case "bitway.lending.Redemption.loan_id":
		panic(fmt.Errorf("field loan_id of message bitway.lending.Redemption is not mutable"))
	case "bitway.lending.Redemption.txid":
		panic(fmt.Errorf("field txid of message bitway.lending.Redemption is not mutable"))
	case "bitway.lending.Redemption.tx":
		panic(fmt.Errorf("field tx of message bitway.lending.Redemption is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Redemption"))
		}
		panic(fmt.Errorf("message bitway.lending.Redemption does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Redemption) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "bitway.lending.Redemption.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "bitway.lending.Redemption.loan_id":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Redemption.txid":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Redemption.tx":
		return protoreflect.ValueOfString("")
	case "bitway.lending.Redemption.signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_Redemption_5_list{list: &list})
	case "bitway.lending.Redemption.dcm_signatures":
		list := []string{}
		return protoreflect.ValueOfList(&_Redemption_6_list{list: &list})
	case "bitway.lending.Redemption.create_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: bitway.lending.Redemption"))
		}
		panic(fmt.Errorf("message bitway.lending.Redemption does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Redemption) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in bitway.lending.Redemption", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Redemption) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Redemption) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Redemption) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Redemption) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Redemption)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		l = len(x.LoanId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Txid)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Tx)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Signatures) > 0 {
			for _, s := range x.Signatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.DcmSignatures) > 0 {
			for _, s := range x.DcmSignatures {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.CreateAt != nil {
			l = options.Size(x.CreateAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Redemption)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CreateAt != nil {
			encoded, err := options.Marshal(x.CreateAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.DcmSignatures) > 0 {
			for iNdEx := len(x.DcmSignatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.DcmSignatures[iNdEx])
				copy(dAtA[i:], x.DcmSignatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DcmSignatures[iNdEx])))
				i--
				dAtA[i] = 0x32
			}
		}
		if len(x.Signatures) > 0 {
			for iNdEx := len(x.Signatures) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Signatures[iNdEx])
				copy(dAtA[i:], x.Signatures[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signatures[iNdEx])))
				i--
				dAtA[i] = 0x2a
			}
		}
		if len(x.Tx) > 0 {
			i -= len(x.Tx)
			copy(dAtA[i:], x.Tx)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Tx)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Txid) > 0 {
			i -= len(x.Txid)
			copy(dAtA[i:], x.Txid)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Txid)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.LoanId) > 0 {
			i -= len(x.LoanId)
			copy(dAtA[i:], x.LoanId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LoanId)))
			i--
			dAtA[i] = 0x12
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Redemption)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Redemption: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Redemption: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LoanId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LoanId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Txid = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Tx = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signatures = append(x.Signatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DcmSignatures", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DcmSignatures = append(x.DcmSignatures, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CreateAt == nil {
					x.CreateAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CreateAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: bitway/lending/lending.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Status options for a lending pool
type PoolStatus int32

const (
	PoolStatus_INACTIVE PoolStatus = 0
	PoolStatus_ACTIVE   PoolStatus = 1
	PoolStatus_PAUSED   PoolStatus = 2
)

// Enum value maps for PoolStatus.
var (
	PoolStatus_name = map[int32]string{
		0: "INACTIVE",
		1: "ACTIVE",
		2: "PAUSED",
	}
	PoolStatus_value = map[string]int32{
		"INACTIVE": 0,
		"ACTIVE":   1,
		"PAUSED":   2,
	}
)

func (x PoolStatus) Enum() *PoolStatus {
	p := new(PoolStatus)
	*p = x
	return p
}

func (x PoolStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PoolStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_bitway_lending_lending_proto_enumTypes[0].Descriptor()
}

func (PoolStatus) Type() protoreflect.EnumType {
	return &file_bitway_lending_lending_proto_enumTypes[0]
}

func (x PoolStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PoolStatus.Descriptor instead.
func (PoolStatus) EnumDescriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{0}
}

// Loan Status
type LoanStatus int32

const (
	// Unspecified
	LoanStatus_Unspecified LoanStatus = 0
	// Loan Requested
	LoanStatus_Requested LoanStatus = 1
	// Loan Cancelled
	LoanStatus_Cancelled LoanStatus = 2
	// Loan Authorized
	LoanStatus_Authorized LoanStatus = 3
	// Loan Rejected
	LoanStatus_Rejected LoanStatus = 4
	// Loan Open
	LoanStatus_Open LoanStatus = 5
	// Loan Repaid
	LoanStatus_Repaid LoanStatus = 6
	// Loan Defaulted
	LoanStatus_Defaulted LoanStatus = 7
	// Loan Liquidated
	LoanStatus_Liquidated LoanStatus = 8
	// Loan Closed
	LoanStatus_Closed LoanStatus = 9
)

// Enum value maps for LoanStatus.
var (
	LoanStatus_name = map[int32]string{
		0: "Unspecified",
		1: "Requested",
		2: "Cancelled",
		3: "Authorized",
		4: "Rejected",
		5: "Open",
		6: "Repaid",
		7: "Defaulted",
		8: "Liquidated",
		9: "Closed",
	}
	LoanStatus_value = map[string]int32{
		"Unspecified": 0,
		"Requested":   1,
		"Cancelled":   2,
		"Authorized":  3,
		"Rejected":    4,
		"Open":        5,
		"Repaid":      6,
		"Defaulted":   7,
		"Liquidated":  8,
		"Closed":      9,
	}
)

func (x LoanStatus) Enum() *LoanStatus {
	p := new(LoanStatus)
	*p = x
	return p
}

func (x LoanStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LoanStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_bitway_lending_lending_proto_enumTypes[1].Descriptor()
}

func (LoanStatus) Type() protoreflect.EnumType {
	return &file_bitway_lending_lending_proto_enumTypes[1]
}

func (x LoanStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LoanStatus.Descriptor instead.
func (LoanStatus) EnumDescriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{1}
}

// Authorization Status
type AuthorizationStatus int32

const (
	// Pending
	AuthorizationStatus_AUTHORIZATION_STATUS_PENDING AuthorizationStatus = 0
	// Authorized
	AuthorizationStatus_AUTHORIZATION_STATUS_AUTHORIZED AuthorizationStatus = 1
	// Rejected
	AuthorizationStatus_AUTHORIZATION_STATUS_REJECTED AuthorizationStatus = 2
)

// Enum value maps for AuthorizationStatus.
var (
	AuthorizationStatus_name = map[int32]string{
		0: "AUTHORIZATION_STATUS_PENDING",
		1: "AUTHORIZATION_STATUS_AUTHORIZED",
		2: "AUTHORIZATION_STATUS_REJECTED",
	}
	AuthorizationStatus_value = map[string]int32{
		"AUTHORIZATION_STATUS_PENDING":    0,
		"AUTHORIZATION_STATUS_AUTHORIZED": 1,
		"AUTHORIZATION_STATUS_REJECTED":   2,
	}
)

func (x AuthorizationStatus) Enum() *AuthorizationStatus {
	p := new(AuthorizationStatus)
	*p = x
	return p
}

func (x AuthorizationStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AuthorizationStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_bitway_lending_lending_proto_enumTypes[2].Descriptor()
}

func (AuthorizationStatus) Type() protoreflect.EnumType {
	return &file_bitway_lending_lending_proto_enumTypes[2]
}

func (x AuthorizationStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AuthorizationStatus.Descriptor instead.
func (AuthorizationStatus) EnumDescriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{2}
}

type CetType int32

const (
	CetType_LIQUIDATION         CetType = 0
	CetType_DEFAULT_LIQUIDATION CetType = 1
	CetType_REPAYMENT           CetType = 2
)

// Enum value maps for CetType.
var (
	CetType_name = map[int32]string{
		0: "LIQUIDATION",
		1: "DEFAULT_LIQUIDATION",
		2: "REPAYMENT",
	}
	CetType_value = map[string]int32{
		"LIQUIDATION":         0,
		"DEFAULT_LIQUIDATION": 1,
		"REPAYMENT":           2,
	}
)

func (x CetType) Enum() *CetType {
	p := new(CetType)
	*p = x
	return p
}

func (x CetType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CetType) Descriptor() protoreflect.EnumDescriptor {
	return file_bitway_lending_lending_proto_enumTypes[3].Descriptor()
}

func (CetType) Type() protoreflect.EnumType {
	return &file_bitway_lending_lending_proto_enumTypes[3]
}

func (x CetType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CetType.Descriptor instead.
func (CetType) EnumDescriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{3}
}

type DepositStatus int32

const (
	DepositStatus_DEPOSIT_STATUS_PENDING   DepositStatus = 0
	DepositStatus_DEPOSIT_STATUS_VERIFIED  DepositStatus = 1
	DepositStatus_DEPOSIT_STATUS_REDEEMING DepositStatus = 2
	DepositStatus_DEPOSIT_STATUS_REDEEMED  DepositStatus = 3
)

// Enum value maps for DepositStatus.
var (
	DepositStatus_name = map[int32]string{
		0: "DEPOSIT_STATUS_PENDING",
		1: "DEPOSIT_STATUS_VERIFIED",
		2: "DEPOSIT_STATUS_REDEEMING",
		3: "DEPOSIT_STATUS_REDEEMED",
	}
	DepositStatus_value = map[string]int32{
		"DEPOSIT_STATUS_PENDING":   0,
		"DEPOSIT_STATUS_VERIFIED":  1,
		"DEPOSIT_STATUS_REDEEMING": 2,
		"DEPOSIT_STATUS_REDEEMED":  3,
	}
)

func (x DepositStatus) Enum() *DepositStatus {
	p := new(DepositStatus)
	*p = x
	return p
}

func (x DepositStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DepositStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_bitway_lending_lending_proto_enumTypes[4].Descriptor()
}

func (DepositStatus) Type() protoreflect.EnumType {
	return &file_bitway_lending_lending_proto_enumTypes[4]
}

func (x DepositStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DepositStatus.Descriptor instead.
func (DepositStatus) EnumDescriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{4}
}

// Signing intent
type SigningIntent int32

const (
	SigningIntent_SIGNING_INTENT_REPAYMENT           SigningIntent = 0
	SigningIntent_SIGNING_INTENT_LIQUIDATION         SigningIntent = 1
	SigningIntent_SIGNING_INTENT_DEFAULT_LIQUIDATION SigningIntent = 2
	SigningIntent_SIGNING_INTENT_REDEMPTION          SigningIntent = 3
)

// Enum value maps for SigningIntent.
var (
	SigningIntent_name = map[int32]string{
		0: "SIGNING_INTENT_REPAYMENT",
		1: "SIGNING_INTENT_LIQUIDATION",
		2: "SIGNING_INTENT_DEFAULT_LIQUIDATION",
		3: "SIGNING_INTENT_REDEMPTION",
	}
	SigningIntent_value = map[string]int32{
		"SIGNING_INTENT_REPAYMENT":           0,
		"SIGNING_INTENT_LIQUIDATION":         1,
		"SIGNING_INTENT_DEFAULT_LIQUIDATION": 2,
		"SIGNING_INTENT_REDEMPTION":          3,
	}
)

func (x SigningIntent) Enum() *SigningIntent {
	p := new(SigningIntent)
	*p = x
	return p
}

func (x SigningIntent) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SigningIntent) Descriptor() protoreflect.EnumDescriptor {
	return file_bitway_lending_lending_proto_enumTypes[5].Descriptor()
}

func (SigningIntent) Type() protoreflect.EnumType {
	return &file_bitway_lending_lending_proto_enumTypes[5]
}

func (x SigningIntent) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SigningIntent.Descriptor instead.
func (SigningIntent) EnumDescriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{5}
}

// Asset metadata
type AssetMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Denom            string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Symbol           string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Decimals         int32  `protobuf:"varint,3,opt,name=decimals,proto3" json:"decimals,omitempty"`
	PriceSymbol      string `protobuf:"bytes,4,opt,name=price_symbol,json=priceSymbol,proto3" json:"price_symbol,omitempty"`
	IsBasePriceAsset bool   `protobuf:"varint,5,opt,name=is_base_price_asset,json=isBasePriceAsset,proto3" json:"is_base_price_asset,omitempty"`
}

func (x *AssetMetadata) Reset() {
	*x = AssetMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AssetMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssetMetadata) ProtoMessage() {}

// Deprecated: Use AssetMetadata.ProtoReflect.Descriptor instead.
func (*AssetMetadata) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{0}
}

func (x *AssetMetadata) GetDenom() string {
	if x != nil {
		return x.Denom
	}
	return ""
}

func (x *AssetMetadata) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *AssetMetadata) GetDecimals() int32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *AssetMetadata) GetPriceSymbol() string {
	if x != nil {
		return x.PriceSymbol
	}
	return ""
}

func (x *AssetMetadata) GetIsBasePriceAsset() bool {
	if x != nil {
		return x.IsBasePriceAsset
	}
	return false
}

// Pool tranche config
type PoolTrancheConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// maturity duration in seconds
	Maturity int64 `protobuf:"varint,1,opt,name=maturity,proto3" json:"maturity,omitempty"`
	// borrow apr permille
	BorrowApr uint32 `protobuf:"varint,2,opt,name=borrow_apr,json=borrowApr,proto3" json:"borrow_apr,omitempty"`
}

func (x *PoolTrancheConfig) Reset() {
	*x = PoolTrancheConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PoolTrancheConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PoolTrancheConfig) ProtoMessage() {}

// Deprecated: Use PoolTrancheConfig.ProtoReflect.Descriptor instead.
func (*PoolTrancheConfig) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{1}
}

func (x *PoolTrancheConfig) GetMaturity() int64 {
	if x != nil {
		return x.Maturity
	}
	return 0
}

func (x *PoolTrancheConfig) GetBorrowApr() uint32 {
	if x != nil {
		return x.BorrowApr
	}
	return 0
}

// Pool config
type PoolConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// collateral asset metadata
	CollateralAsset *AssetMetadata `protobuf:"bytes,1,opt,name=collateral_asset,json=collateralAsset,proto3" json:"collateral_asset,omitempty"`
	// lending asset metadata
	LendingAsset *AssetMetadata `protobuf:"bytes,2,opt,name=lending_asset,json=lendingAsset,proto3" json:"lending_asset,omitempty"`
	// supply cap
	SupplyCap string `protobuf:"bytes,3,opt,name=supply_cap,json=supplyCap,proto3" json:"supply_cap,omitempty"`
	// borrow cap
	BorrowCap string `protobuf:"bytes,4,opt,name=borrow_cap,json=borrowCap,proto3" json:"borrow_cap,omitempty"`
	// minimum amount to be borrowed
	MinBorrowAmount string `protobuf:"bytes,5,opt,name=min_borrow_amount,json=minBorrowAmount,proto3" json:"min_borrow_amount,omitempty"`
	// maximum amount to be borrowed
	MaxBorrowAmount string `protobuf:"bytes,6,opt,name=max_borrow_amount,json=maxBorrowAmount,proto3" json:"max_borrow_amount,omitempty"`
	// tranches
	Tranches []*PoolTrancheConfig `protobuf:"bytes,7,rep,name=tranches,proto3" json:"tranches,omitempty"`
	// request fee
	RequestFee *v1beta1.Coin `protobuf:"bytes,8,opt,name=request_fee,json=requestFee,proto3" json:"request_fee,omitempty"`
	// origination fee factor permille
	OriginationFeeFactor uint32 `protobuf:"varint,9,opt,name=origination_fee_factor,json=originationFeeFactor,proto3" json:"origination_fee_factor,omitempty"`
	// reserve factor permille
	ReserveFactor uint32 `protobuf:"varint,10,opt,name=reserve_factor,json=reserveFactor,proto3" json:"reserve_factor,omitempty"`
	// maximum ltv percent
	MaxLtv uint32 `protobuf:"varint,11,opt,name=max_ltv,json=maxLtv,proto3" json:"max_ltv,omitempty"`
	// liquidation ltv percent
	LiquidationThreshold uint32 `protobuf:"varint,12,opt,name=liquidation_threshold,json=liquidationThreshold,proto3" json:"liquidation_threshold,omitempty"`
	// indicates if the pool is paused
	Paused bool `protobuf:"varint,13,opt,name=paused,proto3" json:"paused,omitempty"`
}

func (x *PoolConfig) Reset() {
	*x = PoolConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PoolConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PoolConfig) ProtoMessage() {}

// Deprecated: Use PoolConfig.ProtoReflect.Descriptor instead.
func (*PoolConfig) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{2}
}

func (x *PoolConfig) GetCollateralAsset() *AssetMetadata {
	if x != nil {
		return x.CollateralAsset
	}
	return nil
}

func (x *PoolConfig) GetLendingAsset() *AssetMetadata {
	if x != nil {
		return x.LendingAsset
	}
	return nil
}

func (x *PoolConfig) GetSupplyCap() string {
	if x != nil {
		return x.SupplyCap
	}
	return ""
}

func (x *PoolConfig) GetBorrowCap() string {
	if x != nil {
		return x.BorrowCap
	}
	return ""
}

func (x *PoolConfig) GetMinBorrowAmount() string {
	if x != nil {
		return x.MinBorrowAmount
	}
	return ""
}

func (x *PoolConfig) GetMaxBorrowAmount() string {
	if x != nil {
		return x.MaxBorrowAmount
	}
	return ""
}

func (x *PoolConfig) GetTranches() []*PoolTrancheConfig {
	if x != nil {
		return x.Tranches
	}
	return nil
}

func (x *PoolConfig) GetRequestFee() *v1beta1.Coin {
	if x != nil {
		return x.RequestFee
	}
	return nil
}

func (x *PoolConfig) GetOriginationFeeFactor() uint32 {
	if x != nil {
		return x.OriginationFeeFactor
	}
	return 0
}

func (x *PoolConfig) GetReserveFactor() uint32 {
	if x != nil {
		return x.ReserveFactor
	}
	return 0
}

func (x *PoolConfig) GetMaxLtv() uint32 {
	if x != nil {
		return x.MaxLtv
	}
	return 0
}

func (x *PoolConfig) GetLiquidationThreshold() uint32 {
	if x != nil {
		return x.LiquidationThreshold
	}
	return 0
}

func (x *PoolConfig) GetPaused() bool {
	if x != nil {
		return x.Paused
	}
	return false
}

// Pool tranche
type PoolTranche struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// maturity duration
	Maturity int64 `protobuf:"varint,1,opt,name=maturity,proto3" json:"maturity,omitempty"`
	// borrow index
	BorrowIndex string `protobuf:"bytes,2,opt,name=borrow_index,json=borrowIndex,proto3" json:"borrow_index,omitempty"`
	// total borrowed
	TotalBorrowed string `protobuf:"bytes,3,opt,name=total_borrowed,json=totalBorrowed,proto3" json:"total_borrowed,omitempty"`
	// total reserve
	TotalReserve string `protobuf:"bytes,4,opt,name=total_reserve,json=totalReserve,proto3" json:"total_reserve,omitempty"`
}

func (x *PoolTranche) Reset() {
	*x = PoolTranche{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PoolTranche) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PoolTranche) ProtoMessage() {}

// Deprecated: Use PoolTranche.ProtoReflect.Descriptor instead.
func (*PoolTranche) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{3}
}

func (x *PoolTranche) GetMaturity() int64 {
	if x != nil {
		return x.Maturity
	}
	return 0
}

func (x *PoolTranche) GetBorrowIndex() string {
	if x != nil {
		return x.BorrowIndex
	}
	return ""
}

func (x *PoolTranche) GetTotalBorrowed() string {
	if x != nil {
		return x.TotalBorrowed
	}
	return ""
}

func (x *PoolTranche) GetTotalReserve() string {
	if x != nil {
		return x.TotalReserve
	}
	return ""
}

type LendingPool struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id              string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Supply          *v1beta1.Coin  `protobuf:"bytes,2,opt,name=supply,proto3" json:"supply,omitempty"`
	AvailableAmount string         `protobuf:"bytes,3,opt,name=available_amount,json=availableAmount,proto3" json:"available_amount,omitempty"`
	BorrowedAmount  string         `protobuf:"bytes,4,opt,name=borrowed_amount,json=borrowedAmount,proto3" json:"borrowed_amount,omitempty"`
	TotalBorrowed   string         `protobuf:"bytes,5,opt,name=total_borrowed,json=totalBorrowed,proto3" json:"total_borrowed,omitempty"`
	ReserveAmount   string         `protobuf:"bytes,6,opt,name=reserve_amount,json=reserveAmount,proto3" json:"reserve_amount,omitempty"`
	TotalReserve    string         `protobuf:"bytes,7,opt,name=total_reserve,json=totalReserve,proto3" json:"total_reserve,omitempty"`
	TotalYtokens    *v1beta1.Coin  `protobuf:"bytes,8,opt,name=total_ytokens,json=totalYtokens,proto3" json:"total_ytokens,omitempty"`
	Tranches        []*PoolTranche `protobuf:"bytes,9,rep,name=tranches,proto3" json:"tranches,omitempty"`
	Config          *PoolConfig    `protobuf:"bytes,10,opt,name=config,proto3" json:"config,omitempty"`
	Status          PoolStatus     `protobuf:"varint,11,opt,name=status,proto3,enum=bitway.lending.PoolStatus" json:"status,omitempty"`
}

func (x *LendingPool) Reset() {
	*x = LendingPool{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LendingPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LendingPool) ProtoMessage() {}

// Deprecated: Use LendingPool.ProtoReflect.Descriptor instead.
func (*LendingPool) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{4}
}

func (x *LendingPool) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *LendingPool) GetSupply() *v1beta1.Coin {
	if x != nil {
		return x.Supply
	}
	return nil
}

func (x *LendingPool) GetAvailableAmount() string {
	if x != nil {
		return x.AvailableAmount
	}
	return ""
}

func (x *LendingPool) GetBorrowedAmount() string {
	if x != nil {
		return x.BorrowedAmount
	}
	return ""
}

func (x *LendingPool) GetTotalBorrowed() string {
	if x != nil {
		return x.TotalBorrowed
	}
	return ""
}

func (x *LendingPool) GetReserveAmount() string {
	if x != nil {
		return x.ReserveAmount
	}
	return ""
}

func (x *LendingPool) GetTotalReserve() string {
	if x != nil {
		return x.TotalReserve
	}
	return ""
}

func (x *LendingPool) GetTotalYtokens() *v1beta1.Coin {
	if x != nil {
		return x.TotalYtokens
	}
	return nil
}

func (x *LendingPool) GetTranches() []*PoolTranche {
	if x != nil {
		return x.Tranches
	}
	return nil
}

func (x *LendingPool) GetConfig() *PoolConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *LendingPool) GetStatus() PoolStatus {
	if x != nil {
		return x.Status
	}
	return PoolStatus_INACTIVE
}

// Authorization with deposit txs for cets
type Authorization struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id         uint64              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DepositTxs []string            `protobuf:"bytes,2,rep,name=deposit_txs,json=depositTxs,proto3" json:"deposit_txs,omitempty"`
	Status     AuthorizationStatus `protobuf:"varint,3,opt,name=status,proto3,enum=bitway.lending.AuthorizationStatus" json:"status,omitempty"`
}

func (x *Authorization) Reset() {
	*x = Authorization{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Authorization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Authorization) ProtoMessage() {}

// Deprecated: Use Authorization.ProtoReflect.Descriptor instead.
func (*Authorization) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{5}
}

func (x *Authorization) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Authorization) GetDepositTxs() []string {
	if x != nil {
		return x.DepositTxs
	}
	return nil
}

func (x *Authorization) GetStatus() AuthorizationStatus {
	if x != nil {
		return x.Status
	}
	return AuthorizationStatus_AUTHORIZATION_STATUS_PENDING
}

type Loan struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	VaultAddress       string                 `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"` // id
	Borrower           string                 `protobuf:"bytes,2,opt,name=borrower,proto3" json:"borrower,omitempty"`
	BorrowerPubKey     string                 `protobuf:"bytes,3,opt,name=borrowerPubKey,proto3" json:"borrowerPubKey,omitempty"`
	BorrowerAuthPubKey string                 `protobuf:"bytes,4,opt,name=borrowerAuthPubKey,proto3" json:"borrowerAuthPubKey,omitempty"`
	Dcm                string                 `protobuf:"bytes,5,opt,name=dcm,proto3" json:"dcm,omitempty"`
	MaturityTime       int64                  `protobuf:"varint,6,opt,name=maturity_time,json=maturityTime,proto3" json:"maturity_time,omitempty"`
	FinalTimeout       int64                  `protobuf:"varint,7,opt,name=final_timeout,json=finalTimeout,proto3" json:"final_timeout,omitempty"`
	PoolId             string                 `protobuf:"bytes,8,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	BorrowAmount       *v1beta1.Coin          `protobuf:"bytes,9,opt,name=borrow_amount,json=borrowAmount,proto3" json:"borrow_amount,omitempty"`
	RequestFee         *v1beta1.Coin          `protobuf:"bytes,10,opt,name=request_fee,json=requestFee,proto3" json:"request_fee,omitempty"`
	OriginationFee     string                 `protobuf:"bytes,11,opt,name=origination_fee,json=originationFee,proto3" json:"origination_fee,omitempty"`
	Interest           string                 `protobuf:"bytes,12,opt,name=interest,proto3" json:"interest,omitempty"`
	ProtocolFee        string                 `protobuf:"bytes,13,opt,name=protocol_fee,json=protocolFee,proto3" json:"protocol_fee,omitempty"`
	Maturity           int64                  `protobuf:"varint,14,opt,name=maturity,proto3" json:"maturity,omitempty"`
	BorrowApr          uint32                 `protobuf:"varint,15,opt,name=borrow_apr,json=borrowApr,proto3" json:"borrow_apr,omitempty"`
	StartBorrowIndex   string                 `protobuf:"bytes,16,opt,name=start_borrow_index,json=startBorrowIndex,proto3" json:"start_borrow_index,omitempty"`
	LiquidationPrice   string                 `protobuf:"bytes,17,opt,name=liquidation_price,json=liquidationPrice,proto3" json:"liquidation_price,omitempty"`
	DlcEventId         uint64                 `protobuf:"varint,18,opt,name=dlc_event_id,json=dlcEventId,proto3" json:"dlc_event_id,omitempty"`
	Authorizations     []*Authorization       `protobuf:"bytes,19,rep,name=authorizations,proto3" json:"authorizations,omitempty"`
	CollateralAmount   string                 `protobuf:"bytes,20,opt,name=collateral_amount,json=collateralAmount,proto3" json:"collateral_amount,omitempty"`
	LiquidationId      uint64                 `protobuf:"varint,21,opt,name=liquidation_id,json=liquidationId,proto3" json:"liquidation_id,omitempty"`
	Referrer           *Referrer              `protobuf:"bytes,22,opt,name=referrer,proto3" json:"referrer,omitempty"`
	CreateAt           *timestamppb.Timestamp `protobuf:"bytes,23,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	DisburseAt         *timestamppb.Timestamp `protobuf:"bytes,24,opt,name=disburse_at,json=disburseAt,proto3" json:"disburse_at,omitempty"`
	Status             LoanStatus             `protobuf:"varint,25,opt,name=status,proto3,enum=bitway.lending.LoanStatus" json:"status,omitempty"`
}

func (x *Loan) Reset() {
	*x = Loan{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Loan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Loan) ProtoMessage() {}

// Deprecated: Use Loan.ProtoReflect.Descriptor instead.
func (*Loan) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{6}
}

func (x *Loan) GetVaultAddress() string {
	if x != nil {
		return x.VaultAddress
	}
	return ""
}

func (x *Loan) GetBorrower() string {
	if x != nil {
		return x.Borrower
	}
	return ""
}

func (x *Loan) GetBorrowerPubKey() string {
	if x != nil {
		return x.BorrowerPubKey
	}
	return ""
}

func (x *Loan) GetBorrowerAuthPubKey() string {
	if x != nil {
		return x.BorrowerAuthPubKey
	}
	return ""
}

func (x *Loan) GetDcm() string {
	if x != nil {
		return x.Dcm
	}
	return ""
}

func (x *Loan) GetMaturityTime() int64 {
	if x != nil {
		return x.MaturityTime
	}
	return 0
}

func (x *Loan) GetFinalTimeout() int64 {
	if x != nil {
		return x.FinalTimeout
	}
	return 0
}

func (x *Loan) GetPoolId() string {
	if x != nil {
		return x.PoolId
	}
	return ""
}

func (x *Loan) GetBorrowAmount() *v1beta1.Coin {
	if x != nil {
		return x.BorrowAmount
	}
	return nil
}

func (x *Loan) GetRequestFee() *v1beta1.Coin {
	if x != nil {
		return x.RequestFee
	}
	return nil
}

func (x *Loan) GetOriginationFee() string {
	if x != nil {
		return x.OriginationFee
	}
	return ""
}

func (x *Loan) GetInterest() string {
	if x != nil {
		return x.Interest
	}
	return ""
}

func (x *Loan) GetProtocolFee() string {
	if x != nil {
		return x.ProtocolFee
	}
	return ""
}

func (x *Loan) GetMaturity() int64 {
	if x != nil {
		return x.Maturity
	}
	return 0
}

func (x *Loan) GetBorrowApr() uint32 {
	if x != nil {
		return x.BorrowApr
	}
	return 0
}

func (x *Loan) GetStartBorrowIndex() string {
	if x != nil {
		return x.StartBorrowIndex
	}
	return ""
}

func (x *Loan) GetLiquidationPrice() string {
	if x != nil {
		return x.LiquidationPrice
	}
	return ""
}

func (x *Loan) GetDlcEventId() uint64 {
	if x != nil {
		return x.DlcEventId
	}
	return 0
}

func (x *Loan) GetAuthorizations() []*Authorization {
	if x != nil {
		return x.Authorizations
	}
	return nil
}

func (x *Loan) GetCollateralAmount() string {
	if x != nil {
		return x.CollateralAmount
	}
	return ""
}

func (x *Loan) GetLiquidationId() uint64 {
	if x != nil {
		return x.LiquidationId
	}
	return 0
}

func (x *Loan) GetReferrer() *Referrer {
	if x != nil {
		return x.Referrer
	}
	return nil
}

func (x *Loan) GetCreateAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateAt
	}
	return nil
}

func (x *Loan) GetDisburseAt() *timestamppb.Timestamp {
	if x != nil {
		return x.DisburseAt
	}
	return nil
}

func (x *Loan) GetStatus() LoanStatus {
	if x != nil {
		return x.Status
	}
	return LoanStatus_Unspecified
}

// Referrer defines the referrer
type Referrer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Unique referral code with 8 alphanumeric characters
	ReferralCode string `protobuf:"bytes,2,opt,name=referral_code,json=referralCode,proto3" json:"referral_code,omitempty"`
	// Referrer address
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// Referral fee factor
	ReferralFeeFactor string `protobuf:"bytes,4,opt,name=referral_fee_factor,json=referralFeeFactor,proto3" json:"referral_fee_factor,omitempty"`
}

func (x *Referrer) Reset() {
	*x = Referrer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Referrer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Referrer) ProtoMessage() {}

// Deprecated: Use Referrer.ProtoReflect.Descriptor instead.
func (*Referrer) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{7}
}

func (x *Referrer) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Referrer) GetReferralCode() string {
	if x != nil {
		return x.ReferralCode
	}
	return ""
}

func (x *Referrer) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Referrer) GetReferralFeeFactor() string {
	if x != nil {
		return x.ReferralFeeFactor
	}
	return ""
}

// LeafScript defines the tap leaf script
type LeafScript struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Script       string `protobuf:"bytes,1,opt,name=script,proto3" json:"script,omitempty"`
	ControlBlock string `protobuf:"bytes,2,opt,name=control_block,json=controlBlock,proto3" json:"control_block,omitempty"`
}

func (x *LeafScript) Reset() {
	*x = LeafScript{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LeafScript) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafScript) ProtoMessage() {}

// Deprecated: Use LeafScript.ProtoReflect.Descriptor instead.
func (*LeafScript) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{8}
}

func (x *LeafScript) GetScript() string {
	if x != nil {
		return x.Script
	}
	return ""
}

func (x *LeafScript) GetControlBlock() string {
	if x != nil {
		return x.ControlBlock
	}
	return ""
}

type CetInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	EventId        uint64      `protobuf:"varint,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	OutcomeIndex   uint32      `protobuf:"varint,2,opt,name=outcome_index,json=outcomeIndex,proto3" json:"outcome_index,omitempty"`
	SignaturePoint string      `protobuf:"bytes,3,opt,name=signature_point,json=signaturePoint,proto3" json:"signature_point,omitempty"`
	Script         *LeafScript `protobuf:"bytes,4,opt,name=script,proto3" json:"script,omitempty"`
	SighashType    uint32      `protobuf:"varint,5,opt,name=sighash_type,json=sighashType,proto3" json:"sighash_type,omitempty"`
}

func (x *CetInfo) Reset() {
	*x = CetInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CetInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CetInfo) ProtoMessage() {}

// Deprecated: Use CetInfo.ProtoReflect.Descriptor instead.
func (*CetInfo) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{9}
}

func (x *CetInfo) GetEventId() uint64 {
	if x != nil {
		return x.EventId
	}
	return 0
}

func (x *CetInfo) GetOutcomeIndex() uint32 {
	if x != nil {
		return x.OutcomeIndex
	}
	return 0
}

func (x *CetInfo) GetSignaturePoint() string {
	if x != nil {
		return x.SignaturePoint
	}
	return ""
}

func (x *CetInfo) GetScript() *LeafScript {
	if x != nil {
		return x.Script
	}
	return nil
}

func (x *CetInfo) GetSighashType() uint32 {
	if x != nil {
		return x.SighashType
	}
	return 0
}

type LiquidationCet struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Tx                        string   `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	BorrowerAdaptorSignatures []string `protobuf:"bytes,2,rep,name=borrower_adaptor_signatures,json=borrowerAdaptorSignatures,proto3" json:"borrower_adaptor_signatures,omitempty"`
	BorrowerAdaptedSignatures []string `protobuf:"bytes,3,rep,name=borrower_adapted_signatures,json=borrowerAdaptedSignatures,proto3" json:"borrower_adapted_signatures,omitempty"`
	DcmSignatures             []string `protobuf:"bytes,4,rep,name=dcm_signatures,json=dcmSignatures,proto3" json:"dcm_signatures,omitempty"`
	SignedTxHex               string   `protobuf:"bytes,5,opt,name=signed_tx_hex,json=signedTxHex,proto3" json:"signed_tx_hex,omitempty"`
}

func (x *LiquidationCet) Reset() {
	*x = LiquidationCet{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LiquidationCet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LiquidationCet) ProtoMessage() {}

// Deprecated: Use LiquidationCet.ProtoReflect.Descriptor instead.
func (*LiquidationCet) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{10}
}

func (x *LiquidationCet) GetTx() string {
	if x != nil {
		return x.Tx
	}
	return ""
}

func (x *LiquidationCet) GetBorrowerAdaptorSignatures() []string {
	if x != nil {
		return x.BorrowerAdaptorSignatures
	}
	return nil
}

func (x *LiquidationCet) GetBorrowerAdaptedSignatures() []string {
	if x != nil {
		return x.BorrowerAdaptedSignatures
	}
	return nil
}

func (x *LiquidationCet) GetDcmSignatures() []string {
	if x != nil {
		return x.DcmSignatures
	}
	return nil
}

func (x *LiquidationCet) GetSignedTxHex() string {
	if x != nil {
		return x.SignedTxHex
	}
	return ""
}

type RepaymentCet struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Tx                   string   `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	DcmAdaptorSignatures []string `protobuf:"bytes,2,rep,name=dcm_adaptor_signatures,json=dcmAdaptorSignatures,proto3" json:"dcm_adaptor_signatures,omitempty"`
	DcmAdaptedSignatures []string `protobuf:"bytes,3,rep,name=dcm_adapted_signatures,json=dcmAdaptedSignatures,proto3" json:"dcm_adapted_signatures,omitempty"`
	BorrowerSignatures   []string `protobuf:"bytes,4,rep,name=borrower_signatures,json=borrowerSignatures,proto3" json:"borrower_signatures,omitempty"`
	SignedTxHex          string   `protobuf:"bytes,5,opt,name=signed_tx_hex,json=signedTxHex,proto3" json:"signed_tx_hex,omitempty"`
}

func (x *RepaymentCet) Reset() {
	*x = RepaymentCet{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RepaymentCet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RepaymentCet) ProtoMessage() {}

// Deprecated: Use RepaymentCet.ProtoReflect.Descriptor instead.
func (*RepaymentCet) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{11}
}

func (x *RepaymentCet) GetTx() string {
	if x != nil {
		return x.Tx
	}
	return ""
}

func (x *RepaymentCet) GetDcmAdaptorSignatures() []string {
	if x != nil {
		return x.DcmAdaptorSignatures
	}
	return nil
}

func (x *RepaymentCet) GetDcmAdaptedSignatures() []string {
	if x != nil {
		return x.DcmAdaptedSignatures
	}
	return nil
}

func (x *RepaymentCet) GetBorrowerSignatures() []string {
	if x != nil {
		return x.BorrowerSignatures
	}
	return nil
}

func (x *RepaymentCet) GetSignedTxHex() string {
	if x != nil {
		return x.SignedTxHex
	}
	return ""
}

type DLCMeta struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	LiquidationCet        *LiquidationCet   `protobuf:"bytes,1,opt,name=liquidation_cet,json=liquidationCet,proto3" json:"liquidation_cet,omitempty"`
	DefaultLiquidationCet *LiquidationCet   `protobuf:"bytes,2,opt,name=default_liquidation_cet,json=defaultLiquidationCet,proto3" json:"default_liquidation_cet,omitempty"`
	RepaymentCet          *RepaymentCet     `protobuf:"bytes,3,opt,name=repayment_cet,json=repaymentCet,proto3" json:"repayment_cet,omitempty"`
	TimeoutRefundTx       string            `protobuf:"bytes,4,opt,name=timeout_refund_tx,json=timeoutRefundTx,proto3" json:"timeout_refund_tx,omitempty"`
	VaultUtxos            []*btcbridge.UTXO `protobuf:"bytes,5,rep,name=vault_utxos,json=vaultUtxos,proto3" json:"vault_utxos,omitempty"`
	InternalKey           string            `protobuf:"bytes,6,opt,name=internal_key,json=internalKey,proto3" json:"internal_key,omitempty"`
	LiquidationScript     *LeafScript       `protobuf:"bytes,7,opt,name=liquidation_script,json=liquidationScript,proto3" json:"liquidation_script,omitempty"`
	RepaymentScript       *LeafScript       `protobuf:"bytes,8,opt,name=repayment_script,json=repaymentScript,proto3" json:"repayment_script,omitempty"`
	TimeoutRefundScript   *LeafScript       `protobuf:"bytes,9,opt,name=timeout_refund_script,json=timeoutRefundScript,proto3" json:"timeout_refund_script,omitempty"`
}

func (x *DLCMeta) Reset() {
	*x = DLCMeta{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DLCMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DLCMeta) ProtoMessage() {}

// Deprecated: Use DLCMeta.ProtoReflect.Descriptor instead.
func (*DLCMeta) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{12}
}

func (x *DLCMeta) GetLiquidationCet() *LiquidationCet {
	if x != nil {
		return x.LiquidationCet
	}
	return nil
}

func (x *DLCMeta) GetDefaultLiquidationCet() *LiquidationCet {
	if x != nil {
		return x.DefaultLiquidationCet
	}
	return nil
}

func (x *DLCMeta) GetRepaymentCet() *RepaymentCet {
	if x != nil {
		return x.RepaymentCet
	}
	return nil
}

func (x *DLCMeta) GetTimeoutRefundTx() string {
	if x != nil {
		return x.TimeoutRefundTx
	}
	return ""
}

func (x *DLCMeta) GetVaultUtxos() []*btcbridge.UTXO {
	if x != nil {
		return x.VaultUtxos
	}
	return nil
}

func (x *DLCMeta) GetInternalKey() string {
	if x != nil {
		return x.InternalKey
	}
	return ""
}

func (x *DLCMeta) GetLiquidationScript() *LeafScript {
	if x != nil {
		return x.LiquidationScript
	}
	return nil
}

func (x *DLCMeta) GetRepaymentScript() *LeafScript {
	if x != nil {
		return x.RepaymentScript
	}
	return nil
}

func (x *DLCMeta) GetTimeoutRefundScript() *LeafScript {
	if x != nil {
		return x.TimeoutRefundScript
	}
	return nil
}

type DepositLog struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Txid            string        `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	VaultAddress    string        `protobuf:"bytes,2,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	AuthorizationId uint64        `protobuf:"varint,3,opt,name=authorization_id,json=authorizationId,proto3" json:"authorization_id,omitempty"`
	DepositTx       string        `protobuf:"bytes,4,opt,name=deposit_tx,json=depositTx,proto3" json:"deposit_tx,omitempty"`
	Status          DepositStatus `protobuf:"varint,5,opt,name=status,proto3,enum=bitway.lending.DepositStatus" json:"status,omitempty"`
}

func (x *DepositLog) Reset() {
	*x = DepositLog{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DepositLog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositLog) ProtoMessage() {}

// Deprecated: Use DepositLog.ProtoReflect.Descriptor instead.
func (*DepositLog) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{13}
}

func (x *DepositLog) GetTxid() string {
	if x != nil {
		return x.Txid
	}
	return ""
}

func (x *DepositLog) GetVaultAddress() string {
	if x != nil {
		return x.VaultAddress
	}
	return ""
}

func (x *DepositLog) GetAuthorizationId() uint64 {
	if x != nil {
		return x.AuthorizationId
	}
	return 0
}

func (x *DepositLog) GetDepositTx() string {
	if x != nil {
		return x.DepositTx
	}
	return ""
}

func (x *DepositLog) GetStatus() DepositStatus {
	if x != nil {
		return x.Status
	}
	return DepositStatus_DEPOSIT_STATUS_PENDING
}

type Repayment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	LoanId   string                 `protobuf:"bytes,1,opt,name=loan_id,json=loanId,proto3" json:"loan_id,omitempty"`
	Amount   *v1beta1.Coin          `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	CreateAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
}

func (x *Repayment) Reset() {
	*x = Repayment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Repayment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Repayment) ProtoMessage() {}

// Deprecated: Use Repayment.ProtoReflect.Descriptor instead.
func (*Repayment) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{14}
}

func (x *Repayment) GetLoanId() string {
	if x != nil {
		return x.LoanId
	}
	return ""
}

func (x *Repayment) GetAmount() *v1beta1.Coin {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *Repayment) GetCreateAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateAt
	}
	return nil
}

type Redemption struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	LoanId        string                 `protobuf:"bytes,2,opt,name=loan_id,json=loanId,proto3" json:"loan_id,omitempty"`
	Txid          string                 `protobuf:"bytes,3,opt,name=txid,proto3" json:"txid,omitempty"`
	Tx            string                 `protobuf:"bytes,4,opt,name=tx,proto3" json:"tx,omitempty"`
	Signatures    []string               `protobuf:"bytes,5,rep,name=signatures,proto3" json:"signatures,omitempty"`
	DcmSignatures []string               `protobuf:"bytes,6,rep,name=dcm_signatures,json=dcmSignatures,proto3" json:"dcm_signatures,omitempty"`
	CreateAt      *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
}

func (x *Redemption) Reset() {
	*x = Redemption{}
	if protoimpl.UnsafeEnabled {
		mi := &file_bitway_lending_lending_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Redemption) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Redemption) ProtoMessage() {}

// Deprecated: Use Redemption.ProtoReflect.Descriptor instead.
func (*Redemption) Descriptor() ([]byte, []int) {
	return file_bitway_lending_lending_proto_rawDescGZIP(), []int{15}
}

func (x *Redemption) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Redemption) GetLoanId() string {
	if x != nil {
		return x.LoanId
	}
	return ""
}

func (x *Redemption) GetTxid() string {
	if x != nil {
		return x.Txid
	}
	return ""
}

func (x *Redemption) GetTx() string {
	if x != nil {
		return x.Tx
	}
	return ""
}

func (x *Redemption) GetSignatures() []string {
	if x != nil {
		return x.Signatures
	}
	return nil
}

func (x *Redemption) GetDcmSignatures() []string {
	if x != nil {
		return x.DcmSignatures
	}
	return nil
}

func (x *Redemption) GetCreateAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateAt
	}
	return nil
}

var File_bitway_lending_lending_proto protoreflect.FileDescriptor

var file_bitway_lending_lending_proto_rawDesc = []byte{
	0x0a, 0x1c, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2f, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67,
	0x2f, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e,
	0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x1a, 0x14,
	0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x62, 0x61,
	0x73, 0x65, 0x2f, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2f, 0x63, 0x6f, 0x69, 0x6e, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x20, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2f, 0x62, 0x74, 0x63, 0x62, 0x72, 0x69, 0x64,
	0x67, 0x65, 0x2f, 0x62, 0x74, 0x63, 0x62, 0x72, 0x69, 0x64, 0x67, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0xab, 0x01, 0x0a, 0x0d, 0x41, 0x73, 0x73, 0x65, 0x74, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x12, 0x14, 0x0a, 0x05, 0x64, 0x65, 0x6e, 0x6f, 0x6d, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x64, 0x65, 0x6e, 0x6f, 0x6d, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x79,
	0x6d, 0x62, 0x6f, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x79, 0x6d, 0x62,
	0x6f, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x64, 0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x73, 0x12, 0x21,
	0x0a, 0x0c, 0x70, 0x72, 0x69, 0x63, 0x65, 0x5f, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x72, 0x69, 0x63, 0x65, 0x53, 0x79, 0x6d, 0x62, 0x6f,
	0x6c, 0x12, 0x2d, 0x0a, 0x13, 0x69, 0x73, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x70, 0x72, 0x69,
	0x63, 0x65, 0x5f, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10,
	0x69, 0x73, 0x42, 0x61, 0x73, 0x65, 0x50, 0x72, 0x69, 0x63, 0x65, 0x41, 0x73, 0x73, 0x65, 0x74,
	0x22, 0x5d, 0x0a, 0x11, 0x50, 0x6f, 0x6f, 0x6c, 0x54, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x61, 0x74, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x6d, 0x61, 0x74, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x12, 0x2c, 0x0a, 0x0a, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x61, 0x70, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x42, 0x0d, 0xe2, 0xde, 0x1f, 0x09, 0x42, 0x6f, 0x72, 0x72, 0x6f,
	0x77, 0x41, 0x50, 0x52, 0x52, 0x09, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x41, 0x70, 0x72, 0x22,
	0x82, 0x06, 0x0a, 0x0a, 0x50, 0x6f, 0x6f, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x4e,
	0x0a, 0x10, 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x5f, 0x61, 0x73, 0x73,
	0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61,
	0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0f, 0x63,
	0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x41, 0x73, 0x73, 0x65, 0x74, 0x12, 0x48,
	0x0a, 0x0d, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c,
	0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0c, 0x6c, 0x65, 0x6e, 0x64,
	0x69, 0x6e, 0x67, 0x41, 0x73, 0x73, 0x65, 0x74, 0x12, 0x3c, 0x0a, 0x0a, 0x73, 0x75, 0x70, 0x70,
	0x6c, 0x79, 0x5f, 0x63, 0x61, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x09, 0x73, 0x75, 0x70,
	0x70, 0x6c, 0x79, 0x43, 0x61, 0x70, 0x12, 0x3c, 0x0a, 0x0a, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77,
	0x5f, 0x63, 0x61, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x09, 0x62, 0x6f, 0x72, 0x72, 0x6f,
	0x77, 0x43, 0x61, 0x70, 0x12, 0x49, 0x0a, 0x11, 0x6d, 0x69, 0x6e, 0x5f, 0x62, 0x6f, 0x72, 0x72,
	0x6f, 0x77, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0f,
	0x6d, 0x69, 0x6e, 0x42, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12,
	0x49, 0x0a, 0x11, 0x6d, 0x61, 0x78, 0x5f, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x42, 0x6f,
	0x72, 0x72, 0x6f, 0x77, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x43, 0x0a, 0x08, 0x74, 0x72,
	0x61, 0x6e, 0x63, 0x68, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x62,
	0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x50, 0x6f,
	0x6f, 0x6c, 0x54, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x42,
	0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x08, 0x74, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x73, 0x12,
	0x40, 0x0a, 0x0b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x66, 0x65, 0x65, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x62, 0x61,
	0x73, 0x65, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42,
	0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46, 0x65,
	0x65, 0x12, 0x34, 0x0a, 0x16, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x66, 0x65, 0x65, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x14, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x65,
	0x65, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x25, 0x0a, 0x0e, 0x72, 0x65, 0x73, 0x65, 0x72,
	0x76, 0x65, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x0d, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x17,
	0x0a, 0x07, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x74, 0x76, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x06, 0x6d, 0x61, 0x78, 0x4c, 0x74, 0x76, 0x12, 0x33, 0x0a, 0x15, 0x6c, 0x69, 0x71, 0x75, 0x69,
	0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x14, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x12, 0x16, 0x0a, 0x06,
	0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x70, 0x61,
	0x75, 0x73, 0x65, 0x64, 0x22, 0x89, 0x02, 0x0a, 0x0b, 0x50, 0x6f, 0x6f, 0x6c, 0x54, 0x72, 0x61,
	0x6e, 0x63, 0x68, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x61, 0x74, 0x75, 0x72, 0x69, 0x74, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x6d, 0x61, 0x74, 0x75, 0x72, 0x69, 0x74, 0x79,
	0x12, 0x54, 0x0a, 0x0c, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x0b, 0x62, 0x6f, 0x72, 0x72, 0x6f,
	0x77, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x44, 0x0a, 0x0e, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f,
	0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0d, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x42, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x64, 0x12, 0x42, 0x0a, 0x0d,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49,
	0x6e, 0x74, 0x52, 0x0c, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
	0x22, 0xbb, 0x05, 0x0a, 0x0b, 0x4c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x6f, 0x6f, 0x6c,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x37, 0x0a, 0x06, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x76,
	0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x06, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x12, 0x48, 0x0a, 0x10, 0x61, 0x76, 0x61,
	0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49,
	0x6e, 0x74, 0x52, 0x0f, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x41, 0x6d, 0x6f,
	0x75, 0x6e, 0x74, 0x12, 0x46, 0x0a, 0x0f, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x64, 0x5f,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0e, 0x62, 0x6f, 0x72,
	0x72, 0x6f, 0x77, 0x65, 0x64, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x44, 0x0a, 0x0e, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49,
	0x6e, 0x74, 0x52, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x42, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65,
	0x64, 0x12, 0x44, 0x0a, 0x0e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x5f, 0x61, 0x6d, 0x6f,
	0x75, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0d, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
	0x65, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x42, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x5f, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0c, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x12, 0x54, 0x0a, 0x0d, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x79, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x62, 0x61, 0x73, 0x65,
	0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x14, 0xc8,
	0xde, 0x1f, 0x00, 0xe2, 0xde, 0x1f, 0x0c, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x59, 0x54, 0x6f, 0x6b,
	0x65, 0x6e, 0x73, 0x52, 0x0c, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x59, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x73, 0x12, 0x3d, 0x0a, 0x08, 0x74, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x73, 0x18, 0x09, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e,
	0x64, 0x69, 0x6e, 0x67, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x54, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x08, 0x74, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x73,
	0x12, 0x38, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e,
	0x67, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x42, 0x04, 0xc8, 0xde,
	0x1f, 0x00, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x32, 0x0a, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x62, 0x69, 0x74,
	0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x50, 0x6f, 0x6f, 0x6c,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x7d,
	0x0a, 0x0d, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
	0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12,
	0x1f, 0x0a, 0x0b, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x74, 0x78, 0x73, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x54, 0x78, 0x73,
	0x12, 0x3b, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x23, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e,
	0x67, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xcb, 0x0a,
	0x0a, 0x04, 0x4c, 0x6f, 0x61, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x62,
	0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x62,
	0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x12, 0x26, 0x0a, 0x0e, 0x62, 0x6f, 0x72, 0x72, 0x6f,
	0x77, 0x65, 0x72, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0e, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12,
	0x2e, 0x0a, 0x12, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x41, 0x75, 0x74, 0x68, 0x50,
	0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x62, 0x6f, 0x72,
	0x72, 0x6f, 0x77, 0x65, 0x72, 0x41, 0x75, 0x74, 0x68, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12,
	0x19, 0x0a, 0x03, 0x64, 0x63, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x07, 0xe2, 0xde,
	0x1f, 0x03, 0x44, 0x43, 0x4d, 0x52, 0x03, 0x64, 0x63, 0x6d, 0x12, 0x23, 0x0a, 0x0d, 0x6d, 0x61,
	0x74, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0c, 0x6d, 0x61, 0x74, 0x75, 0x72, 0x69, 0x74, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x12,
	0x23, 0x0a, 0x0d, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x54, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x44, 0x0a,
	0x0d, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x62, 0x61,
	0x73, 0x65, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42,
	0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0c, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x41, 0x6d, 0x6f,
	0x75, 0x6e, 0x74, 0x12, 0x40, 0x0a, 0x0b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x66,
	0x65, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43,
	0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x46, 0x65, 0x65, 0x12, 0x46, 0x0a, 0x0f, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66, 0x65, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0e, 0x6f,
	0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x65, 0x65, 0x12, 0x39, 0x0a,
	0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x65, 0x73, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x08,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x65, 0x73, 0x74, 0x12, 0x40, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x66, 0x65, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1d,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0b, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x46, 0x65, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x61,
	0x74, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x6d, 0x61,
	0x74, 0x75, 0x72, 0x69, 0x74, 0x79, 0x12, 0x2c, 0x0a, 0x0a, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77,
	0x5f, 0x61, 0x70, 0x72, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0d, 0x42, 0x0d, 0xe2, 0xde, 0x1f, 0x09,
	0x42, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x41, 0x50, 0x52, 0x52, 0x09, 0x62, 0x6f, 0x72, 0x72, 0x6f,
	0x77, 0x41, 0x70, 0x72, 0x12, 0x5f, 0x0a, 0x12, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x62, 0x6f,
	0x72, 0x72, 0x6f, 0x77, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x10, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61,
	0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x44, 0x65, 0x63, 0x52, 0x10, 0x73, 0x74, 0x61, 0x72, 0x74, 0x42, 0x6f, 0x72, 0x72, 0x6f, 0x77,
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x5e, 0x0a, 0x11, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x11, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61,
	0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x44, 0x65, 0x63, 0x52, 0x10, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x20, 0x0a, 0x0c, 0x64, 0x6c, 0x63, 0x5f, 0x65, 0x76, 0x65,
	0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x12, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x64, 0x6c, 0x63,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x4b, 0x0a, 0x0e, 0x61, 0x75, 0x74, 0x68, 0x6f,
	0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x13, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1d, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67,
	0x2e, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x04,
	0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0e, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x12, 0x4a, 0x0a, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72,
	0x61, 0x6c, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x14, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x10,
	0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x25, 0x0a, 0x0e, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x69, 0x64, 0x18, 0x15, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x66, 0x65, 0x72,
	0x72, 0x65, 0x72, 0x18, 0x16, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x62, 0x69, 0x74, 0x77,
	0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x52, 0x65, 0x66, 0x65, 0x72,
	0x72, 0x65, 0x72, 0x52, 0x08, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x72, 0x12, 0x41, 0x0a,
	0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x74, 0x18, 0x17, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde,
	0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x08, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x74,
	0x12, 0x45, 0x0a, 0x0b, 0x64, 0x69, 0x73, 0x62, 0x75, 0x72, 0x73, 0x65, 0x5f, 0x61, 0x74, 0x18,
	0x18, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0a, 0x64, 0x69, 0x73,
	0x62, 0x75, 0x72, 0x73, 0x65, 0x41, 0x74, 0x12, 0x32, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79,
	0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x4c, 0x6f, 0x61, 0x6e, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xc0, 0x01, 0x0a, 0x08,
	0x52, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x23, 0x0a, 0x0d,
	0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x61, 0x6c, 0x43, 0x6f, 0x64,
	0x65, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x61, 0x0a, 0x13, 0x72,
	0x65, 0x66, 0x65, 0x72, 0x72, 0x61, 0x6c, 0x5f, 0x66, 0x65, 0x65, 0x5f, 0x66, 0x61, 0x63, 0x74,
	0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d,
	0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x11, 0x72, 0x65, 0x66,
	0x65, 0x72, 0x72, 0x61, 0x6c, 0x46, 0x65, 0x65, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x22, 0x49,
	0x0a, 0x0a, 0x4c, 0x65, 0x61, 0x66, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x16, 0x0a, 0x06,
	0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x63,
	0x72, 0x69, 0x70, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f,
	0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6e,
	0x74, 0x72, 0x6f, 0x6c, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x22, 0xcf, 0x01, 0x0a, 0x07, 0x43, 0x65,
	0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x19, 0x0a, 0x08, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x64,
	0x12, 0x23, 0x0a, 0x0d, 0x6f, 0x75, 0x74, 0x63, 0x6f, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x64, 0x65,
	0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x6f, 0x75, 0x74, 0x63, 0x6f, 0x6d, 0x65,
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x27, 0x0a, 0x0f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
	0x72, 0x65, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e,
	0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x38,
	0x0a, 0x06, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e,
	0x4c, 0x65, 0x61, 0x66, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00,
	0x52, 0x06, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x69, 0x67, 0x68,
	0x61, 0x73, 0x68, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b,
	0x73, 0x69, 0x67, 0x68, 0x61, 0x73, 0x68, 0x54, 0x79, 0x70, 0x65, 0x22, 0xfe, 0x01, 0x0a, 0x0e,
	0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x65, 0x74, 0x12, 0x0e,
	0x0a, 0x02, 0x74, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74, 0x78, 0x12, 0x3e,
	0x0a, 0x1b, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74,
	0x6f, 0x72, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x19, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x41, 0x64, 0x61,
	0x70, 0x74, 0x6f, 0x72, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x3e,
	0x0a, 0x1b, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74,
	0x65, 0x64, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x19, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x41, 0x64, 0x61,
	0x70, 0x74, 0x65, 0x64, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x38,
	0x0a, 0x0e, 0x64, 0x63, 0x6d, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
	0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x42, 0x11, 0xe2, 0xde, 0x1f, 0x0d, 0x44, 0x43, 0x4d, 0x53,
	0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x0d, 0x64, 0x63, 0x6d, 0x53, 0x69,
	0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x22, 0x0a, 0x0d, 0x73, 0x69, 0x67, 0x6e,
	0x65, 0x64, 0x5f, 0x74, 0x78, 0x5f, 0x68, 0x65, 0x78, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0b, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x54, 0x78, 0x48, 0x65, 0x78, 0x22, 0x93, 0x02, 0x0a,
	0x0c, 0x52, 0x65, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x43, 0x65, 0x74, 0x12, 0x0e, 0x0a,
	0x02, 0x74, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74, 0x78, 0x12, 0x4e, 0x0a,
	0x16, 0x64, 0x63, 0x6d, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x42, 0x18, 0xe2,
	0xde, 0x1f, 0x14, 0x44, 0x43, 0x4d, 0x41, 0x64, 0x61, 0x70, 0x74, 0x6f, 0x72, 0x53, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x14, 0x64, 0x63, 0x6d, 0x41, 0x64, 0x61, 0x70,
	0x74, 0x6f, 0x72, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x4e, 0x0a,
	0x16, 0x64, 0x63, 0x6d, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x42, 0x18, 0xe2,
	0xde, 0x1f, 0x14, 0x44, 0x43, 0x4d, 0x41, 0x64, 0x61, 0x70, 0x74, 0x65, 0x64, 0x53, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x14, 0x64, 0x63, 0x6d, 0x41, 0x64, 0x61, 0x70,
	0x74, 0x65, 0x64, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x2f, 0x0a,
	0x13, 0x62, 0x6f, 0x72, 0x72, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74,
	0x75, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x12, 0x62, 0x6f, 0x72, 0x72,
	0x6f, 0x77, 0x65, 0x72, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x22,
	0x0a, 0x0d, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x5f, 0x74, 0x78, 0x5f, 0x68, 0x65, 0x78, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x54, 0x78, 0x48,
	0x65, 0x78, 0x22, 0xfb, 0x04, 0x0a, 0x07, 0x44, 0x4c, 0x43, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x4d,
	0x0a, 0x0f, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x65,
	0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79,
	0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x43, 0x65, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0e, 0x6c,
	0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x65, 0x74, 0x12, 0x5c, 0x0a,
	0x17, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e,
	0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e,
	0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x65, 0x74, 0x42, 0x04,
	0xc8, 0xde, 0x1f, 0x00, 0x52, 0x15, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x4c, 0x69, 0x71,
	0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x65, 0x74, 0x12, 0x47, 0x0a, 0x0d, 0x72,
	0x65, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64,
	0x69, 0x6e, 0x67, 0x2e, 0x52, 0x65, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x43, 0x65, 0x74,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0c, 0x72, 0x65, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e,
	0x74, 0x43, 0x65, 0x74, 0x12, 0x2a, 0x0a, 0x11, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f,
	0x72, 0x65, 0x66, 0x75, 0x6e, 0x64, 0x5f, 0x74, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x52, 0x65, 0x66, 0x75, 0x6e, 0x64, 0x54, 0x78,
	0x12, 0x37, 0x0a, 0x0b, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x75, 0x74, 0x78, 0x6f, 0x73, 0x18,
	0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x62,
	0x74, 0x63, 0x62, 0x72, 0x69, 0x64, 0x67, 0x65, 0x2e, 0x55, 0x54, 0x58, 0x4f, 0x52, 0x0a, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x55, 0x74, 0x78, 0x6f, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0b, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x4b, 0x65, 0x79, 0x12, 0x4f, 0x0a, 0x12,
	0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x63, 0x72, 0x69,
	0x70, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61,
	0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x53, 0x63,
	0x72, 0x69, 0x70, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x11, 0x6c, 0x69, 0x71, 0x75,
	0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x4b, 0x0a,
	0x10, 0x72, 0x65, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x63, 0x72, 0x69, 0x70,
	0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79,
	0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x53, 0x63, 0x72,
	0x69, 0x70, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0f, 0x72, 0x65, 0x70, 0x61, 0x79,
	0x6d, 0x65, 0x6e, 0x74, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x54, 0x0a, 0x15, 0x74, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x72, 0x65, 0x66, 0x75, 0x6e, 0x64, 0x5f, 0x73, 0x63, 0x72,
	0x69, 0x70, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x62, 0x69, 0x74, 0x77,
	0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x4c, 0x65, 0x61, 0x66, 0x53,
	0x63, 0x72, 0x69, 0x70, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x13, 0x74, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x52, 0x65, 0x66, 0x75, 0x6e, 0x64, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x22, 0xc6, 0x01, 0x0a, 0x0a, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x4c, 0x6f, 0x67, 0x12,
	0x12, 0x0a, 0x04, 0x74, 0x78, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74,
	0x78, 0x69, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x76, 0x61, 0x75, 0x6c,
	0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x29, 0x0a, 0x10, 0x61, 0x75, 0x74, 0x68,
	0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0f, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x74,
	0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74,
	0x54, 0x78, 0x12, 0x35, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x1d, 0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64,
	0x69, 0x6e, 0x67, 0x2e, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xa0, 0x01, 0x0a, 0x09, 0x52, 0x65,
	0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6c, 0x6f, 0x61, 0x6e, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f, 0x61, 0x6e, 0x49, 0x64,
	0x12, 0x37, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x76,
	0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x41, 0x0a, 0x09, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x5f, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf,
	0x1f, 0x01, 0x52, 0x08, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x74, 0x22, 0xf6, 0x01, 0x0a,
	0x0a, 0x52, 0x65, 0x64, 0x65, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x6c,
	0x6f, 0x61, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f,
	0x61, 0x6e, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x78, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x74, 0x78, 0x69, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x78, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74, 0x78, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x69, 0x67, 0x6e,
	0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x69,
	0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x38, 0x0a, 0x0e, 0x64, 0x63, 0x6d, 0x5f,
	0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09,
	0x42, 0x11, 0xe2, 0xde, 0x1f, 0x0d, 0x44, 0x43, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
	0x72, 0x65, 0x73, 0x52, 0x0d, 0x64, 0x63, 0x6d, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72,
	0x65, 0x73, 0x12, 0x41, 0x0a, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x74, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x08, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x41, 0x74, 0x2a, 0x32, 0x0a, 0x0a, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x0c, 0x0a, 0x08, 0x49, 0x4e, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x10,
	0x00, 0x12, 0x0a, 0x0a, 0x06, 0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x10, 0x01, 0x12, 0x0a, 0x0a,
	0x06, 0x50, 0x41, 0x55, 0x53, 0x45, 0x44, 0x10, 0x02, 0x2a, 0x9a, 0x01, 0x0a, 0x0a, 0x4c, 0x6f,
	0x61, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x6e, 0x73, 0x70,
	0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x61, 0x6e, 0x63,
	0x65, 0x6c, 0x6c, 0x65, 0x64, 0x10, 0x02, 0x12, 0x0e, 0x0a, 0x0a, 0x41, 0x75, 0x74, 0x68, 0x6f,
	0x72, 0x69, 0x7a, 0x65, 0x64, 0x10, 0x03, 0x12, 0x0c, 0x0a, 0x08, 0x52, 0x65, 0x6a, 0x65, 0x63,
	0x74, 0x65, 0x64, 0x10, 0x04, 0x12, 0x08, 0x0a, 0x04, 0x4f, 0x70, 0x65, 0x6e, 0x10, 0x05, 0x12,
	0x0a, 0x0a, 0x06, 0x52, 0x65, 0x70, 0x61, 0x69, 0x64, 0x10, 0x06, 0x12, 0x0d, 0x0a, 0x09, 0x44,
	0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x65, 0x64, 0x10, 0x07, 0x12, 0x0e, 0x0a, 0x0a, 0x4c, 0x69,
	0x71, 0x75, 0x69, 0x64, 0x61, 0x74, 0x65, 0x64, 0x10, 0x08, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x6c,
	0x6f, 0x73, 0x65, 0x64, 0x10, 0x09, 0x2a, 0x7f, 0x0a, 0x13, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72,
	0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x20, 0x0a,
	0x1c, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x00, 0x12,
	0x23, 0x0a, 0x1f, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x41, 0x54, 0x49, 0x4f, 0x4e,
	0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a,
	0x45, 0x44, 0x10, 0x01, 0x12, 0x21, 0x0a, 0x1d, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a,
	0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x45, 0x4a,
	0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x02, 0x2a, 0x42, 0x0a, 0x07, 0x43, 0x65, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x0f, 0x0a, 0x0b, 0x4c, 0x49, 0x51, 0x55, 0x49, 0x44, 0x41, 0x54, 0x49, 0x4f,
	0x4e, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x13, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c, 0x54, 0x5f, 0x4c,
	0x49, 0x51, 0x55, 0x49, 0x44, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09,
	0x52, 0x45, 0x50, 0x41, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x02, 0x2a, 0x83, 0x01, 0x0a, 0x0d,
	0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a,
	0x16, 0x44, 0x45, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f,
	0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17, 0x44, 0x45, 0x50,
	0x4f, 0x53, 0x49, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x56, 0x45, 0x52, 0x49,
	0x46, 0x49, 0x45, 0x44, 0x10, 0x01, 0x12, 0x1c, 0x0a, 0x18, 0x44, 0x45, 0x50, 0x4f, 0x53, 0x49,
	0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x45, 0x44, 0x45, 0x45, 0x4d, 0x49,
	0x4e, 0x47, 0x10, 0x02, 0x12, 0x1b, 0x0a, 0x17, 0x44, 0x45, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x5f,
	0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x45, 0x44, 0x45, 0x45, 0x4d, 0x45, 0x44, 0x10,
	0x03, 0x2a, 0x94, 0x01, 0x0a, 0x0d, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x74,
	0x65, 0x6e, 0x74, 0x12, 0x1c, 0x0a, 0x18, 0x53, 0x49, 0x47, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x49,
	0x4e, 0x54, 0x45, 0x4e, 0x54, 0x5f, 0x52, 0x45, 0x50, 0x41, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x10,
	0x00, 0x12, 0x1e, 0x0a, 0x1a, 0x53, 0x49, 0x47, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x49, 0x4e, 0x54,
	0x45, 0x4e, 0x54, 0x5f, 0x4c, 0x49, 0x51, 0x55, 0x49, 0x44, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10,
	0x01, 0x12, 0x26, 0x0a, 0x22, 0x53, 0x49, 0x47, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x49, 0x4e, 0x54,
	0x45, 0x4e, 0x54, 0x5f, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c, 0x54, 0x5f, 0x4c, 0x49, 0x51, 0x55,
	0x49, 0x44, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x02, 0x12, 0x1d, 0x0a, 0x19, 0x53, 0x49, 0x47,
	0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x4e, 0x54, 0x5f, 0x52, 0x45, 0x44, 0x45,
	0x4d, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x42, 0xac, 0x01, 0x0a, 0x12, 0x63, 0x6f, 0x6d,
	0x2e, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x42,
	0x0c, 0x4c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a,
	0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x69, 0x74, 0x77,
	0x61, 0x79, 0x6c, 0x61, 0x62, 0x73, 0x2f, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2f, 0x61, 0x70,
	0x69, 0x2f, 0x62, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2f, 0x6c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67,
	0xa2, 0x02, 0x03, 0x42, 0x4c, 0x58, 0xaa, 0x02, 0x0e, 0x42, 0x69, 0x74, 0x77, 0x61, 0x79, 0x2e,
	0x4c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0xca, 0x02, 0x0e, 0x42, 0x69, 0x74, 0x77, 0x61, 0x79,
	0x5c, 0x4c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0xe2, 0x02, 0x1a, 0x42, 0x69, 0x74, 0x77, 0x61,
	0x79, 0x5c, 0x4c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74,
	0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x0f, 0x42, 0x69, 0x74, 0x77, 0x61, 0x79, 0x3a, 0x3a,
	0x4c, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_bitway_lending_lending_proto_rawDescOnce sync.Once
	file_bitway_lending_lending_proto_rawDescData = file_bitway_lending_lending_proto_rawDesc
)

func file_bitway_lending_lending_proto_rawDescGZIP() []byte {
	file_bitway_lending_lending_proto_rawDescOnce.Do(func() {
		file_bitway_lending_lending_proto_rawDescData = protoimpl.X.CompressGZIP(file_bitway_lending_lending_proto_rawDescData)
	})
	return file_bitway_lending_lending_proto_rawDescData
}

var file_bitway_lending_lending_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_bitway_lending_lending_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_bitway_lending_lending_proto_goTypes = []interface{}{
	(PoolStatus)(0),               // 0: bitway.lending.PoolStatus
	(LoanStatus)(0),               // 1: bitway.lending.LoanStatus
	(AuthorizationStatus)(0),      // 2: bitway.lending.AuthorizationStatus
	(CetType)(0),                  // 3: bitway.lending.CetType
	(DepositStatus)(0),            // 4: bitway.lending.DepositStatus
	(SigningIntent)(0),            // 5: bitway.lending.SigningIntent
	(*AssetMetadata)(nil),         // 6: bitway.lending.AssetMetadata
	(*PoolTrancheConfig)(nil),     // 7: bitway.lending.PoolTrancheConfig
	(*PoolConfig)(nil),            // 8: bitway.lending.PoolConfig
	(*PoolTranche)(nil),           // 9: bitway.lending.PoolTranche
	(*LendingPool)(nil),           // 10: bitway.lending.LendingPool
	(*Authorization)(nil),         // 11: bitway.lending.Authorization
	(*Loan)(nil),                  // 12: bitway.lending.Loan
	(*Referrer)(nil),              // 13: bitway.lending.Referrer
	(*LeafScript)(nil),            // 14: bitway.lending.LeafScript
	(*CetInfo)(nil),               // 15: bitway.lending.CetInfo
	(*LiquidationCet)(nil),        // 16: bitway.lending.LiquidationCet
	(*RepaymentCet)(nil),          // 17: bitway.lending.RepaymentCet
	(*DLCMeta)(nil),               // 18: bitway.lending.DLCMeta
	(*DepositLog)(nil),            // 19: bitway.lending.DepositLog
	(*Repayment)(nil),             // 20: bitway.lending.Repayment
	(*Redemption)(nil),            // 21: bitway.lending.Redemption
	(*v1beta1.Coin)(nil),          // 22: cosmos.base.v1beta1.Coin
	(*timestamppb.Timestamp)(nil), // 23: google.protobuf.Timestamp
	(*btcbridge.UTXO)(nil),        // 24: bitway.btcbridge.UTXO
}
var file_bitway_lending_lending_proto_depIdxs = []int32{
	6,  // 0: bitway.lending.PoolConfig.collateral_asset:type_name -> bitway.lending.AssetMetadata
	6,  // 1: bitway.lending.PoolConfig.lending_asset:type_name -> bitway.lending.AssetMetadata
	7,  // 2: bitway.lending.PoolConfig.tranches:type_name -> bitway.lending.PoolTrancheConfig
	22, // 3: bitway.lending.PoolConfig.request_fee:type_name -> cosmos.base.v1beta1.Coin
	22, // 4: bitway.lending.LendingPool.supply:type_name -> cosmos.base.v1beta1.Coin
	22, // 5: bitway.lending.LendingPool.total_ytokens:type_name -> cosmos.base.v1beta1.Coin
	9,  // 6: bitway.lending.LendingPool.tranches:type_name -> bitway.lending.PoolTranche
	8,  // 7: bitway.lending.LendingPool.config:type_name -> bitway.lending.PoolConfig
	0,  // 8: bitway.lending.LendingPool.status:type_name -> bitway.lending.PoolStatus
	2,  // 9: bitway.lending.Authorization.status:type_name -> bitway.lending.AuthorizationStatus
	22, // 10: bitway.lending.Loan.borrow_amount:type_name -> cosmos.base.v1beta1.Coin
	22, // 11: bitway.lending.Loan.request_fee:type_name -> cosmos.base.v1beta1.Coin
	11, // 12: bitway.lending.Loan.authorizations:type_name -> bitway.lending.Authorization
	13, // 13: bitway.lending.Loan.referrer:type_name -> bitway.lending.Referrer
	23, // 14: bitway.lending.Loan.create_at:type_name -> google.protobuf.Timestamp
	23, // 15: bitway.lending.Loan.disburse_at:type_name -> google.protobuf.Timestamp
	1,  // 16: bitway.lending.Loan.status:type_name -> bitway.lending.LoanStatus
	14, // 17: bitway.lending.CetInfo.script:type_name -> bitway.lending.LeafScript
	16, // 18: bitway.lending.DLCMeta.liquidation_cet:type_name -> bitway.lending.LiquidationCet
	16, // 19: bitway.lending.DLCMeta.default_liquidation_cet:type_name -> bitway.lending.LiquidationCet
	17, // 20: bitway.lending.DLCMeta.repayment_cet:type_name -> bitway.lending.RepaymentCet
	24, // 21: bitway.lending.DLCMeta.vault_utxos:type_name -> bitway.btcbridge.UTXO
	14, // 22: bitway.lending.DLCMeta.liquidation_script:type_name -> bitway.lending.LeafScript
	14, // 23: bitway.lending.DLCMeta.repayment_script:type_name -> bitway.lending.LeafScript
	14, // 24: bitway.lending.DLCMeta.timeout_refund_script:type_name -> bitway.lending.LeafScript
	4,  // 25: bitway.lending.DepositLog.status:type_name -> bitway.lending.DepositStatus
	22, // 26: bitway.lending.Repayment.amount:type_name -> cosmos.base.v1beta1.Coin
	23, // 27: bitway.lending.Repayment.create_at:type_name -> google.protobuf.Timestamp
	23, // 28: bitway.lending.Redemption.create_at:type_name -> google.protobuf.Timestamp
	29, // [29:29] is the sub-list for method output_type
	29, // [29:29] is the sub-list for method input_type
	29, // [29:29] is the sub-list for extension type_name
	29, // [29:29] is the sub-list for extension extendee
	0,  // [0:29] is the sub-list for field type_name
}

func init() { file_bitway_lending_lending_proto_init() }
func file_bitway_lending_lending_proto_init() {
	if File_bitway_lending_lending_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_bitway_lending_lending_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AssetMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PoolTrancheConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PoolConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PoolTranche); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LendingPool); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Authorization); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Loan); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Referrer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LeafScript); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CetInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LiquidationCet); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RepaymentCet); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DLCMeta); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DepositLog); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Repayment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_bitway_lending_lending_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Redemption); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_bitway_lending_lending_proto_rawDesc,
			NumEnums:      6,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_bitway_lending_lending_proto_goTypes,
		DependencyIndexes: file_bitway_lending_lending_proto_depIdxs,
		EnumInfos:         file_bitway_lending_lending_proto_enumTypes,
		MessageInfos:      file_bitway_lending_lending_proto_msgTypes,
	}.Build()
	File_bitway_lending_lending_proto = out.File
	file_bitway_lending_lending_proto_rawDesc = nil
	file_bitway_lending_lending_proto_goTypes = nil
	file_bitway_lending_lending_proto_depIdxs = nil
}
